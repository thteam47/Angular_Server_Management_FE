{"ast":null,"code":"import { Ajax, extend, getValue, isNullOrUndefined, merge, setValue } from '@syncfusion/ej2-base';\n/**\n * Query class is used to build query which is used by the DataManager to communicate with datasource.\n */\n\nclass Query {\n  /**\n   * Constructor for Query class.\n   * @param  {string|string[]} from?\n   * @hidden\n   */\n  constructor(from) {\n    /** @hidden */\n    this.subQuery = null;\n    /** @hidden */\n\n    this.isChild = false;\n    /** @hidden */\n\n    this.distincts = [];\n    this.queries = [];\n    this.key = '';\n    this.fKey = '';\n\n    if (typeof from === 'string') {\n      this.fromTable = from;\n    } else if (from && from instanceof Array) {\n      this.lookups = from;\n    }\n\n    this.expands = [];\n    this.sortedColumns = [];\n    this.groupedColumns = [];\n    this.subQuery = null;\n    this.isChild = false;\n    this.params = [];\n    this.lazyLoad = [];\n    return this;\n  }\n  /**\n   * Sets the primary key.\n   * @param  {string} field - Defines the column field.\n   */\n\n\n  setKey(field) {\n    this.key = field;\n    return this;\n  }\n  /**\n   * Sets default DataManager to execute query.\n   * @param  {DataManager} dataManager - Defines the DataManager.\n   */\n\n\n  using(dataManager) {\n    this.dataManager = dataManager;\n    return this;\n  }\n  /**\n   * Executes query with the given DataManager.\n   * @param  {DataManager} dataManager - Defines the DataManager.\n   * @param  {Function} done - Defines the success callback.\n   * @param  {Function} fail - Defines the failure callback.\n   * @param  {Function} always - Defines the callback which will be invoked on either success or failure.\n   *\n   * <pre>\n   * let dataManager: DataManager = new DataManager([{ ID: '10' }, { ID: '2' }, { ID: '1' }, { ID: '20' }]);\n   * let query: Query = new Query();\n   * query.sortBy('ID', (x: string, y: string): number => { return parseInt(x, 10) - parseInt(y, 10) });\n   * let promise: Promise< Object > = query.execute(dataManager);\n   * promise.then((e: { result: Object }) => { });\n   * </pre>\n   */\n\n\n  execute(dataManager, done, fail, always) {\n    dataManager = dataManager || this.dataManager;\n\n    if (dataManager) {\n      return dataManager.executeQuery(this, done, fail, always);\n    }\n\n    return DataUtil.throwError('Query - execute() : dataManager needs to be is set using \"using\" function or should be passed as argument');\n  }\n  /**\n   * Executes query with the local datasource.\n   * @param  {DataManager} dataManager - Defines the DataManager.\n   */\n\n\n  executeLocal(dataManager) {\n    dataManager = dataManager || this.dataManager;\n\n    if (dataManager) {\n      return dataManager.executeLocal(this);\n    }\n\n    return DataUtil.throwError('Query - executeLocal() : dataManager needs to be is set using \"using\" function or should be passed as argument');\n  }\n  /**\n   * Creates deep copy of the Query object.\n   */\n\n\n  clone() {\n    let cloned = new Query();\n    cloned.queries = this.queries.slice(0);\n    cloned.key = this.key;\n    cloned.isChild = this.isChild;\n    cloned.dataManager = this.dataManager;\n    cloned.fromTable = this.fromTable;\n    cloned.params = this.params.slice(0);\n    cloned.expands = this.expands.slice(0);\n    cloned.sortedColumns = this.sortedColumns.slice(0);\n    cloned.groupedColumns = this.groupedColumns.slice(0);\n    cloned.subQuerySelector = this.subQuerySelector;\n    cloned.subQuery = this.subQuery;\n    cloned.fKey = this.fKey;\n    cloned.isCountRequired = this.isCountRequired;\n    cloned.distincts = this.distincts.slice(0);\n    cloned.lazyLoad = this.lazyLoad.slice(0);\n    return cloned;\n  }\n  /**\n   * Specifies the name of table to retrieve data in query execution.\n   * @param  {string} tableName - Defines the table name.\n   */\n\n\n  from(tableName) {\n    this.fromTable = tableName;\n    return this;\n  }\n  /**\n   * Adds additional parameter which will be sent along with the request which will be generated while DataManager execute.\n   * @param  {string} key - Defines the key of additional parameter.\n   * @param  {Function|string} value - Defines the value for the key.\n   */\n\n\n  addParams(key, value) {\n    if (typeof value === 'function') {\n      this.params.push({\n        key: key,\n        fn: value\n      });\n    } else {\n      this.params.push({\n        key: key,\n        value: value\n      });\n    }\n\n    return this;\n  }\n  /**\n   * @hidden\n   */\n\n\n  distinct(fields) {\n    if (typeof fields === 'string') {\n      this.distincts = [].slice.call([fields], 0);\n    } else {\n      this.distincts = fields.slice(0);\n    }\n\n    return this;\n  }\n  /**\n   * Expands the related table.\n   * @param  {string|Object[]} tables\n   */\n\n\n  expand(tables) {\n    if (typeof tables === 'string') {\n      this.expands = [].slice.call([tables], 0);\n    } else {\n      this.expands = tables.slice(0);\n    }\n\n    return this;\n  }\n  /**\n   * Filter data with given filter criteria.\n   * @param  {string|Predicate} fieldName - Defines the column field or Predicate.\n   * @param  {string} operator - Defines the operator how to filter data.\n   * @param  {string|number|boolean} value - Defines the values to match with data.\n   * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else\n   * filter data with case insensitive.\n   */\n\n\n  where(fieldName, operator, value, ignoreCase, ignoreAccent) {\n    operator = operator ? operator.toLowerCase() : null;\n    let predicate = null;\n\n    if (typeof fieldName === 'string') {\n      predicate = new Predicate(fieldName, operator, value, ignoreCase, ignoreAccent);\n    } else if (fieldName instanceof Predicate) {\n      predicate = fieldName;\n    }\n\n    this.queries.push({\n      fn: 'onWhere',\n      e: predicate\n    });\n    return this;\n  }\n  /**\n   * Search data with given search criteria.\n   * @param  {string|number|boolean} searchKey - Defines the search key.\n   * @param  {string|string[]} fieldNames - Defines the collection of column fields.\n   * @param  {string} operator - Defines the operator how to search data.\n   * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else\n   * filter data with case insensitive.\n   */\n\n\n  search(searchKey, fieldNames, operator, ignoreCase, ignoreAccent) {\n    if (typeof fieldNames === 'string') {\n      fieldNames = [fieldNames];\n    }\n\n    if (!operator || operator === 'none') {\n      operator = 'contains';\n    }\n\n    let comparer = DataUtil.fnOperators[operator];\n    this.queries.push({\n      fn: 'onSearch',\n      e: {\n        fieldNames: fieldNames,\n        operator: operator,\n        searchKey: searchKey,\n        ignoreCase: ignoreCase,\n        ignoreAccent: ignoreAccent,\n        comparer: comparer\n      }\n    });\n    return this;\n  }\n  /**\n   * Sort the data with given sort criteria.\n   * By default, sort direction is ascending.\n   * @param  {string|string[]} fieldName - Defines the single or collection of column fields.\n   * @param  {string|Function} comparer - Defines the sort direction or custom sort comparer function.\n   */\n\n\n  sortBy(fieldName, comparer, isFromGroup) {\n    return this.sortByForeignKey(fieldName, comparer, isFromGroup);\n  }\n  /**\n   * Sort the data with given sort criteria.\n   * By default, sort direction is ascending.\n   * @param  {string|string[]} fieldName - Defines the single or collection of column fields.\n   * @param  {string|Function} comparer - Defines the sort direction or custom sort comparer function.\n   * @param  {string} direction - Defines the sort direction .\n   */\n\n\n  sortByForeignKey(fieldName, comparer, isFromGroup, direction) {\n    let order = !isNullOrUndefined(direction) ? direction : 'ascending';\n    let sorts;\n    let temp;\n\n    if (typeof fieldName === 'string' && DataUtil.endsWith(fieldName.toLowerCase(), ' desc')) {\n      fieldName = fieldName.replace(/ desc$/i, '');\n      comparer = 'descending';\n    }\n\n    if (!comparer || typeof comparer === 'string') {\n      order = comparer ? comparer.toLowerCase() : 'ascending';\n      comparer = DataUtil.fnSort(comparer);\n    }\n\n    if (isFromGroup) {\n      sorts = Query.filterQueries(this.queries, 'onSortBy');\n\n      for (let i = 0; i < sorts.length; i++) {\n        temp = sorts[i].e.fieldName;\n\n        if (typeof temp === 'string') {\n          if (temp === fieldName) {\n            return this;\n          }\n        } else if (temp instanceof Array) {\n          for (let j = 0; j < temp.length; j++) {\n            if (temp[j] === fieldName || fieldName.toLowerCase() === temp[j] + ' desc') {\n              return this;\n            }\n          }\n        }\n      }\n    }\n\n    this.queries.push({\n      fn: 'onSortBy',\n      e: {\n        fieldName: fieldName,\n        comparer: comparer,\n        direction: order\n      }\n    });\n    return this;\n  }\n  /**\n   * Sorts data in descending order.\n   * @param  {string} fieldName - Defines the column field.\n   */\n\n\n  sortByDesc(fieldName) {\n    return this.sortBy(fieldName, 'descending');\n  }\n  /**\n   * Groups data with the given field name.\n   * @param  {string} fieldName - Defines the column field.\n   */\n\n\n  group(fieldName, fn, format) {\n    this.sortBy(fieldName, null, true);\n    this.queries.push({\n      fn: 'onGroup',\n      e: {\n        fieldName: fieldName,\n        comparer: fn ? fn : null,\n        format: format ? format : null\n      }\n    });\n    return this;\n  }\n  /**\n   * Gets data based on the given page index and size.\n   * @param  {number} pageIndex - Defines the current page index.\n   * @param  {number} pageSize - Defines the no of records per page.\n   */\n\n\n  page(pageIndex, pageSize) {\n    this.queries.push({\n      fn: 'onPage',\n      e: {\n        pageIndex: pageIndex,\n        pageSize: pageSize\n      }\n    });\n    return this;\n  }\n  /**\n   * Gets data based on the given start and end index.\n   * @param  {number} start - Defines the start index of the datasource.\n   * @param  {number} end - Defines the end index of the datasource.\n   */\n\n\n  range(start, end) {\n    this.queries.push({\n      fn: 'onRange',\n      e: {\n        start: start,\n        end: end\n      }\n    });\n    return this;\n  }\n  /**\n   * Gets data from the top of the data source based on given number of records count.\n   * @param  {number} nos - Defines the no of records to retrieve from datasource.\n   */\n\n\n  take(nos) {\n    this.queries.push({\n      fn: 'onTake',\n      e: {\n        nos: nos\n      }\n    });\n    return this;\n  }\n  /**\n   * Skips data with given number of records count from the top of the data source.\n   * @param  {number} nos - Defines the no of records skip in the datasource.\n   */\n\n\n  skip(nos) {\n    this.queries.push({\n      fn: 'onSkip',\n      e: {\n        nos: nos\n      }\n    });\n    return this;\n  }\n  /**\n   * Selects specified columns from the data source.\n   * @param  {string|string[]} fieldNames - Defines the collection of column fields.\n   */\n\n\n  select(fieldNames) {\n    if (typeof fieldNames === 'string') {\n      fieldNames = [].slice.call([fieldNames], 0);\n    }\n\n    this.queries.push({\n      fn: 'onSelect',\n      e: {\n        fieldNames: fieldNames\n      }\n    });\n    return this;\n  }\n  /**\n   * Gets the records in hierarchical relationship from two tables. It requires the foreign key to relate two tables.\n   * @param  {Query} query - Defines the query to relate two tables.\n   * @param  {Function} selectorFn - Defines the custom function to select records.\n   */\n\n\n  hierarchy(query, selectorFn) {\n    this.subQuerySelector = selectorFn;\n    this.subQuery = query;\n    return this;\n  }\n  /**\n   * Sets the foreign key which is used to get data from the related table.\n   * @param  {string} key - Defines the foreign key.\n   */\n\n\n  foreignKey(key) {\n    this.fKey = key;\n    return this;\n  }\n  /**\n   * It is used to get total number of records in the DataManager execution result.\n   */\n\n\n  requiresCount() {\n    this.isCountRequired = true;\n    return this;\n  } //type - sum, avg, min, max\n\n  /**\n   * Aggregate the data with given type and field name.\n   * @param  {string} type - Defines the aggregate type.\n   * @param  {string} field - Defines the column field to aggregate.\n   */\n\n\n  aggregate(type, field) {\n    this.queries.push({\n      fn: 'onAggregates',\n      e: {\n        field: field,\n        type: type\n      }\n    });\n    return this;\n  }\n  /**\n   * Pass array of filterColumn query for performing filter operation.\n   * @param  {QueryOptions[]} queries\n   * @param  {string} name\n   * @hidden\n   */\n\n\n  static filterQueries(queries, name) {\n    return queries.filter(q => {\n      return q.fn === name;\n    });\n  }\n  /**\n   * To get the list of queries which is already filtered in current data source.\n   * @param  {Object[]} queries\n   * @param  {string[]} singles\n   * @hidden\n   */\n\n\n  static filterQueryLists(queries, singles) {\n    let filtered = queries.filter(q => {\n      return singles.indexOf(q.fn) !== -1;\n    });\n    let res = {};\n\n    for (let i = 0; i < filtered.length; i++) {\n      if (!res[filtered[i].fn]) {\n        res[filtered[i].fn] = filtered[i].e;\n      }\n    }\n\n    return res;\n  }\n\n}\n/**\n * Predicate class is used to generate complex filter criteria.\n * This will be used by DataManager to perform multiple filtering operation.\n */\n\n\nclass Predicate {\n  /**\n   * Constructor for Predicate class.\n   * @param  {string|Predicate} field\n   * @param  {string} operator\n   * @param  {string|number|boolean|Predicate|Predicate[]} value\n   * @param  {boolean=false} ignoreCase\n   * @hidden\n   */\n  constructor(field, operator, value, ignoreCase = false, ignoreAccent) {\n    /** @hidden */\n    this.ignoreAccent = false;\n    /** @hidden */\n\n    this.isComplex = false;\n\n    if (typeof field === 'string') {\n      this.field = field;\n      this.operator = operator.toLowerCase();\n      this.value = value;\n      this.ignoreCase = ignoreCase;\n      this.ignoreAccent = ignoreAccent;\n      this.isComplex = false;\n      this.comparer = DataUtil.fnOperators.processOperator(this.operator);\n    } else if (field instanceof Predicate && value instanceof Predicate || value instanceof Array) {\n      this.isComplex = true;\n      this.condition = operator.toLowerCase();\n      this.predicates = [field];\n\n      if (value instanceof Array) {\n        [].push.apply(this.predicates, value);\n      } else {\n        this.predicates.push(value);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Adds n-number of new predicates on existing predicate with “and” condition.\n   * @param  {Object[]} args - Defines the collection of predicates.\n   */\n\n\n  static and(...args) {\n    return Predicate.combinePredicates([].slice.call(args, 0), 'and');\n  }\n  /**\n   * Adds new predicate on existing predicate with “and” condition.\n   * @param  {string} field - Defines the column field.\n   * @param  {string} operator - Defines the operator how to filter data.\n   * @param  {string} value - Defines the values to match with data.\n   * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else\n   * filter data with case insensitive.\n   */\n\n\n  and(field, operator, value, ignoreCase, ignoreAccent) {\n    return Predicate.combine(this, field, operator, value, 'and', ignoreCase, ignoreAccent);\n  }\n  /**\n   * Adds n-number of new predicates on existing predicate with “or” condition.\n   * @param  {Object[]} args - Defines the collection of predicates.\n   */\n\n\n  static or(...args) {\n    return Predicate.combinePredicates([].slice.call(args, 0), 'or');\n  }\n  /**\n   * Adds new predicate on existing predicate with “or” condition.\n   * @param  {string} field - Defines the column field.\n   * @param  {string} operator - Defines the operator how to filter data.\n   * @param  {string} value - Defines the values to match with data.\n   * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else\n   * filter data with case insensitive.\n   */\n\n\n  or(field, operator, value, ignoreCase, ignoreAccent) {\n    return Predicate.combine(this, field, operator, value, 'or', ignoreCase, ignoreAccent);\n  }\n  /**\n   * Converts plain JavaScript object to Predicate object.\n   * @param  {Predicate[]|Predicate} json - Defines single or collection of Predicate.\n   */\n\n\n  static fromJson(json) {\n    if (json instanceof Array) {\n      let res = [];\n\n      for (let i = 0, len = json.length; i < len; i++) {\n        res.push(this.fromJSONData(json[i]));\n      }\n\n      return res;\n    }\n\n    let pred = json;\n    return this.fromJSONData(pred);\n  }\n  /**\n   * Validate the record based on the predicates.\n   * @param  {Object} record - Defines the datasource record.\n   */\n\n\n  validate(record) {\n    let predicate = this.predicates ? this.predicates : [];\n    let isAnd;\n    let ret;\n\n    if (!this.isComplex && this.comparer) {\n      return this.comparer.call(this, DataUtil.getObject(this.field, record), this.value, this.ignoreCase, this.ignoreAccent);\n    }\n\n    isAnd = this.condition === 'and';\n\n    for (let i = 0; i < predicate.length; i++) {\n      ret = predicate[i].validate(record);\n\n      if (isAnd) {\n        if (!ret) {\n          return false;\n        }\n      } else {\n        if (ret) {\n          return true;\n        }\n      }\n    }\n\n    return isAnd;\n  }\n  /**\n   * Converts predicates to plain JavaScript.\n   * This method is uses Json stringify when serializing Predicate object.\n   */\n\n\n  toJson() {\n    let predicates;\n    let p;\n\n    if (this.isComplex) {\n      predicates = [];\n      p = this.predicates;\n\n      for (let i = 0; i < p.length; i++) {\n        predicates.push(p[i].toJson());\n      }\n    }\n\n    return {\n      isComplex: this.isComplex,\n      field: this.field,\n      operator: this.operator,\n      value: this.value,\n      ignoreCase: this.ignoreCase,\n      ignoreAccent: this.ignoreAccent,\n      condition: this.condition,\n      predicates: predicates\n    };\n  }\n\n  static combinePredicates(predicates, operator) {\n    if (predicates.length === 1) {\n      if (!(predicates[0] instanceof Array)) {\n        return predicates[0];\n      }\n\n      predicates = predicates[0];\n    }\n\n    return new Predicate(predicates[0], operator, predicates.slice(1));\n  }\n\n  static combine(pred, field, operator, value, condition, ignoreCase, ignoreAccent) {\n    if (field instanceof Predicate) {\n      return Predicate[condition](pred, field);\n    }\n\n    if (typeof field === 'string') {\n      return Predicate[condition](pred, new Predicate(field, operator, value, ignoreCase, ignoreAccent));\n    }\n\n    return DataUtil.throwError('Predicate - ' + condition + ' : invalid arguments');\n  }\n\n  static fromJSONData(json) {\n    let preds = json.predicates || [];\n    let len = preds.length;\n    let predicates = [];\n    let result;\n\n    for (let i = 0; i < len; i++) {\n      predicates.push(this.fromJSONData(preds[i]));\n    }\n\n    if (!json.isComplex) {\n      result = new Predicate(json.field, json.operator, json.value, json.ignoreCase, json.ignoreAccent);\n    } else {\n      result = new Predicate(predicates[0], json.condition, predicates.slice(1));\n    }\n\n    return result;\n  }\n\n}\n\nconst consts = {\n  GroupGuid: '{271bbba0-1ee7}'\n};\n/**\n * Data manager common utility methods.\n * @hidden\n */\n\nlet DataUtil = /*#__PURE__*/(() => {\n  class DataUtil {\n    /**\n     * Returns the value by invoking the provided parameter function.\n     * If the paramater is not of type function then it will be returned as it is.\n     * @param  {Function|string|string[]|number} value\n     * @param  {Object} inst?\n     * @hidden\n     */\n    static getValue(value, inst) {\n      if (typeof value === 'function') {\n        return value.call(inst || {});\n      }\n\n      return value;\n    }\n    /**\n     * Returns true if the input string ends with given string.\n     * @param  {string} input\n     * @param  {string} substr\n     */\n\n\n    static endsWith(input, substr) {\n      return input.slice && input.slice(-substr.length) === substr;\n    }\n    /**\n     * Returns true if the input string starts with given string.\n     * @param  {string} str\n     * @param  {string} startstr\n     */\n\n\n    static startsWith(input, start) {\n      return input.slice(0, start.length) === start;\n    }\n    /**\n     * To return the sorting function based on the string.\n     * @param  {string} order\n     * @hidden\n     */\n\n\n    static fnSort(order) {\n      order = order ? DataUtil.toLowerCase(order) : 'ascending';\n\n      if (order === 'ascending') {\n        return this.fnAscending;\n      }\n\n      return this.fnDescending;\n    }\n    /**\n     * Comparer function which is used to sort the data in ascending order.\n     * @param  {string|number} x\n     * @param  {string|number} y\n     * @returns number\n     */\n\n\n    static fnAscending(x, y) {\n      if (isNullOrUndefined(x) && isNullOrUndefined(y)) {\n        return -1;\n      }\n\n      if (y === null || y === undefined) {\n        return -1;\n      }\n\n      if (typeof x === 'string') {\n        return x.localeCompare(y);\n      }\n\n      if (x === null || x === undefined) {\n        return 1;\n      }\n\n      return x - y;\n    }\n    /**\n     * Comparer function which is used to sort the data in descending order.\n     * @param  {string|number} x\n     * @param  {string|number} y\n     * @returns number\n     */\n\n\n    static fnDescending(x, y) {\n      if (isNullOrUndefined(x) && isNullOrUndefined(y)) {\n        return -1;\n      }\n\n      if (y === null || y === undefined) {\n        return 1;\n      }\n\n      if (typeof x === 'string') {\n        return x.localeCompare(y) * -1;\n      }\n\n      if (x === null || x === undefined) {\n        return -1;\n      }\n\n      return y - x;\n    }\n\n    static extractFields(obj, fields) {\n      let newObj = {};\n\n      for (let i = 0; i < fields.length; i++) {\n        newObj = this.setValue(fields[i], this.getObject(fields[i], obj), newObj);\n      }\n\n      return newObj;\n    }\n    /**\n     * Select objects by given fields from jsonArray.\n     * @param  {Object[]} jsonArray\n     * @param  {string[]} fields\n     */\n\n\n    static select(jsonArray, fields) {\n      let newData = [];\n\n      for (let i = 0; i < jsonArray.length; i++) {\n        newData.push(this.extractFields(jsonArray[i], fields));\n      }\n\n      return newData;\n    }\n    /**\n     * Group the input data based on the field name.\n     * It also performs aggregation of the grouped records based on the aggregates paramater.\n     * @param  {Object[]} jsonArray\n     * @param  {string} field?\n     * @param  {Object[]} agg?\n     * @param  {number} level?\n     * @param  {Object[]} groupDs?\n     */\n\n\n    static group(jsonArray, field, aggregates, level, groupDs, format, isLazyLoad) {\n      level = level || 1;\n      let jsonData = jsonArray;\n      let guid = 'GroupGuid';\n\n      if (jsonData.GroupGuid === consts[guid]) {\n        for (let j = 0; j < jsonData.length; j++) {\n          if (!isNullOrUndefined(groupDs)) {\n            let indx = -1;\n            let temp = groupDs.filter(e => {\n              return e.key === jsonData[j].key;\n            });\n            indx = groupDs.indexOf(temp[0]);\n            jsonData[j].items = this.group(jsonData[j].items, field, aggregates, jsonData.level + 1, groupDs[indx].items, format, isLazyLoad);\n            jsonData[j].count = groupDs[indx].count;\n          } else {\n            jsonData[j].items = this.group(jsonData[j].items, field, aggregates, jsonData.level + 1, null, format, isLazyLoad);\n            jsonData[j].count = jsonData[j].items.length;\n          }\n        }\n\n        jsonData.childLevels += 1;\n        return jsonData;\n      }\n\n      let grouped = {};\n      let groupedArray = [];\n      groupedArray.GroupGuid = consts[guid];\n      groupedArray.level = level;\n      groupedArray.childLevels = 0;\n      groupedArray.records = jsonData;\n\n      for (let i = 0; i < jsonData.length; i++) {\n        let val = this.getVal(jsonData, i, field);\n\n        if (!isNullOrUndefined(format)) {\n          val = format(val, field);\n        }\n\n        if (!grouped[val]) {\n          grouped[val] = {\n            key: val,\n            count: 0,\n            items: [],\n            aggregates: {},\n            field: field\n          };\n          groupedArray.push(grouped[val]);\n\n          if (!isNullOrUndefined(groupDs)) {\n            let tempObj = groupDs.filter(e => {\n              return e.key === grouped[val].key;\n            });\n            grouped[val].count = tempObj[0].count;\n          }\n        }\n\n        grouped[val].count = !isNullOrUndefined(groupDs) ? grouped[val].count : grouped[val].count += 1;\n\n        if (!isLazyLoad || isLazyLoad && aggregates.length) {\n          grouped[val].items.push(jsonData[i]);\n        }\n      }\n\n      if (aggregates && aggregates.length) {\n        for (let i = 0; i < groupedArray.length; i++) {\n          let res = {};\n          let fn;\n          let aggs = aggregates;\n\n          for (let j = 0; j < aggregates.length; j++) {\n            fn = DataUtil.aggregates[aggregates[j].type];\n\n            if (!isNullOrUndefined(groupDs)) {\n              let temp = groupDs.filter(e => {\n                return e.key === groupedArray[i].key;\n              });\n\n              if (fn) {\n                res[aggs[j].field + ' - ' + aggs[j].type] = fn(temp[0].items, aggs[j].field);\n              }\n            } else {\n              if (fn) {\n                res[aggs[j].field + ' - ' + aggs[j].type] = fn(groupedArray[i].items, aggs[j].field);\n              }\n            }\n          }\n\n          groupedArray[i].aggregates = res;\n        }\n      }\n\n      if (isLazyLoad && groupedArray.length && aggregates.length) {\n        for (let i = 0; i < groupedArray.length; i++) {\n          groupedArray[i].items = [];\n        }\n      }\n\n      return jsonData.length && groupedArray || jsonData;\n    }\n    /**\n     * It is used to categorize the multiple items based on a specific field in jsonArray.\n     * The hierarchical queries are commonly required when you use foreign key binding.\n     * @param  {string} fKey\n     * @param  {string} from\n     * @param  {Object[]} source\n     * @param  {Group} lookup?\n     * @param  {string} pKey?\n     * @hidden\n     */\n\n\n    static buildHierarchy(fKey, from, source, lookup, pKey) {\n      let i;\n      let grp = {};\n      let temp;\n\n      if (lookup.result) {\n        lookup = lookup.result;\n      }\n\n      if (lookup.GroupGuid) {\n        this.throwError('DataManager: Do not have support Grouping in hierarchy');\n      }\n\n      for (i = 0; i < lookup.length; i++) {\n        let fKeyData = this.getObject(fKey, lookup[i]);\n        temp = grp[fKeyData] || (grp[fKeyData] = []);\n        temp.push(lookup[i]);\n      }\n\n      for (i = 0; i < source.length; i++) {\n        let fKeyData = this.getObject(pKey || fKey, source[i]);\n        source[i][from] = grp[fKeyData];\n      }\n    }\n    /**\n     * The method used to get the field names which started with specified characters.\n     * @param  {Object} obj\n     * @param  {string[]} fields?\n     * @param  {string} prefix?\n     * @hidden\n     */\n\n\n    static getFieldList(obj, fields, prefix) {\n      if (prefix === undefined) {\n        prefix = '';\n      }\n\n      if (fields === undefined || fields === null) {\n        return this.getFieldList(obj, [], prefix);\n      }\n\n      let copyObj = obj;\n      let keys = Object.keys(obj);\n\n      for (let prop of keys) {\n        if (typeof copyObj[prop] === 'object' && !(copyObj[prop] instanceof Array)) {\n          this.getFieldList(copyObj[prop], fields, prefix + prop + '.');\n        } else {\n          fields.push(prefix + prop);\n        }\n      }\n\n      return fields;\n    }\n    /**\n     * Gets the value of the property in the given object.\n     * The complex object can be accessed by providing the field names concatenated with dot(.).\n     * @param  {string} nameSpace - The name of the property to be accessed.\n     * @param  {Object} from - Defines the source object.\n     */\n\n\n    static getObject(nameSpace, from) {\n      if (!nameSpace) {\n        return from;\n      }\n\n      if (!from) {\n        return undefined;\n      }\n\n      if (nameSpace.indexOf('.') === -1) {\n        return from[nameSpace];\n      }\n\n      let value = from;\n      let splits = nameSpace.split('.');\n\n      for (let i = 0; i < splits.length; i++) {\n        if (value == null) {\n          break;\n        }\n\n        value = value[splits[i]];\n      }\n\n      return value;\n    }\n    /**\n     * To set value for the nameSpace in desired object.\n     * @param {string} nameSpace - String value to the get the inner object.\n     * @param {Object} value - Value that you need to set.\n     * @param {Object} obj - Object to get the inner object value.\n     * @return { [key: string]: Object; } | Object\n     * @hidden\n     */\n\n\n    static setValue(nameSpace, value, obj) {\n      let keys = nameSpace.toString().split('.');\n      let start = obj || {};\n      let fromObj = start;\n      let i;\n      let length = keys.length;\n      let key;\n\n      for (i = 0; i < length; i++) {\n        key = keys[i];\n\n        if (i + 1 === length) {\n          fromObj[key] = value === undefined ? undefined : value;\n        } else if (isNullOrUndefined(fromObj[key])) {\n          fromObj[key] = {};\n        }\n\n        fromObj = fromObj[key];\n      }\n\n      return start;\n    }\n    /**\n     * Sort the given data based on the field and comparer.\n     * @param  {Object[]} ds - Defines the input data.\n     * @param  {string} field - Defines the field to be sorted.\n     * @param  {Function} comparer - Defines the comparer function used to sort the records.\n     */\n\n\n    static sort(ds, field, comparer) {\n      if (ds.length <= 1) {\n        return ds;\n      }\n\n      let middle = parseInt((ds.length / 2).toString(), 10);\n      let left = ds.slice(0, middle);\n      let right = ds.slice(middle);\n      left = this.sort(left, field, comparer);\n      right = this.sort(right, field, comparer);\n      return this.merge(left, right, field, comparer);\n    }\n\n    static ignoreDiacritics(value) {\n      if (typeof value !== 'string') {\n        return value;\n      }\n\n      let result = value.split('');\n      let newValue = result.map(temp => temp in DataUtil.diacritics ? DataUtil.diacritics[temp] : temp);\n      return newValue.join('');\n    }\n\n    static merge(left, right, fieldName, comparer) {\n      let result = [];\n      let current;\n\n      while (left.length > 0 || right.length > 0) {\n        if (left.length > 0 && right.length > 0) {\n          if (comparer) {\n            current = comparer(this.getVal(left, 0, fieldName), this.getVal(right, 0, fieldName), left[0], right[0]) <= 0 ? left : right;\n          } else {\n            current = left[0][fieldName] < left[0][fieldName] ? left : right;\n          }\n        } else {\n          current = left.length > 0 ? left : right;\n        }\n\n        result.push(current.shift());\n      }\n\n      return result;\n    }\n\n    static getVal(array, index, field) {\n      return field ? this.getObject(field, array[index]) : array[index];\n    }\n\n    static toLowerCase(val) {\n      return val ? typeof val === 'string' ? val.toLowerCase() : val.toString() : val === 0 || val === false ? val.toString() : '';\n    }\n    /**\n     * To perform the filter operation with specified adaptor and returns the result.\n     * @param  {Object} adaptor\n     * @param  {string} fnName\n     * @param  {Object} param1?\n     * @param  {Object} param2?\n     * @hidden\n     */\n\n\n    static callAdaptorFunction(adaptor, fnName, param1, param2) {\n      if (fnName in adaptor) {\n        let res = adaptor[fnName](param1, param2);\n\n        if (!isNullOrUndefined(res)) {\n          param1 = res;\n        }\n      }\n\n      return param1;\n    }\n\n    static getAddParams(adp, dm, query) {\n      let req = {};\n      DataUtil.callAdaptorFunction(adp, 'addParams', {\n        dm: dm,\n        query: query,\n        params: query.params,\n        reqParams: req\n      });\n      return req;\n    }\n    /**\n     * Checks wheather the given input is a plain object or not.\n     * @param  {Object|Object[]} obj\n     */\n\n\n    static isPlainObject(obj) {\n      return !!obj && obj.constructor === Object;\n    }\n    /**\n     * Returns true when the browser cross origin request.\n     */\n\n\n    static isCors() {\n      let xhr = null;\n      let request = 'XMLHttpRequest';\n\n      try {\n        xhr = new window[request]();\n      } catch (e) {// No exception handling\n      }\n\n      return !!xhr && 'withCredentials' in xhr;\n    }\n    /**\n     * Generate random GUID value which will be prefixed with the given value.\n     * @param  {string} prefix\n     */\n\n\n    static getGuid(prefix) {\n      let hexs = '0123456789abcdef';\n      let rand;\n      return (prefix || '') + '00000000-0000-4000-0000-000000000000'.replace(/0/g, (val, i) => {\n        if ('crypto' in window && 'getRandomValues' in crypto) {\n          let arr = new Uint8Array(1);\n          window.crypto.getRandomValues(arr);\n          rand = arr[0] % 16 | 0;\n        } else {\n          rand = Math.random() * 16 | 0;\n        }\n\n        return hexs[i === 19 ? rand & 0x3 | 0x8 : rand];\n      });\n    }\n    /**\n     * Checks wheather the given value is null or not.\n     * @param  {string|Object} val\n     * @returns boolean\n     */\n\n\n    static isNull(val) {\n      return val === undefined || val === null;\n    }\n    /**\n     * To get the required items from collection of objects.\n     * @param  {Object[]} array\n     * @param  {string} field\n     * @param  {Function} comparer\n     * @returns Object\n     * @hidden\n     */\n\n\n    static getItemFromComparer(array, field, comparer) {\n      let keyVal;\n      let current;\n      let key;\n      let i = 0;\n      let castRequired = typeof DataUtil.getVal(array, 0, field) === 'string';\n\n      if (array.length) {\n        while (isNullOrUndefined(keyVal) && i < array.length) {\n          keyVal = DataUtil.getVal(array, i, field);\n          key = array[i++];\n        }\n      }\n\n      for (; i < array.length; i++) {\n        current = DataUtil.getVal(array, i, field);\n\n        if (isNullOrUndefined(current)) {\n          continue;\n        }\n\n        if (castRequired) {\n          keyVal = +keyVal;\n          current = +current;\n        }\n\n        if (comparer(keyVal, current) > 0) {\n          keyVal = current;\n          key = array[i];\n        }\n      }\n\n      return key;\n    }\n    /**\n     * To get distinct values of Array or Array of Objects.\n     * @param  {Object[]} json\n     * @param  {string} field\n     * @param  {boolean} requiresCompleteRecord\n     * @returns Object[]\n     * * distinct array of objects is return when requiresCompleteRecord set as true.\n     * @hidden\n     */\n\n\n    static distinct(json, fieldName, requiresCompleteRecord) {\n      requiresCompleteRecord = isNullOrUndefined(requiresCompleteRecord) ? false : requiresCompleteRecord;\n      let result = [];\n      let val;\n      let tmp = {};\n      json.forEach((data, index) => {\n        val = typeof json[index] === 'object' ? DataUtil.getVal(json, index, fieldName) : json[index];\n\n        if (!(val in tmp)) {\n          result.push(!requiresCompleteRecord ? val : json[index]);\n          tmp[val] = 1;\n        }\n      });\n      return result;\n    }\n    /**\n     * Process the given records based on the datamanager string.\n     * @param  {string} datamanager\n     * @param  {Object[]} records\n     */\n\n\n    static processData(dm, records) {\n      let query = this.prepareQuery(dm);\n      let sampledata = new DataManager(records);\n\n      if (dm.requiresCounts) {\n        query.requiresCount();\n      }\n\n      let result = sampledata.executeLocal(query);\n      let returnValue = {\n        result: dm.requiresCounts ? result.result : result,\n        count: result.count,\n        aggregates: JSON.stringify(result.aggregates)\n      };\n      return dm.requiresCounts ? returnValue : result;\n    }\n\n    static prepareQuery(dm) {\n      let query = new Query();\n\n      if (dm.select) {\n        query.select(dm.select);\n      }\n\n      if (dm.where) {\n        let where = DataUtil.parse.parseJson(dm.where);\n        where.filter(pred => {\n          if (isNullOrUndefined(pred.condition)) {\n            query.where(pred.field, pred.operator, pred.value, pred.ignoreCase, pred.ignoreAccent);\n          } else {\n            let predicateList = [];\n\n            if (pred.field) {\n              predicateList.push(new Predicate(pred.field, pred.operator, pred.value, pred.ignoreCase, pred.ignoreAccent));\n            } else {\n              predicateList = predicateList.concat(this.getPredicate(pred.predicates));\n            }\n\n            if (pred.condition == 'or') {\n              query.where(Predicate.or(predicateList));\n            } else if (pred.condition == 'and') {\n              query.where(Predicate.and(predicateList));\n            }\n          }\n        });\n      }\n\n      if (dm.search) {\n        let search = DataUtil.parse.parseJson(dm.search);\n        search.filter(e => query.search(e.key, e.fields, e['operator'], e['ignoreCase'], e['ignoreAccent']));\n      }\n\n      if (dm.aggregates) {\n        dm.aggregates.filter(e => query.aggregate(e.type, e.field));\n      }\n\n      if (dm.sorted) {\n        dm.sorted.filter(e => query.sortBy(e.name, e.direction));\n      }\n\n      if (dm.skip) {\n        query.skip(dm.skip);\n      }\n\n      if (dm.take) {\n        query.take(dm.take);\n      }\n\n      if (dm.group) {\n        dm.group.filter(grp => query.group(grp));\n      }\n\n      return query;\n    }\n\n    static getPredicate(pred) {\n      let mainPred = [];\n\n      for (let i = 0; i < pred.length; i++) {\n        let e = pred[i];\n\n        if (e.field) {\n          mainPred.push(new Predicate(e.field, e.operator, e.value, e.ignoreCase, e.ignoreAccent));\n        } else {\n          let childPred = [];\n          let cpre = this.getPredicate(e.predicates);\n\n          for (const prop of Object.keys(cpre)) {\n            childPred.push(cpre[prop]);\n          }\n\n          mainPred.push(e.condition == 'or' ? Predicate.or(childPred) : Predicate.and(childPred));\n        }\n      }\n\n      return mainPred;\n    }\n\n  }\n\n  /**\n   * Specifies the value which will be used to adjust the date value to server timezone.\n   * @default null\n   */\n  DataUtil.serverTimezoneOffset = null;\n  /**\n   * Species whether are not to be parsed with serverTimezoneOffset value.\n   * @hidden\n   */\n\n  DataUtil.timeZoneHandling = true;\n  /**\n   * Throw error with the given string as message.\n   * @param  {string} er\n   */\n\n  DataUtil.throwError = error => {\n    try {\n      throw new Error(error);\n    } catch (e) {\n      throw e.message + '\\n' + e.stack;\n    }\n  };\n\n  DataUtil.aggregates = {\n    /**\n     * Calculate sum of the given field in the data.\n     * @param  {Object[]} ds\n     * @param  {string} field\n     */\n    sum: (ds, field) => {\n      let result = 0;\n      let val;\n      let castRequired = typeof DataUtil.getVal(ds, 0, field) !== 'number';\n\n      for (let i = 0; i < ds.length; i++) {\n        val = DataUtil.getVal(ds, i, field);\n\n        if (!isNaN(val) && val !== null) {\n          if (castRequired) {\n            val = +val;\n          }\n\n          result += val;\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Calculate average value of the given field in the data.\n     * @param  {Object[]} ds\n     * @param  {string} field\n     */\n    average: (ds, field) => {\n      return DataUtil.aggregates.sum(ds, field) / ds.length;\n    },\n\n    /**\n     * Returns the min value of the data based on the field.\n     * @param  {Object[]} ds\n     * @param  {string|Function} field\n     */\n    min: (ds, field) => {\n      let comparer;\n\n      if (typeof field === 'function') {\n        comparer = field;\n        field = null;\n      }\n\n      return DataUtil.getObject(field, DataUtil.getItemFromComparer(ds, field, comparer || DataUtil.fnAscending));\n    },\n\n    /**\n     * Returns the max value of the data based on the field.\n     * @param  {Object[]} ds\n     * @param  {string} field\n     * @returns number\n     */\n    max: (ds, field) => {\n      let comparer;\n\n      if (typeof field === 'function') {\n        comparer = field;\n        field = null;\n      }\n\n      return DataUtil.getObject(field, DataUtil.getItemFromComparer(ds, field, comparer || DataUtil.fnDescending));\n    },\n\n    /**\n     * Returns the total number of true value present in the data based on the given boolean field name.\n     * @param  {Object[]} ds\n     * @param  {string} field\n     */\n    truecount: (ds, field) => {\n      return new DataManager(ds).executeLocal(new Query().where(field, 'equal', true, true)).length;\n    },\n\n    /**\n     * Returns the total number of false value present in the data based on the given boolean field name.\n     * @param  {Object[]} ds\n     * @param  {string} field\n     */\n    falsecount: (ds, field) => {\n      return new DataManager(ds).executeLocal(new Query().where(field, 'equal', false, true)).length;\n    },\n\n    /**\n     * Returns the length of the given data.\n     * @param  {Object[]} ds\n     * @param  {string} field?\n     * @returns number\n     */\n    count: (ds, field) => {\n      return ds.length;\n    }\n  };\n  /**\n   * Specifies the Object with filter operators.\n   */\n\n  DataUtil.operatorSymbols = {\n    '<': 'lessthan',\n    '>': 'greaterthan',\n    '<=': 'lessthanorequal',\n    '>=': 'greaterthanorequal',\n    '==': 'equal',\n    '!=': 'notequal',\n    '*=': 'contains',\n    '$=': 'endswith',\n    '^=': 'startswith'\n  };\n  /**\n   * Specifies the Object with filter operators which will be used for OData filter query generation.\n   * * It will be used for date/number type filter query.\n   */\n\n  DataUtil.odBiOperator = {\n    '<': ' lt ',\n    '>': ' gt ',\n    '<=': ' le ',\n    '>=': ' ge ',\n    '==': ' eq ',\n    '!=': ' ne ',\n    'lessthan': ' lt ',\n    'lessthanorequal': ' le ',\n    'greaterthan': ' gt ',\n    'greaterthanorequal': ' ge ',\n    'equal': ' eq ',\n    'notequal': ' ne '\n  };\n  /**\n   * Specifies the Object with filter operators which will be used for OData filter query generation.\n   * It will be used for string type filter query.\n   */\n\n  DataUtil.odUniOperator = {\n    '$=': 'endswith',\n    '^=': 'startswith',\n    '*=': 'substringof',\n    'endswith': 'endswith',\n    'startswith': 'startswith',\n    'contains': 'substringof'\n  };\n  /**\n   * Specifies the Object with filter operators which will be used for ODataV4 filter query generation.\n   * It will be used for string type filter query.\n   */\n\n  DataUtil.odv4UniOperator = {\n    '$=': 'endswith',\n    '^=': 'startswith',\n    '*=': 'contains',\n    'endswith': 'endswith',\n    'startswith': 'startswith',\n    'contains': 'contains'\n  };\n  DataUtil.diacritics = {\n    '\\u24B6': 'A',\n    '\\uFF21': 'A',\n    '\\u00C0': 'A',\n    '\\u00C1': 'A',\n    '\\u00C2': 'A',\n    '\\u1EA6': 'A',\n    '\\u1EA4': 'A',\n    '\\u1EAA': 'A',\n    '\\u1EA8': 'A',\n    '\\u00C3': 'A',\n    '\\u0100': 'A',\n    '\\u0102': 'A',\n    '\\u1EB0': 'A',\n    '\\u1EAE': 'A',\n    '\\u1EB4': 'A',\n    '\\u1EB2': 'A',\n    '\\u0226': 'A',\n    '\\u01E0': 'A',\n    '\\u00C4': 'A',\n    '\\u01DE': 'A',\n    '\\u1EA2': 'A',\n    '\\u00C5': 'A',\n    '\\u01FA': 'A',\n    '\\u01CD': 'A',\n    '\\u0200': 'A',\n    '\\u0202': 'A',\n    '\\u1EA0': 'A',\n    '\\u1EAC': 'A',\n    '\\u1EB6': 'A',\n    '\\u1E00': 'A',\n    '\\u0104': 'A',\n    '\\u023A': 'A',\n    '\\u2C6F': 'A',\n    '\\uA732': 'AA',\n    '\\u00C6': 'AE',\n    '\\u01FC': 'AE',\n    '\\u01E2': 'AE',\n    '\\uA734': 'AO',\n    '\\uA736': 'AU',\n    '\\uA738': 'AV',\n    '\\uA73A': 'AV',\n    '\\uA73C': 'AY',\n    '\\u24B7': 'B',\n    '\\uFF22': 'B',\n    '\\u1E02': 'B',\n    '\\u1E04': 'B',\n    '\\u1E06': 'B',\n    '\\u0243': 'B',\n    '\\u0182': 'B',\n    '\\u0181': 'B',\n    '\\u24B8': 'C',\n    '\\uFF23': 'C',\n    '\\u0106': 'C',\n    '\\u0108': 'C',\n    '\\u010A': 'C',\n    '\\u010C': 'C',\n    '\\u00C7': 'C',\n    '\\u1E08': 'C',\n    '\\u0187': 'C',\n    '\\u023B': 'C',\n    '\\uA73E': 'C',\n    '\\u24B9': 'D',\n    '\\uFF24': 'D',\n    '\\u1E0A': 'D',\n    '\\u010E': 'D',\n    '\\u1E0C': 'D',\n    '\\u1E10': 'D',\n    '\\u1E12': 'D',\n    '\\u1E0E': 'D',\n    '\\u0110': 'D',\n    '\\u018B': 'D',\n    '\\u018A': 'D',\n    '\\u0189': 'D',\n    '\\uA779': 'D',\n    '\\u01F1': 'DZ',\n    '\\u01C4': 'DZ',\n    '\\u01F2': 'Dz',\n    '\\u01C5': 'Dz',\n    '\\u24BA': 'E',\n    '\\uFF25': 'E',\n    '\\u00C8': 'E',\n    '\\u00C9': 'E',\n    '\\u00CA': 'E',\n    '\\u1EC0': 'E',\n    '\\u1EBE': 'E',\n    '\\u1EC4': 'E',\n    '\\u1EC2': 'E',\n    '\\u1EBC': 'E',\n    '\\u0112': 'E',\n    '\\u1E14': 'E',\n    '\\u1E16': 'E',\n    '\\u0114': 'E',\n    '\\u0116': 'E',\n    '\\u00CB': 'E',\n    '\\u1EBA': 'E',\n    '\\u011A': 'E',\n    '\\u0204': 'E',\n    '\\u0206': 'E',\n    '\\u1EB8': 'E',\n    '\\u1EC6': 'E',\n    '\\u0228': 'E',\n    '\\u1E1C': 'E',\n    '\\u0118': 'E',\n    '\\u1E18': 'E',\n    '\\u1E1A': 'E',\n    '\\u0190': 'E',\n    '\\u018E': 'E',\n    '\\u24BB': 'F',\n    '\\uFF26': 'F',\n    '\\u1E1E': 'F',\n    '\\u0191': 'F',\n    '\\uA77B': 'F',\n    '\\u24BC': 'G',\n    '\\uFF27': 'G',\n    '\\u01F4': 'G',\n    '\\u011C': 'G',\n    '\\u1E20': 'G',\n    '\\u011E': 'G',\n    '\\u0120': 'G',\n    '\\u01E6': 'G',\n    '\\u0122': 'G',\n    '\\u01E4': 'G',\n    '\\u0193': 'G',\n    '\\uA7A0': 'G',\n    '\\uA77D': 'G',\n    '\\uA77E': 'G',\n    '\\u24BD': 'H',\n    '\\uFF28': 'H',\n    '\\u0124': 'H',\n    '\\u1E22': 'H',\n    '\\u1E26': 'H',\n    '\\u021E': 'H',\n    '\\u1E24': 'H',\n    '\\u1E28': 'H',\n    '\\u1E2A': 'H',\n    '\\u0126': 'H',\n    '\\u2C67': 'H',\n    '\\u2C75': 'H',\n    '\\uA78D': 'H',\n    '\\u24BE': 'I',\n    '\\uFF29': 'I',\n    '\\u00CC': 'I',\n    '\\u00CD': 'I',\n    '\\u00CE': 'I',\n    '\\u0128': 'I',\n    '\\u012A': 'I',\n    '\\u012C': 'I',\n    '\\u0130': 'I',\n    '\\u00CF': 'I',\n    '\\u1E2E': 'I',\n    '\\u1EC8': 'I',\n    '\\u01CF': 'I',\n    '\\u0208': 'I',\n    '\\u020A': 'I',\n    '\\u1ECA': 'I',\n    '\\u012E': 'I',\n    '\\u1E2C': 'I',\n    '\\u0197': 'I',\n    '\\u24BF': 'J',\n    '\\uFF2A': 'J',\n    '\\u0134': 'J',\n    '\\u0248': 'J',\n    '\\u24C0': 'K',\n    '\\uFF2B': 'K',\n    '\\u1E30': 'K',\n    '\\u01E8': 'K',\n    '\\u1E32': 'K',\n    '\\u0136': 'K',\n    '\\u1E34': 'K',\n    '\\u0198': 'K',\n    '\\u2C69': 'K',\n    '\\uA740': 'K',\n    '\\uA742': 'K',\n    '\\uA744': 'K',\n    '\\uA7A2': 'K',\n    '\\u24C1': 'L',\n    '\\uFF2C': 'L',\n    '\\u013F': 'L',\n    '\\u0139': 'L',\n    '\\u013D': 'L',\n    '\\u1E36': 'L',\n    '\\u1E38': 'L',\n    '\\u013B': 'L',\n    '\\u1E3C': 'L',\n    '\\u1E3A': 'L',\n    '\\u0141': 'L',\n    '\\u023D': 'L',\n    '\\u2C62': 'L',\n    '\\u2C60': 'L',\n    '\\uA748': 'L',\n    '\\uA746': 'L',\n    '\\uA780': 'L',\n    '\\u01C7': 'LJ',\n    '\\u01C8': 'Lj',\n    '\\u24C2': 'M',\n    '\\uFF2D': 'M',\n    '\\u1E3E': 'M',\n    '\\u1E40': 'M',\n    '\\u1E42': 'M',\n    '\\u2C6E': 'M',\n    '\\u019C': 'M',\n    '\\u24C3': 'N',\n    '\\uFF2E': 'N',\n    '\\u01F8': 'N',\n    '\\u0143': 'N',\n    '\\u00D1': 'N',\n    '\\u1E44': 'N',\n    '\\u0147': 'N',\n    '\\u1E46': 'N',\n    '\\u0145': 'N',\n    '\\u1E4A': 'N',\n    '\\u1E48': 'N',\n    '\\u0220': 'N',\n    '\\u019D': 'N',\n    '\\uA790': 'N',\n    '\\uA7A4': 'N',\n    '\\u01CA': 'NJ',\n    '\\u01CB': 'Nj',\n    '\\u24C4': 'O',\n    '\\uFF2F': 'O',\n    '\\u00D2': 'O',\n    '\\u00D3': 'O',\n    '\\u00D4': 'O',\n    '\\u1ED2': 'O',\n    '\\u1ED0': 'O',\n    '\\u1ED6': 'O',\n    '\\u1ED4': 'O',\n    '\\u00D5': 'O',\n    '\\u1E4C': 'O',\n    '\\u022C': 'O',\n    '\\u1E4E': 'O',\n    '\\u014C': 'O',\n    '\\u1E50': 'O',\n    '\\u1E52': 'O',\n    '\\u014E': 'O',\n    '\\u022E': 'O',\n    '\\u0230': 'O',\n    '\\u00D6': 'O',\n    '\\u022A': 'O',\n    '\\u1ECE': 'O',\n    '\\u0150': 'O',\n    '\\u01D1': 'O',\n    '\\u020C': 'O',\n    '\\u020E': 'O',\n    '\\u01A0': 'O',\n    '\\u1EDC': 'O',\n    '\\u1EDA': 'O',\n    '\\u1EE0': 'O',\n    '\\u1EDE': 'O',\n    '\\u1EE2': 'O',\n    '\\u1ECC': 'O',\n    '\\u1ED8': 'O',\n    '\\u01EA': 'O',\n    '\\u01EC': 'O',\n    '\\u00D8': 'O',\n    '\\u01FE': 'O',\n    '\\u0186': 'O',\n    '\\u019F': 'O',\n    '\\uA74A': 'O',\n    '\\uA74C': 'O',\n    '\\u01A2': 'OI',\n    '\\uA74E': 'OO',\n    '\\u0222': 'OU',\n    '\\u24C5': 'P',\n    '\\uFF30': 'P',\n    '\\u1E54': 'P',\n    '\\u1E56': 'P',\n    '\\u01A4': 'P',\n    '\\u2C63': 'P',\n    '\\uA750': 'P',\n    '\\uA752': 'P',\n    '\\uA754': 'P',\n    '\\u24C6': 'Q',\n    '\\uFF31': 'Q',\n    '\\uA756': 'Q',\n    '\\uA758': 'Q',\n    '\\u024A': 'Q',\n    '\\u24C7': 'R',\n    '\\uFF32': 'R',\n    '\\u0154': 'R',\n    '\\u1E58': 'R',\n    '\\u0158': 'R',\n    '\\u0210': 'R',\n    '\\u0212': 'R',\n    '\\u1E5A': 'R',\n    '\\u1E5C': 'R',\n    '\\u0156': 'R',\n    '\\u1E5E': 'R',\n    '\\u024C': 'R',\n    '\\u2C64': 'R',\n    '\\uA75A': 'R',\n    '\\uA7A6': 'R',\n    '\\uA782': 'R',\n    '\\u24C8': 'S',\n    '\\uFF33': 'S',\n    '\\u1E9E': 'S',\n    '\\u015A': 'S',\n    '\\u1E64': 'S',\n    '\\u015C': 'S',\n    '\\u1E60': 'S',\n    '\\u0160': 'S',\n    '\\u1E66': 'S',\n    '\\u1E62': 'S',\n    '\\u1E68': 'S',\n    '\\u0218': 'S',\n    '\\u015E': 'S',\n    '\\u2C7E': 'S',\n    '\\uA7A8': 'S',\n    '\\uA784': 'S',\n    '\\u24C9': 'T',\n    '\\uFF34': 'T',\n    '\\u1E6A': 'T',\n    '\\u0164': 'T',\n    '\\u1E6C': 'T',\n    '\\u021A': 'T',\n    '\\u0162': 'T',\n    '\\u1E70': 'T',\n    '\\u1E6E': 'T',\n    '\\u0166': 'T',\n    '\\u01AC': 'T',\n    '\\u01AE': 'T',\n    '\\u023E': 'T',\n    '\\uA786': 'T',\n    '\\uA728': 'TZ',\n    '\\u24CA': 'U',\n    '\\uFF35': 'U',\n    '\\u00D9': 'U',\n    '\\u00DA': 'U',\n    '\\u00DB': 'U',\n    '\\u0168': 'U',\n    '\\u1E78': 'U',\n    '\\u016A': 'U',\n    '\\u1E7A': 'U',\n    '\\u016C': 'U',\n    '\\u00DC': 'U',\n    '\\u01DB': 'U',\n    '\\u01D7': 'U',\n    '\\u01D5': 'U',\n    '\\u01D9': 'U',\n    '\\u1EE6': 'U',\n    '\\u016E': 'U',\n    '\\u0170': 'U',\n    '\\u01D3': 'U',\n    '\\u0214': 'U',\n    '\\u0216': 'U',\n    '\\u01AF': 'U',\n    '\\u1EEA': 'U',\n    '\\u1EE8': 'U',\n    '\\u1EEE': 'U',\n    '\\u1EEC': 'U',\n    '\\u1EF0': 'U',\n    '\\u1EE4': 'U',\n    '\\u1E72': 'U',\n    '\\u0172': 'U',\n    '\\u1E76': 'U',\n    '\\u1E74': 'U',\n    '\\u0244': 'U',\n    '\\u24CB': 'V',\n    '\\uFF36': 'V',\n    '\\u1E7C': 'V',\n    '\\u1E7E': 'V',\n    '\\u01B2': 'V',\n    '\\uA75E': 'V',\n    '\\u0245': 'V',\n    '\\uA760': 'VY',\n    '\\u24CC': 'W',\n    '\\uFF37': 'W',\n    '\\u1E80': 'W',\n    '\\u1E82': 'W',\n    '\\u0174': 'W',\n    '\\u1E86': 'W',\n    '\\u1E84': 'W',\n    '\\u1E88': 'W',\n    '\\u2C72': 'W',\n    '\\u24CD': 'X',\n    '\\uFF38': 'X',\n    '\\u1E8A': 'X',\n    '\\u1E8C': 'X',\n    '\\u24CE': 'Y',\n    '\\uFF39': 'Y',\n    '\\u1EF2': 'Y',\n    '\\u00DD': 'Y',\n    '\\u0176': 'Y',\n    '\\u1EF8': 'Y',\n    '\\u0232': 'Y',\n    '\\u1E8E': 'Y',\n    '\\u0178': 'Y',\n    '\\u1EF6': 'Y',\n    '\\u1EF4': 'Y',\n    '\\u01B3': 'Y',\n    '\\u024E': 'Y',\n    '\\u1EFE': 'Y',\n    '\\u24CF': 'Z',\n    '\\uFF3A': 'Z',\n    '\\u0179': 'Z',\n    '\\u1E90': 'Z',\n    '\\u017B': 'Z',\n    '\\u017D': 'Z',\n    '\\u1E92': 'Z',\n    '\\u1E94': 'Z',\n    '\\u01B5': 'Z',\n    '\\u0224': 'Z',\n    '\\u2C7F': 'Z',\n    '\\u2C6B': 'Z',\n    '\\uA762': 'Z',\n    '\\u24D0': 'a',\n    '\\uFF41': 'a',\n    '\\u1E9A': 'a',\n    '\\u00E0': 'a',\n    '\\u00E1': 'a',\n    '\\u00E2': 'a',\n    '\\u1EA7': 'a',\n    '\\u1EA5': 'a',\n    '\\u1EAB': 'a',\n    '\\u1EA9': 'a',\n    '\\u00E3': 'a',\n    '\\u0101': 'a',\n    '\\u0103': 'a',\n    '\\u1EB1': 'a',\n    '\\u1EAF': 'a',\n    '\\u1EB5': 'a',\n    '\\u1EB3': 'a',\n    '\\u0227': 'a',\n    '\\u01E1': 'a',\n    '\\u00E4': 'a',\n    '\\u01DF': 'a',\n    '\\u1EA3': 'a',\n    '\\u00E5': 'a',\n    '\\u01FB': 'a',\n    '\\u01CE': 'a',\n    '\\u0201': 'a',\n    '\\u0203': 'a',\n    '\\u1EA1': 'a',\n    '\\u1EAD': 'a',\n    '\\u1EB7': 'a',\n    '\\u1E01': 'a',\n    '\\u0105': 'a',\n    '\\u2C65': 'a',\n    '\\u0250': 'a',\n    '\\uA733': 'aa',\n    '\\u00E6': 'ae',\n    '\\u01FD': 'ae',\n    '\\u01E3': 'ae',\n    '\\uA735': 'ao',\n    '\\uA737': 'au',\n    '\\uA739': 'av',\n    '\\uA73B': 'av',\n    '\\uA73D': 'ay',\n    '\\u24D1': 'b',\n    '\\uFF42': 'b',\n    '\\u1E03': 'b',\n    '\\u1E05': 'b',\n    '\\u1E07': 'b',\n    '\\u0180': 'b',\n    '\\u0183': 'b',\n    '\\u0253': 'b',\n    '\\u24D2': 'c',\n    '\\uFF43': 'c',\n    '\\u0107': 'c',\n    '\\u0109': 'c',\n    '\\u010B': 'c',\n    '\\u010D': 'c',\n    '\\u00E7': 'c',\n    '\\u1E09': 'c',\n    '\\u0188': 'c',\n    '\\u023C': 'c',\n    '\\uA73F': 'c',\n    '\\u2184': 'c',\n    '\\u24D3': 'd',\n    '\\uFF44': 'd',\n    '\\u1E0B': 'd',\n    '\\u010F': 'd',\n    '\\u1E0D': 'd',\n    '\\u1E11': 'd',\n    '\\u1E13': 'd',\n    '\\u1E0F': 'd',\n    '\\u0111': 'd',\n    '\\u018C': 'd',\n    '\\u0256': 'd',\n    '\\u0257': 'd',\n    '\\uA77A': 'd',\n    '\\u01F3': 'dz',\n    '\\u01C6': 'dz',\n    '\\u24D4': 'e',\n    '\\uFF45': 'e',\n    '\\u00E8': 'e',\n    '\\u00E9': 'e',\n    '\\u00EA': 'e',\n    '\\u1EC1': 'e',\n    '\\u1EBF': 'e',\n    '\\u1EC5': 'e',\n    '\\u1EC3': 'e',\n    '\\u1EBD': 'e',\n    '\\u0113': 'e',\n    '\\u1E15': 'e',\n    '\\u1E17': 'e',\n    '\\u0115': 'e',\n    '\\u0117': 'e',\n    '\\u00EB': 'e',\n    '\\u1EBB': 'e',\n    '\\u011B': 'e',\n    '\\u0205': 'e',\n    '\\u0207': 'e',\n    '\\u1EB9': 'e',\n    '\\u1EC7': 'e',\n    '\\u0229': 'e',\n    '\\u1E1D': 'e',\n    '\\u0119': 'e',\n    '\\u1E19': 'e',\n    '\\u1E1B': 'e',\n    '\\u0247': 'e',\n    '\\u025B': 'e',\n    '\\u01DD': 'e',\n    '\\u24D5': 'f',\n    '\\uFF46': 'f',\n    '\\u1E1F': 'f',\n    '\\u0192': 'f',\n    '\\uA77C': 'f',\n    '\\u24D6': 'g',\n    '\\uFF47': 'g',\n    '\\u01F5': 'g',\n    '\\u011D': 'g',\n    '\\u1E21': 'g',\n    '\\u011F': 'g',\n    '\\u0121': 'g',\n    '\\u01E7': 'g',\n    '\\u0123': 'g',\n    '\\u01E5': 'g',\n    '\\u0260': 'g',\n    '\\uA7A1': 'g',\n    '\\u1D79': 'g',\n    '\\uA77F': 'g',\n    '\\u24D7': 'h',\n    '\\uFF48': 'h',\n    '\\u0125': 'h',\n    '\\u1E23': 'h',\n    '\\u1E27': 'h',\n    '\\u021F': 'h',\n    '\\u1E25': 'h',\n    '\\u1E29': 'h',\n    '\\u1E2B': 'h',\n    '\\u1E96': 'h',\n    '\\u0127': 'h',\n    '\\u2C68': 'h',\n    '\\u2C76': 'h',\n    '\\u0265': 'h',\n    '\\u0195': 'hv',\n    '\\u24D8': 'i',\n    '\\uFF49': 'i',\n    '\\u00EC': 'i',\n    '\\u00ED': 'i',\n    '\\u00EE': 'i',\n    '\\u0129': 'i',\n    '\\u012B': 'i',\n    '\\u012D': 'i',\n    '\\u00EF': 'i',\n    '\\u1E2F': 'i',\n    '\\u1EC9': 'i',\n    '\\u01D0': 'i',\n    '\\u0209': 'i',\n    '\\u020B': 'i',\n    '\\u1ECB': 'i',\n    '\\u012F': 'i',\n    '\\u1E2D': 'i',\n    '\\u0268': 'i',\n    '\\u0131': 'i',\n    '\\u24D9': 'j',\n    '\\uFF4A': 'j',\n    '\\u0135': 'j',\n    '\\u01F0': 'j',\n    '\\u0249': 'j',\n    '\\u24DA': 'k',\n    '\\uFF4B': 'k',\n    '\\u1E31': 'k',\n    '\\u01E9': 'k',\n    '\\u1E33': 'k',\n    '\\u0137': 'k',\n    '\\u1E35': 'k',\n    '\\u0199': 'k',\n    '\\u2C6A': 'k',\n    '\\uA741': 'k',\n    '\\uA743': 'k',\n    '\\uA745': 'k',\n    '\\uA7A3': 'k',\n    '\\u24DB': 'l',\n    '\\uFF4C': 'l',\n    '\\u0140': 'l',\n    '\\u013A': 'l',\n    '\\u013E': 'l',\n    '\\u1E37': 'l',\n    '\\u1E39': 'l',\n    '\\u013C': 'l',\n    '\\u1E3D': 'l',\n    '\\u1E3B': 'l',\n    '\\u017F': 'l',\n    '\\u0142': 'l',\n    '\\u019A': 'l',\n    '\\u026B': 'l',\n    '\\u2C61': 'l',\n    '\\uA749': 'l',\n    '\\uA781': 'l',\n    '\\uA747': 'l',\n    '\\u01C9': 'lj',\n    '\\u24DC': 'm',\n    '\\uFF4D': 'm',\n    '\\u1E3F': 'm',\n    '\\u1E41': 'm',\n    '\\u1E43': 'm',\n    '\\u0271': 'm',\n    '\\u026F': 'm',\n    '\\u24DD': 'n',\n    '\\uFF4E': 'n',\n    '\\u01F9': 'n',\n    '\\u0144': 'n',\n    '\\u00F1': 'n',\n    '\\u1E45': 'n',\n    '\\u0148': 'n',\n    '\\u1E47': 'n',\n    '\\u0146': 'n',\n    '\\u1E4B': 'n',\n    '\\u1E49': 'n',\n    '\\u019E': 'n',\n    '\\u0272': 'n',\n    '\\u0149': 'n',\n    '\\uA791': 'n',\n    '\\uA7A5': 'n',\n    '\\u01CC': 'nj',\n    '\\u24DE': 'o',\n    '\\uFF4F': 'o',\n    '\\u00F2': 'o',\n    '\\u00F3': 'o',\n    '\\u00F4': 'o',\n    '\\u1ED3': 'o',\n    '\\u1ED1': 'o',\n    '\\u1ED7': 'o',\n    '\\u1ED5': 'o',\n    '\\u00F5': 'o',\n    '\\u1E4D': 'o',\n    '\\u022D': 'o',\n    '\\u1E4F': 'o',\n    '\\u014D': 'o',\n    '\\u1E51': 'o',\n    '\\u1E53': 'o',\n    '\\u014F': 'o',\n    '\\u022F': 'o',\n    '\\u0231': 'o',\n    '\\u00F6': 'o',\n    '\\u022B': 'o',\n    '\\u1ECF': 'o',\n    '\\u0151': 'o',\n    '\\u01D2': 'o',\n    '\\u020D': 'o',\n    '\\u020F': 'o',\n    '\\u01A1': 'o',\n    '\\u1EDD': 'o',\n    '\\u1EDB': 'o',\n    '\\u1EE1': 'o',\n    '\\u1EDF': 'o',\n    '\\u1EE3': 'o',\n    '\\u1ECD': 'o',\n    '\\u1ED9': 'o',\n    '\\u01EB': 'o',\n    '\\u01ED': 'o',\n    '\\u00F8': 'o',\n    '\\u01FF': 'o',\n    '\\u0254': 'o',\n    '\\uA74B': 'o',\n    '\\uA74D': 'o',\n    '\\u0275': 'o',\n    '\\u01A3': 'oi',\n    '\\u0223': 'ou',\n    '\\uA74F': 'oo',\n    '\\u24DF': 'p',\n    '\\uFF50': 'p',\n    '\\u1E55': 'p',\n    '\\u1E57': 'p',\n    '\\u01A5': 'p',\n    '\\u1D7D': 'p',\n    '\\uA751': 'p',\n    '\\uA753': 'p',\n    '\\uA755': 'p',\n    '\\u24E0': 'q',\n    '\\uFF51': 'q',\n    '\\u024B': 'q',\n    '\\uA757': 'q',\n    '\\uA759': 'q',\n    '\\u24E1': 'r',\n    '\\uFF52': 'r',\n    '\\u0155': 'r',\n    '\\u1E59': 'r',\n    '\\u0159': 'r',\n    '\\u0211': 'r',\n    '\\u0213': 'r',\n    '\\u1E5B': 'r',\n    '\\u1E5D': 'r',\n    '\\u0157': 'r',\n    '\\u1E5F': 'r',\n    '\\u024D': 'r',\n    '\\u027D': 'r',\n    '\\uA75B': 'r',\n    '\\uA7A7': 'r',\n    '\\uA783': 'r',\n    '\\u24E2': 's',\n    '\\uFF53': 's',\n    '\\u00DF': 's',\n    '\\u015B': 's',\n    '\\u1E65': 's',\n    '\\u015D': 's',\n    '\\u1E61': 's',\n    '\\u0161': 's',\n    '\\u1E67': 's',\n    '\\u1E63': 's',\n    '\\u1E69': 's',\n    '\\u0219': 's',\n    '\\u015F': 's',\n    '\\u023F': 's',\n    '\\uA7A9': 's',\n    '\\uA785': 's',\n    '\\u1E9B': 's',\n    '\\u24E3': 't',\n    '\\uFF54': 't',\n    '\\u1E6B': 't',\n    '\\u1E97': 't',\n    '\\u0165': 't',\n    '\\u1E6D': 't',\n    '\\u021B': 't',\n    '\\u0163': 't',\n    '\\u1E71': 't',\n    '\\u1E6F': 't',\n    '\\u0167': 't',\n    '\\u01AD': 't',\n    '\\u0288': 't',\n    '\\u2C66': 't',\n    '\\uA787': 't',\n    '\\uA729': 'tz',\n    '\\u24E4': 'u',\n    '\\uFF55': 'u',\n    '\\u00F9': 'u',\n    '\\u00FA': 'u',\n    '\\u00FB': 'u',\n    '\\u0169': 'u',\n    '\\u1E79': 'u',\n    '\\u016B': 'u',\n    '\\u1E7B': 'u',\n    '\\u016D': 'u',\n    '\\u00FC': 'u',\n    '\\u01DC': 'u',\n    '\\u01D8': 'u',\n    '\\u01D6': 'u',\n    '\\u01DA': 'u',\n    '\\u1EE7': 'u',\n    '\\u016F': 'u',\n    '\\u0171': 'u',\n    '\\u01D4': 'u',\n    '\\u0215': 'u',\n    '\\u0217': 'u',\n    '\\u01B0': 'u',\n    '\\u1EEB': 'u',\n    '\\u1EE9': 'u',\n    '\\u1EEF': 'u',\n    '\\u1EED': 'u',\n    '\\u1EF1': 'u',\n    '\\u1EE5': 'u',\n    '\\u1E73': 'u',\n    '\\u0173': 'u',\n    '\\u1E77': 'u',\n    '\\u1E75': 'u',\n    '\\u0289': 'u',\n    '\\u24E5': 'v',\n    '\\uFF56': 'v',\n    '\\u1E7D': 'v',\n    '\\u1E7F': 'v',\n    '\\u028B': 'v',\n    '\\uA75F': 'v',\n    '\\u028C': 'v',\n    '\\uA761': 'vy',\n    '\\u24E6': 'w',\n    '\\uFF57': 'w',\n    '\\u1E81': 'w',\n    '\\u1E83': 'w',\n    '\\u0175': 'w',\n    '\\u1E87': 'w',\n    '\\u1E85': 'w',\n    '\\u1E98': 'w',\n    '\\u1E89': 'w',\n    '\\u2C73': 'w',\n    '\\u24E7': 'x',\n    '\\uFF58': 'x',\n    '\\u1E8B': 'x',\n    '\\u1E8D': 'x',\n    '\\u24E8': 'y',\n    '\\uFF59': 'y',\n    '\\u1EF3': 'y',\n    '\\u00FD': 'y',\n    '\\u0177': 'y',\n    '\\u1EF9': 'y',\n    '\\u0233': 'y',\n    '\\u1E8F': 'y',\n    '\\u00FF': 'y',\n    '\\u1EF7': 'y',\n    '\\u1E99': 'y',\n    '\\u1EF5': 'y',\n    '\\u01B4': 'y',\n    '\\u024F': 'y',\n    '\\u1EFF': 'y',\n    '\\u24E9': 'z',\n    '\\uFF5A': 'z',\n    '\\u017A': 'z',\n    '\\u1E91': 'z',\n    '\\u017C': 'z',\n    '\\u017E': 'z',\n    '\\u1E93': 'z',\n    '\\u1E95': 'z',\n    '\\u01B6': 'z',\n    '\\u0225': 'z',\n    '\\u0240': 'z',\n    '\\u2C6C': 'z',\n    '\\uA763': 'z',\n    '\\u0386': '\\u0391',\n    '\\u0388': '\\u0395',\n    '\\u0389': '\\u0397',\n    '\\u038A': '\\u0399',\n    '\\u03AA': '\\u0399',\n    '\\u038C': '\\u039F',\n    '\\u038E': '\\u03A5',\n    '\\u03AB': '\\u03A5',\n    '\\u038F': '\\u03A9',\n    '\\u03AC': '\\u03B1',\n    '\\u03AD': '\\u03B5',\n    '\\u03AE': '\\u03B7',\n    '\\u03AF': '\\u03B9',\n    '\\u03CA': '\\u03B9',\n    '\\u0390': '\\u03B9',\n    '\\u03CC': '\\u03BF',\n    '\\u03CD': '\\u03C5',\n    '\\u03CB': '\\u03C5',\n    '\\u03B0': '\\u03C5',\n    '\\u03C9': '\\u03C9',\n    '\\u03C2': '\\u03C3'\n  };\n  DataUtil.fnOperators = {\n    /**\n     * Returns true when the actual input is equal to the given input.\n     * @param  {string|number|boolean} actual\n     * @param  {string|number|boolean} expected\n     * @param  {boolean} ignoreCase?\n     * @param  {boolean} ignoreAccent?\n     */\n    equal: (actual, expected, ignoreCase, ignoreAccent) => {\n      if (ignoreAccent) {\n        actual = DataUtil.ignoreDiacritics(actual);\n        expected = DataUtil.ignoreDiacritics(expected);\n      }\n\n      if (ignoreCase) {\n        return DataUtil.toLowerCase(actual) === DataUtil.toLowerCase(expected);\n      }\n\n      return actual === expected;\n    },\n\n    /**\n     * Returns true when the actual input is not equal to the given input.\n     * @param  {string|number|boolean} actual\n     * @param  {string|number|boolean} expected\n     * @param  {boolean} ignoreCase?\n     */\n    notequal: (actual, expected, ignoreCase, ignoreAccent) => {\n      if (ignoreAccent) {\n        actual = DataUtil.ignoreDiacritics(actual);\n        expected = DataUtil.ignoreDiacritics(expected);\n      }\n\n      return !DataUtil.fnOperators.equal(actual, expected, ignoreCase);\n    },\n\n    /**\n     * Returns true when the actual input is less than to the given input.\n     * @param  {string|number|boolean} actual\n     * @param  {string|number|boolean} expected\n     * @param  {boolean} ignoreCase?\n     */\n    lessthan: (actual, expected, ignoreCase) => {\n      if (ignoreCase) {\n        return DataUtil.toLowerCase(actual) < DataUtil.toLowerCase(expected);\n      }\n\n      if (isNullOrUndefined(actual)) {\n        actual = undefined;\n      }\n\n      return actual < expected;\n    },\n\n    /**\n     * Returns true when the actual input is greater than to the given input.\n     * @param  {string|number|boolean} actual\n     * @param  {string|number|boolean} expected\n     * @param  {boolean} ignoreCase?\n     */\n    greaterthan: (actual, expected, ignoreCase) => {\n      if (ignoreCase) {\n        return DataUtil.toLowerCase(actual) > DataUtil.toLowerCase(expected);\n      }\n\n      return actual > expected;\n    },\n\n    /**\n     * Returns true when the actual input is less than or equal to the given input.\n     * @param  {string|number|boolean} actual\n     * @param  {string|number|boolean} expected\n     * @param  {boolean} ignoreCase?\n     */\n    lessthanorequal: (actual, expected, ignoreCase) => {\n      if (ignoreCase) {\n        return DataUtil.toLowerCase(actual) <= DataUtil.toLowerCase(expected);\n      }\n\n      return actual <= expected;\n    },\n\n    /**\n     * Returns true when the actual input is greater than or equal to the given input.\n     * @param  {string|number|boolean} actual\n     * @param  {string|number|boolean} expected\n     * @param  {boolean} ignoreCase?\n     */\n    greaterthanorequal: (actual, expected, ignoreCase) => {\n      if (ignoreCase) {\n        return DataUtil.toLowerCase(actual) >= DataUtil.toLowerCase(expected);\n      }\n\n      return actual >= expected;\n    },\n\n    /**\n     * Returns true when the actual input contains the given string.\n     * @param  {string|number} actual\n     * @param  {string|number} expected\n     * @param  {boolean} ignoreCase?\n     */\n    contains: (actual, expected, ignoreCase, ignoreAccent) => {\n      if (ignoreAccent) {\n        actual = DataUtil.ignoreDiacritics(actual);\n        expected = DataUtil.ignoreDiacritics(expected);\n      }\n\n      if (ignoreCase) {\n        return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) && DataUtil.toLowerCase(actual).indexOf(DataUtil.toLowerCase(expected)) !== -1;\n      }\n\n      return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) && actual.toString().indexOf(expected) !== -1;\n    },\n\n    /**\n     * Returns true when the given input value is not null.\n     * @param  {string|number} actual\n     * @returns boolean\n     */\n    notnull: actual => {\n      return actual !== null;\n    },\n\n    /**\n     * Returns true when the given input value is null.\n     * @param  {string|number} actual\n     * @returns boolean\n     */\n    isnull: actual => {\n      return actual === null;\n    },\n\n    /**\n     * Returns true when the actual input starts with the given string\n     * @param  {string} actual\n     * @param  {string} expected\n     * @param  {boolean} ignoreCase?\n     */\n    startswith: (actual, expected, ignoreCase, ignoreAccent) => {\n      if (ignoreAccent) {\n        actual = DataUtil.ignoreDiacritics(actual);\n        expected = DataUtil.ignoreDiacritics(expected);\n      }\n\n      if (ignoreCase) {\n        return actual && expected && DataUtil.startsWith(DataUtil.toLowerCase(actual), DataUtil.toLowerCase(expected));\n      }\n\n      return actual && expected && DataUtil.startsWith(actual, expected);\n    },\n\n    /**\n     * Returns true when the actual input ends with the given string.\n     * @param  {string} actual\n     * @param  {string} expected\n     * @param  {boolean} ignoreCase?\n     */\n    endswith: (actual, expected, ignoreCase, ignoreAccent) => {\n      if (ignoreAccent) {\n        actual = DataUtil.ignoreDiacritics(actual);\n        expected = DataUtil.ignoreDiacritics(expected);\n      }\n\n      if (ignoreCase) {\n        return actual && expected && DataUtil.endsWith(DataUtil.toLowerCase(actual), DataUtil.toLowerCase(expected));\n      }\n\n      return actual && expected && DataUtil.endsWith(actual, expected);\n    },\n\n    /**\n     * It will return the filter operator based on the filter symbol.\n     * @param  {string} operator\n     * @hidden\n     */\n    processSymbols: operator => {\n      let fnName = DataUtil.operatorSymbols[operator];\n\n      if (fnName) {\n        let fn = DataUtil.fnOperators[fnName];\n        return fn;\n      }\n\n      return DataUtil.throwError('Query - Process Operator : Invalid operator');\n    },\n\n    /**\n     * It will return the valid filter operator based on the specified operators.\n     * @param  {string} operator\n     * @hidden\n     */\n    processOperator: operator => {\n      let fn = DataUtil.fnOperators[operator];\n\n      if (fn) {\n        return fn;\n      }\n\n      return DataUtil.fnOperators.processSymbols(operator);\n    }\n  };\n  /**\n   * To perform the parse operation on JSON data, like convert to string from JSON or convert to JSON from string.\n   */\n\n  DataUtil.parse = {\n    /**\n     * Parse the given string to the plain JavaScript object.\n     * @param  {string|Object|Object[]} jsonText\n     */\n    parseJson: jsonText => {\n      if (typeof jsonText === 'string') {\n        jsonText = JSON.parse(jsonText, DataUtil.parse.jsonReviver);\n      } else if (jsonText instanceof Array) {\n        DataUtil.parse.iterateAndReviveArray(jsonText);\n      } else if (typeof jsonText === 'object' && jsonText !== null) {\n        DataUtil.parse.iterateAndReviveJson(jsonText);\n      }\n\n      return jsonText;\n    },\n\n    /**\n     * It will perform on array of values.\n     * @param  {string[]|Object[]} array\n     * @hidden\n     */\n    iterateAndReviveArray: array => {\n      for (let i = 0; i < array.length; i++) {\n        if (typeof array[i] === 'object' && array[i] !== null) {\n          DataUtil.parse.iterateAndReviveJson(array[i]);\n        } else if (typeof array[i] === 'string' && !/^[\\s]*\\[|^[\\s]*\\{(.)+:|\\\"/g.test(array[i])) {\n          array[i] = DataUtil.parse.jsonReviver('', array[i]);\n        } else {\n          array[i] = DataUtil.parse.parseJson(array[i]);\n        }\n      }\n    },\n\n    /**\n     * It will perform on JSON values\n     * @param  {JSON} json\n     * @hidden\n     */\n    iterateAndReviveJson: json => {\n      let value;\n      let keys = Object.keys(json);\n\n      for (let prop of keys) {\n        if (DataUtil.startsWith(prop, '__')) {\n          continue;\n        }\n\n        value = json[prop];\n\n        if (typeof value === 'object') {\n          if (value instanceof Array) {\n            DataUtil.parse.iterateAndReviveArray(value);\n          } else if (value) {\n            DataUtil.parse.iterateAndReviveJson(value);\n          }\n        } else {\n          json[prop] = DataUtil.parse.jsonReviver(json[prop], value);\n        }\n      }\n    },\n\n    /**\n     * It will perform on JSON values\n     * @param  {string} field\n     * @param  {string|Date} value\n     * @hidden\n     */\n    jsonReviver: (field, value) => {\n      if (typeof value === 'string') {\n        let ms = /^\\/Date\\(([+-]?[0-9]+)([+-][0-9]{4})?\\)\\/$/.exec(value);\n        let offSet = DataUtil.timeZoneHandling ? DataUtil.serverTimezoneOffset : null;\n\n        if (ms) {\n          return DataUtil.dateParse.toTimeZone(new Date(parseInt(ms[1], 10)), offSet, true);\n        } else if (/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*){1})([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/.test(value)) {\n          let isUTC = value.indexOf('Z') > -1 || value.indexOf('z') > -1;\n          let arr = value.split(/[^0-9.]/);\n\n          if (isUTC) {\n            value = DataUtil.dateParse.toTimeZone(new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5], 10)), DataUtil.serverTimezoneOffset, false);\n          } else {\n            let utcFormat = new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5], 10));\n            let hrs = parseInt(arr[6], 10);\n            let mins = parseInt(arr[7], 10);\n\n            if (isNaN(hrs) && isNaN(mins)) {\n              return utcFormat;\n            }\n\n            if (value.indexOf('+') > -1) {\n              utcFormat.setHours(utcFormat.getHours() - hrs, utcFormat.getMinutes() - mins);\n            } else {\n              utcFormat.setHours(utcFormat.getHours() + hrs, utcFormat.getMinutes() + mins);\n            }\n\n            value = DataUtil.dateParse.toTimeZone(utcFormat, DataUtil.serverTimezoneOffset, false);\n          }\n\n          if (DataUtil.serverTimezoneOffset == null) {\n            value = DataUtil.dateParse.addSelfOffset(value);\n          }\n        }\n      }\n\n      return value;\n    },\n\n    /**\n     * Check wheather the given value is JSON or not.\n     * @param  {Object[]} jsonData\n     */\n    isJson: jsonData => {\n      if (typeof jsonData[0] === 'string') {\n        return jsonData;\n      }\n\n      return DataUtil.parse.parseJson(jsonData);\n    },\n\n    /**\n     * Checks wheather the given value is GUID or not.\n     * @param  {string} value\n     */\n    isGuid: value => {\n      let regex = /[A-Fa-f0-9]{8}(?:-[A-Fa-f0-9]{4}){3}-[A-Fa-f0-9]{12}/i;\n      let match = regex.exec(value);\n      return match != null;\n    },\n\n    /**\n     * The method used to replace the value based on the type.\n     * @param  {Object} value\n     * @param  {boolean} stringify\n     * @hidden\n     */\n    replacer: (value, stringify) => {\n      if (DataUtil.isPlainObject(value)) {\n        return DataUtil.parse.jsonReplacer(value, stringify);\n      }\n\n      if (value instanceof Array) {\n        return DataUtil.parse.arrayReplacer(value);\n      }\n\n      if (value instanceof Date) {\n        return DataUtil.parse.jsonReplacer({\n          val: value\n        }, stringify).val;\n      }\n\n      return value;\n    },\n\n    /**\n     * It will replace the JSON value.\n     * @param  {string} key\n     * @param  {Object} val\n     * @hidden\n     */\n    jsonReplacer: (val, stringify) => {\n      let value;\n      let keys = Object.keys(val);\n\n      for (let prop of keys) {\n        value = val[prop];\n\n        if (!(value instanceof Date)) {\n          continue;\n        }\n\n        let d = value;\n\n        if (DataUtil.serverTimezoneOffset == null) {\n          val[prop] = DataUtil.dateParse.toTimeZone(d, null).toJSON();\n        } else {\n          d = new Date(+d + DataUtil.serverTimezoneOffset * 3600000);\n          val[prop] = DataUtil.dateParse.toTimeZone(DataUtil.dateParse.addSelfOffset(d), null).toJSON();\n        }\n      }\n\n      return val;\n    },\n\n    /**\n     * It will replace the Array of value.\n     * @param  {string} key\n     * @param  {Object[]} val\n     * @hidden\n     */\n    arrayReplacer: val => {\n      for (let i = 0; i < val.length; i++) {\n        if (DataUtil.isPlainObject(val[i])) {\n          val[i] = DataUtil.parse.jsonReplacer(val[i]);\n        } else if (val[i] instanceof Date) {\n          val[i] = DataUtil.parse.jsonReplacer({\n            date: val[i]\n          }).date;\n        }\n      }\n\n      return val;\n    },\n\n    /**\n     * It will replace the Date object with respective to UTC format value.\n     * @param  {string} key\n     * @param  {any} value\n     * @hidden\n     */\n\n    /* tslint:disable-next-line:no-any */\n    jsonDateReplacer: (key, value) => {\n      if (key === 'value' && value) {\n        if (typeof value === 'string') {\n          let ms = /^\\/Date\\(([+-]?[0-9]+)([+-][0-9]{4})?\\)\\/$/.exec(value);\n\n          if (ms) {\n            value = DataUtil.dateParse.toTimeZone(new Date(parseInt(ms[1], 10)), null, true);\n          } else if (/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*){1})([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/.test(value)) {\n            let arr = value.split(/[^0-9]/);\n            value = DataUtil.dateParse.toTimeZone(new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5], 10)), null, true);\n          }\n        }\n\n        if (value instanceof Date) {\n          value = DataUtil.dateParse.addSelfOffset(value);\n\n          if (DataUtil.serverTimezoneOffset === null) {\n            return DataUtil.dateParse.toTimeZone(DataUtil.dateParse.addSelfOffset(value), null).toJSON();\n          } else {\n            value = DataUtil.dateParse.toTimeZone(value, value.getTimezoneOffset() / 60 * 2 - DataUtil.serverTimezoneOffset, false);\n            return value.toJSON();\n          }\n        }\n      }\n\n      return value;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n  DataUtil.dateParse = {\n    addSelfOffset: input => {\n      return new Date(+input - input.getTimezoneOffset() * 60000);\n    },\n    toUTC: input => {\n      return new Date(+input + input.getTimezoneOffset() * 60000);\n    },\n    toTimeZone: (input, offset, utc) => {\n      if (offset === null) {\n        return input;\n      }\n\n      let unix = utc ? DataUtil.dateParse.toUTC(input) : input;\n      return new Date(+unix - offset * 3600000);\n    },\n    toLocalTime: input => {\n      let datefn = input;\n      let timeZone = -datefn.getTimezoneOffset();\n      let differenceString = timeZone >= 0 ? '+' : '-';\n\n      let localtimefn = num => {\n        let norm = Math.floor(Math.abs(num));\n        return (norm < 10 ? '0' : '') + norm;\n      };\n\n      let val = datefn.getFullYear() + '-' + localtimefn(datefn.getMonth() + 1) + '-' + localtimefn(datefn.getDate()) + 'T' + localtimefn(datefn.getHours()) + ':' + localtimefn(datefn.getMinutes()) + ':' + localtimefn(datefn.getSeconds()) + differenceString + localtimefn(timeZone / 60) + ':' + localtimefn(timeZone % 60);\n      return val;\n    }\n  };\n  return DataUtil;\n})();\nconst consts$1 = {\n  GroupGuid: '{271bbba0-1ee7}'\n};\n/**\n * Adaptors are specific data source type aware interfaces that are used by DataManager to communicate with DataSource.\n * This is the base adaptor class that other adaptors can extend.\n * @hidden\n */\n\nclass Adaptor {\n  /**\n   * Constructor for Adaptor class\n   * @param  {DataOptions} ds?\n   * @hidden\n   * @returns aggregates\n   */\n  constructor(ds) {\n    // common options for all the adaptors \n    this.options = {\n      from: 'table',\n      requestType: 'json',\n      sortBy: 'sorted',\n      select: 'select',\n      skip: 'skip',\n      group: 'group',\n      take: 'take',\n      search: 'search',\n      count: 'requiresCounts',\n      where: 'where',\n      aggregates: 'aggregates',\n      expand: 'expand'\n    };\n    /**\n     * Specifies the type of adaptor.\n     * @default Adaptor\n     */\n\n    this.type = Adaptor;\n    this.dataSource = ds;\n    this.pvt = {};\n  }\n  /**\n   * Returns the data from the query processing.\n   * @param  {Object} data\n   * @param  {DataOptions} ds?\n   * @param  {Query} query?\n   * @param  {XMLHttpRequest} xhr?\n   * @returns Object\n   */\n\n\n  processResponse(data, ds, query, xhr) {\n    return data;\n  }\n\n}\n/**\n * JsonAdaptor is used to process JSON data. It contains methods to process the given JSON data based on the queries.\n * @hidden\n */\n\n\nclass JsonAdaptor extends Adaptor {\n  /**\n   * Process the JSON data based on the provided queries.\n   * @param  {DataManager} dataManager\n   * @param  {Query} query\n   * @returns Object\n   */\n  processQuery(dataManager, query) {\n    let result = dataManager.dataSource.json.slice(0);\n    let count = result.length;\n    let countFlg = true;\n    let ret;\n    let key;\n    let lazyLoad = {};\n    let keyCount = 0;\n    let group = [];\n    let page;\n\n    for (let i = 0; i < query.lazyLoad.length; i++) {\n      keyCount++;\n      lazyLoad[query.lazyLoad[i].key] = query.lazyLoad[i].value;\n    }\n\n    let agg = {};\n\n    for (let i = 0; i < query.queries.length; i++) {\n      key = query.queries[i];\n\n      if ((key.fn === 'onPage' || key.fn === 'onGroup') && query.lazyLoad.length) {\n        if (key.fn === 'onGroup') {\n          group.push(key.e);\n        }\n\n        if (key.fn === 'onPage') {\n          page = key.e;\n        }\n\n        continue;\n      }\n\n      ret = this[key.fn].call(this, result, key.e, query);\n\n      if (key.fn === 'onAggregates') {\n        agg[key.e.field + ' - ' + key.e.type] = ret;\n      } else {\n        result = ret !== undefined ? ret : result;\n      }\n\n      if (key.fn === 'onPage' || key.fn === 'onSkip' || key.fn === 'onTake' || key.fn === 'onRange') {\n        countFlg = false;\n      }\n\n      if (countFlg) {\n        count = result.length;\n      }\n    }\n\n    if (keyCount) {\n      let args = {\n        query: query,\n        lazyLoad: lazyLoad,\n        result: result,\n        group: group,\n        page: page\n      };\n      let lazyLoadData = this.lazyLoadGroup(args);\n      result = lazyLoadData.result;\n      count = lazyLoadData.count;\n    }\n\n    if (query.isCountRequired) {\n      result = {\n        result: result,\n        count: count,\n        aggregates: agg\n      };\n    }\n\n    return result;\n  }\n  /**\n   * Perform lazy load grouping in JSON array based on the given query and lazy load details.\n   * @param  {LazyLoadGroupArgs} args\n   */\n\n\n  lazyLoadGroup(args) {\n    let count = 0;\n    let agg = this.getAggregate(args.query);\n    let result = args.result;\n\n    if (!isNullOrUndefined(args.lazyLoad.onDemandGroupInfo)) {\n      let req = args.lazyLoad.onDemandGroupInfo;\n\n      for (let i = req.where.length - 1; i >= 0; i--) {\n        result = this.onWhere(result, req.where[i]);\n      }\n\n      if (args.group.length !== req.level) {\n        let field = args.group[req.level].fieldName;\n        result = DataUtil.group(result, field, agg, null, null, args.group[0].comparer, true);\n      }\n\n      count = result.length;\n      let data = result;\n      result = result.slice(req.skip);\n      result = result.slice(0, req.take);\n\n      if (args.group.length !== req.level) {\n        this.formGroupResult(result, data);\n      }\n    } else {\n      let field = args.group[0].fieldName;\n      result = DataUtil.group(result, field, agg, null, null, args.group[0].comparer, true);\n      count = result.length;\n      let data = result;\n\n      if (args.page) {\n        result = this.onPage(result, args.page, args.query);\n      }\n\n      this.formGroupResult(result, data);\n    }\n\n    return {\n      result: result,\n      count: count\n    };\n  }\n\n  formGroupResult(result, data) {\n    if (result.length && data.length) {\n      let uid = 'GroupGuid';\n      let childLevel = 'childLevels';\n      let level = 'level';\n      let records = 'records';\n      result[uid] = data[uid];\n      result[childLevel] = data[childLevel];\n      result[level] = data[level];\n      result[records] = data[records];\n    }\n\n    return result;\n  }\n  /**\n   * Separate the aggregate query from the given queries\n   * @param  {Query} query\n   */\n\n\n  getAggregate(query) {\n    let aggQuery = Query.filterQueries(query.queries, 'onAggregates');\n    let agg = [];\n\n    if (aggQuery.length) {\n      let tmp;\n\n      for (let i = 0; i < aggQuery.length; i++) {\n        tmp = aggQuery[i].e;\n        agg.push({\n          type: tmp.type,\n          field: DataUtil.getValue(tmp.field, query)\n        });\n      }\n    }\n\n    return agg;\n  }\n  /**\n   * Performs batch update in the JSON array which add, remove and update records.\n   * @param  {DataManager} dm\n   * @param  {CrudOptions} changes\n   * @param  {RemoteArgs} e\n   */\n\n\n  batchRequest(dm, changes, e) {\n    let i;\n    let deletedRecordsLen = changes.deletedRecords.length;\n\n    for (i = 0; i < changes.addedRecords.length; i++) {\n      this.insert(dm, changes.addedRecords[i]);\n    }\n\n    for (i = 0; i < changes.changedRecords.length; i++) {\n      this.update(dm, e.key, changes.changedRecords[i]);\n    }\n\n    for (i = 0; i < deletedRecordsLen; i++) {\n      this.remove(dm, e.key, changes.deletedRecords[i]);\n    }\n\n    return changes;\n  }\n  /**\n   * Performs filter operation with the given data and where query.\n   * @param  {Object[]} ds\n   * @param  {{validate:Function}} e\n   */\n\n\n  onWhere(ds, e) {\n    if (!ds || !ds.length) {\n      return ds;\n    }\n\n    return ds.filter(obj => {\n      if (e) {\n        return e.validate(obj);\n      }\n    });\n  }\n  /**\n   * Returns aggregate function based on the aggregate type.\n   * @param  {Object[]} ds\n   * @param  {{field:string} e\n   * @param  {string}} type\n   */\n\n\n  onAggregates(ds, e) {\n    let fn = DataUtil.aggregates[e.type];\n\n    if (!ds || !fn || ds.length === 0) {\n      return null;\n    }\n\n    return fn(ds, e.field);\n  }\n  /**\n   * Performs search operation based on the given query.\n   * @param  {Object[]} ds\n   * @param  {QueryOptions} e\n   */\n\n\n  onSearch(ds, e) {\n    if (!ds || !ds.length) {\n      return ds;\n    }\n\n    if (e.fieldNames.length === 0) {\n      DataUtil.getFieldList(ds[0], e.fieldNames);\n    }\n\n    return ds.filter(obj => {\n      for (let j = 0; j < e.fieldNames.length; j++) {\n        if (e.comparer.call(obj, DataUtil.getObject(e.fieldNames[j], obj), e.searchKey, e.ignoreCase, e.ignoreAccent)) {\n          return true;\n        }\n      }\n\n      return false;\n    });\n  }\n  /**\n   * Sort the data with given direction and field.\n   * @param  {Object[]} ds\n   * @param  {{comparer:(a:Object} e\n   * @param  {Object} b\n   */\n\n\n  onSortBy(ds, e, query) {\n    if (!ds || !ds.length) {\n      return ds;\n    }\n\n    let fnCompare;\n    let field = DataUtil.getValue(e.fieldName, query);\n\n    if (!field) {\n      return ds.sort(e.comparer);\n    }\n\n    if (field instanceof Array) {\n      field = field.slice(0);\n\n      for (let i = field.length - 1; i >= 0; i--) {\n        if (!field[i]) {\n          continue;\n        }\n\n        fnCompare = e.comparer;\n\n        if (DataUtil.endsWith(field[i], ' desc')) {\n          fnCompare = DataUtil.fnSort('descending');\n          field[i] = field[i].replace(' desc', '');\n        }\n\n        ds = DataUtil.sort(ds, field[i], fnCompare);\n      }\n\n      return ds;\n    }\n\n    return DataUtil.sort(ds, field, e.comparer);\n  }\n  /**\n   * Group the data based on the given query.\n   * @param  {Object[]} ds\n   * @param  {QueryOptions} e\n   * @param  {Query} query\n   */\n\n\n  onGroup(ds, e, query) {\n    if (!ds || !ds.length) {\n      return ds;\n    }\n\n    let agg = this.getAggregate(query);\n    return DataUtil.group(ds, DataUtil.getValue(e.fieldName, query), agg, null, null, e.comparer);\n  }\n  /**\n   * Retrieves records based on the given page index and size.\n   * @param  {Object[]} ds\n   * @param  {{pageSize:number} e\n   * @param  {number}} pageIndex\n   * @param  {Query} query\n   */\n\n\n  onPage(ds, e, query) {\n    let size = DataUtil.getValue(e.pageSize, query);\n    let start = (DataUtil.getValue(e.pageIndex, query) - 1) * size;\n    let end = start + size;\n\n    if (!ds || !ds.length) {\n      return ds;\n    }\n\n    return ds.slice(start, end);\n  }\n  /**\n   * Retrieves records based on the given start and end index from query.\n   * @param  {Object[]} ds\n   * @param  {{start:number} e\n   * @param  {number}} end\n   */\n\n\n  onRange(ds, e) {\n    if (!ds || !ds.length) {\n      return ds;\n    }\n\n    return ds.slice(DataUtil.getValue(e.start), DataUtil.getValue(e.end));\n  }\n  /**\n   * Picks the given count of records from the top of the datasource.\n   * @param  {Object[]} ds\n   * @param  {{nos:number}} e\n   */\n\n\n  onTake(ds, e) {\n    if (!ds || !ds.length) {\n      return ds;\n    }\n\n    return ds.slice(0, DataUtil.getValue(e.nos));\n  }\n  /**\n   * Skips the given count of records from the data source.\n   * @param  {Object[]} ds\n   * @param  {{nos:number}} e\n   */\n\n\n  onSkip(ds, e) {\n    if (!ds || !ds.length) {\n      return ds;\n    }\n\n    return ds.slice(DataUtil.getValue(e.nos));\n  }\n  /**\n   * Selects specified columns from the data source.\n   * @param  {Object[]} ds\n   * @param  {{fieldNames:string}} e\n   */\n\n\n  onSelect(ds, e) {\n    if (!ds || !ds.length) {\n      return ds;\n    }\n\n    return DataUtil.select(ds, DataUtil.getValue(e.fieldNames));\n  }\n  /**\n   * Inserts new record in the table.\n   * @param  {DataManager} dm\n   * @param  {Object} data\n   * @param  {number} position\n   */\n\n\n  insert(dm, data, tableName, query, position) {\n    if (isNullOrUndefined(position)) {\n      return dm.dataSource.json.push(data);\n    } else {\n      return dm.dataSource.json.splice(position, 0, data);\n    }\n  }\n  /**\n   * Remove the data from the dataSource based on the key field value.\n   * @param  {DataManager} dm\n   * @param  {string} keyField\n   * @param  {Object} value\n   * @param  {string} tableName?\n   * @returns null\n   */\n\n\n  remove(dm, keyField, value, tableName) {\n    let ds = dm.dataSource.json;\n    let i;\n\n    if (typeof value === 'object' && !(value instanceof Date)) {\n      value = DataUtil.getObject(keyField, value);\n    }\n\n    for (i = 0; i < ds.length; i++) {\n      if (DataUtil.getObject(keyField, ds[i]) === value) {\n        break;\n      }\n    }\n\n    return i !== ds.length ? ds.splice(i, 1) : null;\n  }\n  /**\n   * Updates existing record and saves the changes to the table.\n   * @param  {DataManager} dm\n   * @param  {string} keyField\n   * @param  {Object} value\n   * @param  {string} tableName?\n   * @returns null\n   */\n\n\n  update(dm, keyField, value, tableName) {\n    let ds = dm.dataSource.json;\n    let i;\n    let key;\n\n    if (!isNullOrUndefined(keyField)) {\n      key = getValue(keyField, value);\n    }\n\n    for (i = 0; i < ds.length; i++) {\n      if (!isNullOrUndefined(keyField) && getValue(keyField, ds[i]) === key) {\n        break;\n      }\n    }\n\n    return i < ds.length ? merge(ds[i], value) : null;\n  }\n\n}\n/**\n * URL Adaptor of DataManager can be used when you are required to use remote service to retrieve data.\n * It interacts with server-side for all DataManager Queries and CRUD operations.\n * @hidden\n */\n\n\nclass UrlAdaptor extends Adaptor {\n  /**\n   * Process the query to generate request body.\n   * @param  {DataManager} dm\n   * @param  {Query} query\n   * @param  {Object[]} hierarchyFilters?\n   * @returns p\n   */\n  // tslint:disable-next-line:max-func-body-length\n  processQuery(dm, query, hierarchyFilters) {\n    let queries = this.getQueryRequest(query);\n    let singles = Query.filterQueryLists(query.queries, ['onSelect', 'onPage', 'onSkip', 'onTake', 'onRange']);\n    let params = query.params;\n    let url = dm.dataSource.url;\n    let temp;\n    let skip;\n    let take = null;\n    let options = this.options;\n    let request = {\n      sorts: [],\n      groups: [],\n      filters: [],\n      searches: [],\n      aggregates: []\n    }; // calc Paging & Range\n\n    if ('onPage' in singles) {\n      temp = singles.onPage;\n      skip = DataUtil.getValue(temp.pageIndex, query);\n      take = DataUtil.getValue(temp.pageSize, query);\n      skip = (skip - 1) * take;\n    } else if ('onRange' in singles) {\n      temp = singles.onRange;\n      skip = temp.start;\n      take = temp.end - temp.start;\n    } // Sorting\n\n\n    for (let i = 0; i < queries.sorts.length; i++) {\n      temp = DataUtil.getValue(queries.sorts[i].e.fieldName, query);\n      request.sorts.push(DataUtil.callAdaptorFunction(this, 'onEachSort', {\n        name: temp,\n        direction: queries.sorts[i].e.direction\n      }, query));\n    } // hierarchy\n\n\n    if (hierarchyFilters) {\n      temp = this.getFiltersFrom(hierarchyFilters, query);\n\n      if (temp) {\n        request.filters.push(DataUtil.callAdaptorFunction(this, 'onEachWhere', temp.toJson(), query));\n      }\n    } // Filters\n\n\n    for (let i = 0; i < queries.filters.length; i++) {\n      let res = DataUtil.callAdaptorFunction(this, 'onEachWhere', queries.filters[i].e.toJson(), query);\n\n      if (this.getModuleName && this.getModuleName() === 'ODataV4Adaptor' && !isNullOrUndefined(queries.filters[i].e.key) && queries.filters.length > 1) {\n        res = \"(\" + res + \")\";\n      }\n\n      request.filters.push(res);\n      let keys = typeof request.filters[i] === 'object' ? Object.keys(request.filters[i]) : [];\n\n      for (let prop of keys) {\n        if (DataUtil.isNull(request[prop])) {\n          delete request[prop];\n        }\n      }\n    } // Searches\n\n\n    for (let i = 0; i < queries.searches.length; i++) {\n      temp = queries.searches[i].e;\n      request.searches.push(DataUtil.callAdaptorFunction(this, 'onEachSearch', {\n        fields: temp.fieldNames,\n        operator: temp.operator,\n        key: temp.searchKey,\n        ignoreCase: temp.ignoreCase\n      }, query));\n    } // Grouping\n\n\n    for (let i = 0; i < queries.groups.length; i++) {\n      request.groups.push(DataUtil.getValue(queries.groups[i].e.fieldName, query));\n    } // aggregates\n\n\n    for (let i = 0; i < queries.aggregates.length; i++) {\n      temp = queries.aggregates[i].e;\n      request.aggregates.push({\n        type: temp.type,\n        field: DataUtil.getValue(temp.field, query)\n      });\n    }\n\n    let req = {};\n    this.getRequestQuery(options, query, singles, request, req); // Params\n\n    DataUtil.callAdaptorFunction(this, 'addParams', {\n      dm: dm,\n      query: query,\n      params: params,\n      reqParams: req\n    });\n\n    if (query.lazyLoad.length) {\n      for (let i = 0; i < query.lazyLoad.length; i++) {\n        req[query.lazyLoad[i].key] = query.lazyLoad[i].value;\n      }\n    } // cleanup\n\n\n    let keys = Object.keys(req);\n\n    for (let prop of keys) {\n      if (DataUtil.isNull(req[prop]) || req[prop] === '' || req[prop].length === 0) {\n        delete req[prop];\n      }\n    }\n\n    if (!(options.skip in req && options.take in req) && take !== null) {\n      req[options.skip] = DataUtil.callAdaptorFunction(this, 'onSkip', skip, query);\n      req[options.take] = DataUtil.callAdaptorFunction(this, 'onTake', take, query);\n    }\n\n    let p = this.pvt;\n    this.pvt = {};\n\n    if (this.options.requestType === 'json') {\n      return {\n        data: JSON.stringify(req, DataUtil.parse.jsonDateReplacer),\n        url: url,\n        pvtData: p,\n        type: 'POST',\n        contentType: 'application/json; charset=utf-8'\n      };\n    }\n\n    temp = this.convertToQueryString(req, query, dm);\n    temp = (dm.dataSource.url.indexOf('?') !== -1 ? '&' : '/') + temp;\n    return {\n      type: 'GET',\n      url: temp.length ? url.replace(/\\/*$/, temp) : url,\n      pvtData: p\n    };\n  }\n\n  getRequestQuery(options, query, singles, request, request1) {\n    let param = 'param';\n    let req = request1;\n    req[options.from] = query.fromTable;\n\n    if (options.apply && query.distincts.length) {\n      req[options.apply] = 'onDistinct' in this ? DataUtil.callAdaptorFunction(this, 'onDistinct', query.distincts) : '';\n    }\n\n    if (!query.distincts.length && options.expand) {\n      req[options.expand] = 'onExpand' in this && 'onSelect' in singles ? DataUtil.callAdaptorFunction(this, 'onExpand', {\n        selects: DataUtil.getValue(singles.onSelect.fieldNames, query),\n        expands: query.expands\n      }, query) : query.expands;\n    }\n\n    req[options.select] = 'onSelect' in singles && !query.distincts.length ? DataUtil.callAdaptorFunction(this, 'onSelect', DataUtil.getValue(singles.onSelect.fieldNames, query), query) : '';\n    req[options.count] = query.isCountRequired ? DataUtil.callAdaptorFunction(this, 'onCount', query.isCountRequired, query) : '';\n    req[options.search] = request.searches.length ? DataUtil.callAdaptorFunction(this, 'onSearch', request.searches, query) : '';\n    req[options.skip] = 'onSkip' in singles ? DataUtil.callAdaptorFunction(this, 'onSkip', DataUtil.getValue(singles.onSkip.nos, query), query) : '';\n    req[options.take] = 'onTake' in singles ? DataUtil.callAdaptorFunction(this, 'onTake', DataUtil.getValue(singles.onTake.nos, query), query) : '';\n    req[options.where] = request.filters.length || request.searches.length ? DataUtil.callAdaptorFunction(this, 'onWhere', request.filters, query) : '';\n    req[options.sortBy] = request.sorts.length ? DataUtil.callAdaptorFunction(this, 'onSortBy', request.sorts, query) : '';\n    req[options.group] = request.groups.length ? DataUtil.callAdaptorFunction(this, 'onGroup', request.groups, query) : '';\n    req[options.aggregates] = request.aggregates.length ? DataUtil.callAdaptorFunction(this, 'onAggregates', request.aggregates, query) : '';\n    req[param] = [];\n  }\n  /**\n   * Convert the object from processQuery to string which can be added query string.\n   * @param  {Object} req\n   * @param  {Query} query\n   * @param  {DataManager} dm\n   */\n\n\n  convertToQueryString(request, query, dm) {\n    return ''; // this needs to be overridden\n  }\n  /**\n   * Return the data from the data manager processing.\n   * @param  {DataResult} data\n   * @param  {DataOptions} ds?\n   * @param  {Query} query?\n   * @param  {XMLHttpRequest} xhr?\n   * @param  {Object} request?\n   * @param  {CrudOptions} changes?\n   */\n\n\n  processResponse(data, ds, query, xhr, request, changes) {\n    if (xhr && xhr.getResponseHeader('Content-Type') && xhr.getResponseHeader('Content-Type').indexOf('application/json') !== -1) {\n      let handleTimeZone = DataUtil.timeZoneHandling;\n\n      if (ds && !ds.timeZoneHandling) {\n        DataUtil.timeZoneHandling = false;\n      }\n\n      data = DataUtil.parse.parseJson(data);\n      DataUtil.timeZoneHandling = handleTimeZone;\n    }\n\n    let requests = request;\n    let pvt = requests.pvtData || {};\n    let groupDs = data ? data.groupDs : [];\n\n    if (xhr && xhr.getResponseHeader('Content-Type') && xhr.getResponseHeader('Content-Type').indexOf('xml') !== -1) {\n      return query.isCountRequired ? {\n        result: [],\n        count: 0\n      } : [];\n    }\n\n    let d = JSON.parse(requests.data);\n\n    if (d && d.action === 'batch' && data && data.addedRecords) {\n      changes.addedRecords = data.addedRecords;\n      return changes;\n    }\n\n    if (data && data.d) {\n      data = data.d;\n    }\n\n    let args = {};\n\n    if (data && 'count' in data) {\n      args.count = data.count;\n    }\n\n    args.result = data && data.result ? data.result : data;\n    let isExpand = false;\n\n    if (Array.isArray(data.result) && data.result.length) {\n      let key = 'key';\n      let val = 'value';\n      let level = 'level';\n\n      if (!isNullOrUndefined(data.result[0][key])) {\n        args.result = this.formRemoteGroupedData(args.result, 1, pvt.groups.length - 1);\n      }\n\n      if (query && query.lazyLoad.length && pvt.groups.length) {\n        for (let i = 0; i < query.lazyLoad.length; i++) {\n          if (query.lazyLoad[i][key] === 'onDemandGroupInfo') {\n            let value = query.lazyLoad[i][val][level];\n\n            if (pvt.groups.length === value) {\n              isExpand = true;\n            }\n          }\n        }\n      }\n    }\n\n    if (!isExpand) {\n      this.getAggregateResult(pvt, data, args, groupDs, query);\n    }\n\n    return DataUtil.isNull(args.count) ? args.result : {\n      result: args.result,\n      count: args.count,\n      aggregates: args.aggregates\n    };\n  }\n\n  formRemoteGroupedData(data, level, childLevel) {\n    for (let i = 0; i < data.length; i++) {\n      if (data[i].items.length && Object.keys(data[i].items[0]).indexOf('key') > -1) {\n        this.formRemoteGroupedData(data[i].items, level + 1, childLevel - 1);\n      }\n    }\n\n    let uid = 'GroupGuid';\n    let childLvl = 'childLevels';\n    let lvl = 'level';\n    let records = 'records';\n    data[uid] = consts$1[uid];\n    data[lvl] = level;\n    data[childLvl] = childLevel;\n    data[records] = data[0].items.length ? this.getGroupedRecords(data, !isNullOrUndefined(data[0].items[records])) : [];\n    return data;\n  }\n\n  getGroupedRecords(data, hasRecords) {\n    let childGroupedRecords = [];\n    let records = 'records';\n\n    for (let i = 0; i < data.length; i++) {\n      if (!hasRecords) {\n        for (let j = 0; j < data[i].items.length; j++) {\n          childGroupedRecords.push(data[i].items[j]);\n        }\n      } else {\n        childGroupedRecords = childGroupedRecords.concat(data[i].items[records]);\n      }\n    }\n\n    return childGroupedRecords;\n  }\n  /**\n   * Add the group query to the adaptor`s option.\n   * @param  {Object[]} e\n   * @returns void\n   */\n\n\n  onGroup(e) {\n    this.pvt.groups = e;\n    return e;\n  }\n  /**\n   * Add the aggregate query to the adaptor`s option.\n   * @param  {Aggregates[]} e\n   * @returns void\n   */\n\n\n  onAggregates(e) {\n    this.pvt.aggregates = e;\n  }\n  /**\n   * Prepare the request body based on the newly added, removed and updated records.\n   * The result is used by the batch request.\n   * @param  {DataManager} dm\n   * @param  {CrudOptions} changes\n   * @param  {Object} e\n   */\n\n\n  batchRequest(dm, changes, e, query, original) {\n    let url;\n    let key;\n    return {\n      type: 'POST',\n      url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.removeUrl || dm.dataSource.url,\n      contentType: 'application/json; charset=utf-8',\n      dataType: 'json',\n      data: JSON.stringify(extend({}, {\n        changed: changes.changedRecords,\n        added: changes.addedRecords,\n        deleted: changes.deletedRecords,\n        action: 'batch',\n        table: e[url],\n        key: e[key]\n      }, DataUtil.getAddParams(this, dm, query)))\n    };\n  }\n  /**\n   * Method will trigger before send the request to server side.\n   * Used to set the custom header or modify the request options.\n   * @param  {DataManager} dm\n   * @param  {XMLHttpRequest} request\n   * @returns void\n   */\n\n\n  beforeSend(dm, request) {// need to extend this method\n  }\n  /**\n   * Prepare and returns request body which is used to insert a new record in the table.\n   * @param  {DataManager} dm\n   * @param  {Object} data\n   * @param  {string} tableName\n   */\n\n\n  insert(dm, data, tableName, query) {\n    return {\n      url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,\n      data: JSON.stringify(extend({}, {\n        value: data,\n        table: tableName,\n        action: 'insert'\n      }, DataUtil.getAddParams(this, dm, query)))\n    };\n  }\n  /**\n   * Prepare and return request body which is used to remove record from the table.\n   * @param  {DataManager} dm\n   * @param  {string} keyField\n   * @param  {number|string} value\n   * @param  {string} tableName\n   */\n\n\n  remove(dm, keyField, value, tableName, query) {\n    return {\n      type: 'POST',\n      url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,\n      data: JSON.stringify(extend({}, {\n        key: value,\n        keyColumn: keyField,\n        table: tableName,\n        action: 'remove'\n      }, DataUtil.getAddParams(this, dm, query)))\n    };\n  }\n  /**\n   * Prepare and return request body which is used to update record.\n   * @param  {DataManager} dm\n   * @param  {string} keyField\n   * @param  {Object} value\n   * @param  {string} tableName\n   */\n\n\n  update(dm, keyField, value, tableName, query) {\n    return {\n      type: 'POST',\n      url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,\n      data: JSON.stringify(extend({}, {\n        value: value,\n        action: 'update',\n        keyColumn: keyField,\n        key: DataUtil.getObject(keyField, value),\n        table: tableName\n      }, DataUtil.getAddParams(this, dm, query)))\n    };\n  }\n  /**\n   * To generate the predicate based on the filtered query.\n   * @param  {Object[]|string[]|number[]} data\n   * @param  {Query} query\n   * @hidden\n   */\n\n\n  getFiltersFrom(data, query) {\n    let key = query.fKey;\n    let value;\n    let prop = key;\n    let pKey = query.key;\n    let predicats = [];\n\n    if (typeof data[0] !== 'object') {\n      prop = null;\n    }\n\n    for (let i = 0; i < data.length; i++) {\n      if (typeof data[0] === 'object') {\n        value = DataUtil.getObject(pKey || prop, data[i]);\n      } else {\n        value = data[i];\n      }\n\n      predicats.push(new Predicate(key, 'equal', value));\n    }\n\n    return Predicate.or(predicats);\n  }\n\n  getAggregateResult(pvt, data, args, groupDs, query) {\n    let pData = data;\n\n    if (data && data.result) {\n      pData = data.result;\n    }\n\n    if (pvt && pvt.aggregates && pvt.aggregates.length) {\n      let agg = pvt.aggregates;\n      let fn;\n      let aggregateData = pData;\n      let res = {};\n\n      if (data.aggregate) {\n        aggregateData = data.aggregate;\n      }\n\n      for (let i = 0; i < agg.length; i++) {\n        fn = DataUtil.aggregates[agg[i].type];\n\n        if (fn) {\n          res[agg[i].field + ' - ' + agg[i].type] = fn(aggregateData, agg[i].field);\n        }\n      }\n\n      args.aggregates = res;\n    }\n\n    let key = 'key';\n    let isServerGrouping = Array.isArray(data.result) && data.result.length && !isNullOrUndefined(data.result[0][key]);\n\n    if (pvt && pvt.groups && pvt.groups.length && !isServerGrouping) {\n      let groups = pvt.groups;\n\n      for (let i = 0; i < groups.length; i++) {\n        let level = null;\n\n        if (!isNullOrUndefined(groupDs)) {\n          groupDs = DataUtil.group(groupDs, groups[i]);\n        }\n\n        let groupQuery = Query.filterQueries(query.queries, 'onGroup')[i].e;\n        pData = DataUtil.group(pData, groups[i], pvt.aggregates, level, groupDs, groupQuery.comparer);\n      }\n\n      args.result = pData;\n    }\n\n    return args;\n  }\n\n  getQueryRequest(query) {\n    let req = {\n      sorts: [],\n      groups: [],\n      filters: [],\n      searches: [],\n      aggregates: []\n    };\n    req.sorts = Query.filterQueries(query.queries, 'onSortBy');\n    req.groups = Query.filterQueries(query.queries, 'onGroup');\n    req.filters = Query.filterQueries(query.queries, 'onWhere');\n    req.searches = Query.filterQueries(query.queries, 'onSearch');\n    req.aggregates = Query.filterQueries(query.queries, 'onAggregates');\n    return req;\n  }\n\n  addParams(options) {\n    let req = options.reqParams;\n\n    if (options.params.length) {\n      req.params = {};\n    }\n\n    for (let tmp of options.params) {\n      if (req[tmp.key]) {\n        throw new Error('Query() - addParams: Custom Param is conflicting other request arguments');\n      }\n\n      req[tmp.key] = tmp.value;\n\n      if (tmp.fn) {\n        req[tmp.key] = tmp.fn.call(options.query, tmp.key, options.query, options.dm);\n      }\n\n      req.params[tmp.key] = req[tmp.key];\n    }\n  }\n\n}\n/**\n * OData Adaptor that is extended from URL Adaptor, is used for consuming data through OData Service.\n * @hidden\n */\n\n\nclass ODataAdaptor extends UrlAdaptor {\n  constructor(props) {\n    super(); // options replaced the default adaptor options\n\n    this.options = extend({}, this.options, {\n      requestType: 'get',\n      accept: 'application/json;odata=light;q=1,application/json;odata=verbose;q=0.5',\n      multipartAccept: 'multipart/mixed',\n      sortBy: '$orderby',\n      select: '$select',\n      skip: '$skip',\n      take: '$top',\n      count: '$inlinecount',\n      where: '$filter',\n      expand: '$expand',\n      batch: '$batch',\n      changeSet: '--changeset_',\n      batchPre: 'batch_',\n      contentId: 'Content-Id: ',\n      batchContent: 'Content-Type: multipart/mixed; boundary=',\n      changeSetContent: 'Content-Type: application/http\\nContent-Transfer-Encoding: binary ',\n      batchChangeSetContentType: 'Content-Type: application/json; charset=utf-8 ',\n      updateType: 'PUT'\n    });\n    extend(this.options, props || {});\n  }\n\n  getModuleName() {\n    return 'ODataAdaptor';\n  }\n  /**\n   * Generate request string based on the filter criteria from query.\n   * @param  {Predicate} pred\n   * @param  {boolean} requiresCast?\n   */\n\n\n  onPredicate(predicate, query, requiresCast) {\n    let returnValue = '';\n    let operator;\n    let guid;\n    let val = predicate.value;\n    let type = typeof val;\n    let field = predicate.field ? ODataAdaptor.getField(predicate.field) : null;\n\n    if (val instanceof Date) {\n      val = 'datetime\\'' + DataUtil.parse.replacer(val) + '\\'';\n    }\n\n    if (type === 'string') {\n      val = encodeURIComponent(val);\n      val = '\\'' + val + '\\'';\n\n      if (requiresCast) {\n        field = 'cast(' + field + ', \\'Edm.String\\')';\n      }\n\n      if (DataUtil.parse.isGuid(val)) {\n        guid = 'guid';\n      }\n\n      if (predicate.ignoreCase) {\n        if (!guid) {\n          field = 'tolower(' + field + ')';\n        }\n\n        val = val.toLowerCase();\n      }\n    }\n\n    operator = DataUtil.odBiOperator[predicate.operator];\n\n    if (operator) {\n      returnValue += field;\n      returnValue += operator;\n\n      if (guid) {\n        returnValue += guid;\n      }\n\n      return returnValue + val;\n    }\n\n    if (!isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor') {\n      operator = DataUtil.odv4UniOperator[predicate.operator];\n    } else {\n      operator = DataUtil.odUniOperator[predicate.operator];\n    }\n\n    if (operator === 'substringof') {\n      let temp = val;\n      val = field;\n      field = temp;\n    }\n\n    returnValue += operator + '(';\n    returnValue += field + ',';\n\n    if (guid) {\n      returnValue += guid;\n    }\n\n    returnValue += val + ')';\n    return returnValue;\n  }\n\n  addParams(options) {\n    super.addParams(options);\n    delete options.reqParams.params;\n  }\n  /**\n   * Generate request string based on the multiple filter criteria from query.\n   * @param  {Predicate} pred\n   * @param  {boolean} requiresCast?\n   */\n\n\n  onComplexPredicate(predicate, query, requiresCast) {\n    let res = [];\n\n    for (let i = 0; i < predicate.predicates.length; i++) {\n      res.push('(' + this.onEachWhere(predicate.predicates[i], query, requiresCast) + ')');\n    }\n\n    return res.join(' ' + predicate.condition + ' ');\n  }\n  /**\n   * Generate query string based on the multiple filter criteria from query.\n   * @param  {Predicate} filter\n   * @param  {boolean} requiresCast?\n   */\n\n\n  onEachWhere(filter, query, requiresCast) {\n    return filter.isComplex ? this.onComplexPredicate(filter, query, requiresCast) : this.onPredicate(filter, query, requiresCast);\n  }\n  /**\n   * Generate query string based on the multiple filter criteria from query.\n   * @param  {string[]} filters\n   */\n\n\n  onWhere(filters) {\n    if (this.pvt.search) {\n      filters.push(this.onEachWhere(this.pvt.search, null, true));\n    }\n\n    return filters.join(' and ');\n  }\n  /**\n   * Generate query string based on the multiple search criteria from query.\n   * @param  {{fields:string[]} e\n   * @param  {string} operator\n   * @param  {string} key\n   * @param  {boolean}} ignoreCase\n   */\n\n\n  onEachSearch(e) {\n    if (e.fields && e.fields.length === 0) {\n      DataUtil.throwError('Query() - Search : oData search requires list of field names to search');\n    }\n\n    let filter = this.pvt.search || [];\n\n    for (let i = 0; i < e.fields.length; i++) {\n      filter.push(new Predicate(e.fields[i], e.operator, e.key, e.ignoreCase));\n    }\n\n    this.pvt.search = filter;\n  }\n  /**\n   * Generate query string based on the search criteria from query.\n   * @param  {Object} e\n   */\n\n\n  onSearch(e) {\n    this.pvt.search = Predicate.or(this.pvt.search);\n    return '';\n  }\n  /**\n   * Generate query string based on multiple sort criteria from query.\n   * @param  {QueryOptions} e\n   */\n\n\n  onEachSort(e) {\n    let res = [];\n\n    if (e.name instanceof Array) {\n      for (let i = 0; i < e.name.length; i++) {\n        res.push(ODataAdaptor.getField(e.name[i]) + (e.direction === 'descending' ? ' desc' : ''));\n      }\n    } else {\n      res.push(ODataAdaptor.getField(e.name) + (e.direction === 'descending' ? ' desc' : ''));\n    }\n\n    return res.join(',');\n  }\n  /**\n   * Returns sort query string.\n   * @param  {string[]} e\n   */\n\n\n  onSortBy(e) {\n    return e.reverse().join(',');\n  }\n  /**\n   * Adds the group query to the adaptor option.\n   * @param  {Object[]} e\n   * @returns string\n   */\n\n\n  onGroup(e) {\n    this.pvt.groups = e;\n    return [];\n  }\n  /**\n   * Returns the select query string.\n   * @param  {string[]} e\n   */\n\n\n  onSelect(e) {\n    for (let i = 0; i < e.length; i++) {\n      e[i] = ODataAdaptor.getField(e[i]);\n    }\n\n    return e.join(',');\n  }\n  /**\n   * Add the aggregate query to the adaptor option.\n   * @param  {Object[]} e\n   * @returns string\n   */\n\n\n  onAggregates(e) {\n    this.pvt.aggregates = e;\n    return '';\n  }\n  /**\n   * Returns the query string which requests total count from the data source.\n   * @param  {boolean} e\n   * @returns string\n   */\n\n\n  onCount(e) {\n    return e === true ? 'allpages' : '';\n  }\n  /**\n   * Method will trigger before send the request to server side.\n   * Used to set the custom header or modify the request options.\n   * @param  {DataManager} dm\n   * @param  {XMLHttpRequest} request\n   * @param  {Ajax} settings?\n   */\n\n\n  beforeSend(dm, request, settings) {\n    if (DataUtil.endsWith(settings.url, this.options.batch) && settings.type.toLowerCase() === 'post') {\n      request.setRequestHeader('Accept', this.options.multipartAccept);\n      request.setRequestHeader('DataServiceVersion', '2.0');\n      request.overrideMimeType('text/plain; charset=x-user-defined');\n    } else {\n      request.setRequestHeader('Accept', this.options.accept);\n    }\n\n    request.setRequestHeader('DataServiceVersion', '2.0');\n    request.setRequestHeader('MaxDataServiceVersion', '2.0');\n  }\n  /**\n   * Returns the data from the query processing.\n   * @param  {DataResult} data\n   * @param  {DataOptions} ds?\n   * @param  {Query} query?\n   * @param  {XMLHttpRequest} xhr?\n   * @param  {Ajax} request?\n   * @param  {CrudOptions} changes?\n   * @returns aggregateResult\n   */\n\n\n  processResponse(data, ds, query, xhr, request, changes) {\n    let metaCheck = 'odata.metadata';\n\n    if (request && request.type === 'GET' && !this.rootUrl && data[metaCheck]) {\n      let dataUrls = data[metaCheck].split('/$metadata#');\n      this.rootUrl = dataUrls[0];\n      this.resourceTableName = dataUrls[1];\n    }\n\n    let pvtData = 'pvtData';\n\n    if (!isNullOrUndefined(data.d)) {\n      let dataCopy = query && query.isCountRequired ? data.d.results : data.d;\n      let metaData = '__metadata';\n\n      if (!isNullOrUndefined(dataCopy)) {\n        for (let i = 0; i < dataCopy.length; i++) {\n          if (!isNullOrUndefined(dataCopy[i][metaData])) {\n            delete dataCopy[i][metaData];\n          }\n        }\n      }\n    }\n\n    let pvt = request && request[pvtData];\n    let emptyAndBatch = this.processBatchResponse(data, query, xhr, request, changes);\n\n    if (emptyAndBatch) {\n      return emptyAndBatch;\n    }\n\n    let versionCheck = xhr && request.getResponseHeader('DataServiceVersion');\n    let count = null;\n    let version = versionCheck && parseInt(versionCheck, 10) || 2;\n\n    if (query && query.isCountRequired) {\n      let oDataCount = '__count';\n\n      if (data[oDataCount] || data['odata.count']) {\n        count = data[oDataCount] || data['odata.count'];\n      }\n\n      if (data.d) {\n        data = data.d;\n      }\n\n      if (data[oDataCount] || data['odata.count']) {\n        count = data[oDataCount] || data['odata.count'];\n      }\n    }\n\n    if (version === 3 && data.value) {\n      data = data.value;\n    }\n\n    if (data.d) {\n      data = data.d;\n    }\n\n    if (version < 3 && data.results) {\n      data = data.results;\n    }\n\n    let args = {};\n    args.count = count;\n    args.result = data;\n    this.getAggregateResult(pvt, data, args, null, query);\n    return DataUtil.isNull(count) ? args.result : {\n      result: args.result,\n      count: args.count,\n      aggregates: args.aggregates\n    };\n  }\n  /**\n   * Converts the request object to query string.\n   * @param  {Object} req\n   * @param  {Query} query\n   * @param  {DataManager} dm\n   * @returns tableName\n   */\n\n\n  convertToQueryString(request, query, dm) {\n    let res = [];\n    let table = 'table';\n    let tableName = request[table] || '';\n    let format = '$format';\n    delete request[table];\n\n    if (dm.dataSource.requiresFormat) {\n      request[format] = 'json';\n    }\n\n    let keys = Object.keys(request);\n\n    for (let prop of keys) {\n      res.push(prop + '=' + request[prop]);\n    }\n\n    res = res.join('&');\n\n    if (dm.dataSource.url && dm.dataSource.url.indexOf('?') !== -1 && !tableName) {\n      return res;\n    }\n\n    return res.length ? tableName + '?' + res : tableName || '';\n  }\n\n  localTimeReplacer(key, convertObj) {\n    for (let prop of !isNullOrUndefined(convertObj) ? Object.keys(convertObj) : []) {\n      if (convertObj[prop] instanceof Date) {\n        convertObj[prop] = DataUtil.dateParse.toLocalTime(convertObj[prop]);\n      }\n    }\n\n    return convertObj;\n  }\n  /**\n   * Prepare and returns request body which is used to insert a new record in the table.\n   * @param  {DataManager} dm\n   * @param  {Object} data\n   * @param  {string} tableName?\n   */\n\n\n  insert(dm, data, tableName) {\n    return {\n      url: (dm.dataSource.insertUrl || dm.dataSource.url).replace(/\\/*$/, tableName ? '/' + tableName : ''),\n      data: JSON.stringify(data, this.options.localTime ? this.localTimeReplacer : null)\n    };\n  }\n  /**\n   * Prepare and return request body which is used to remove record from the table.\n   * @param  {DataManager} dm\n   * @param  {string} keyField\n   * @param  {number} value\n   * @param  {string} tableName?\n   */\n\n\n  remove(dm, keyField, value, tableName) {\n    let url;\n\n    if (typeof value === 'string' && !DataUtil.parse.isGuid(value)) {\n      url = `('${value}')`;\n    } else {\n      url = `(${value})`;\n    }\n\n    return {\n      type: 'DELETE',\n      url: (dm.dataSource.removeUrl || dm.dataSource.url).replace(/\\/*$/, tableName ? '/' + tableName : '') + url\n    };\n  }\n  /**\n   * Updates existing record and saves the changes to the table.\n   * @param  {DataManager} dm\n   * @param  {string} keyField\n   * @param  {Object} value\n   * @param  {string} tableName?\n   * @returns this\n   */\n\n\n  update(dm, keyField, value, tableName, query, original) {\n    if (this.options.updateType === 'PATCH' && !isNullOrUndefined(original)) {\n      value = this.compareAndRemove(value, original, keyField);\n    }\n\n    let url;\n\n    if (typeof value[keyField] === 'string' && !DataUtil.parse.isGuid(value[keyField])) {\n      url = `('${value[keyField]}')`;\n    } else {\n      url = `(${value[keyField]})`;\n    }\n\n    return {\n      type: this.options.updateType,\n      url: (dm.dataSource.updateUrl || dm.dataSource.url).replace(/\\/*$/, tableName ? '/' + tableName : '') + url,\n      data: JSON.stringify(value, this.options.localTime ? this.localTimeReplacer : null),\n      accept: this.options.accept\n    };\n  }\n  /**\n   * Prepare the request body based on the newly added, removed and updated records.\n   * The result is used by the batch request.\n   * @param  {DataManager} dm\n   * @param  {CrudOptions} changes\n   * @param  {RemoteArgs} e\n   * @returns {Object}\n   */\n\n\n  batchRequest(dm, changes, e, query, original) {\n    let initialGuid = e.guid = DataUtil.getGuid(this.options.batchPre);\n    let url = this.rootUrl ? this.rootUrl + '/' + this.options.batch : dm.dataSource.url.replace(/\\/*$/, '/' + this.options.batch);\n    e.url = this.resourceTableName ? this.resourceTableName : e.url;\n    let args = {\n      url: e.url,\n      key: e.key,\n      cid: 1,\n      cSet: DataUtil.getGuid(this.options.changeSet)\n    };\n    let req = '--' + initialGuid + '\\n';\n    req += 'Content-Type: multipart/mixed; boundary=' + args.cSet.replace('--', '') + '\\n';\n    this.pvt.changeSet = 0;\n    req += this.generateInsertRequest(changes.addedRecords, args, dm);\n    req += this.generateUpdateRequest(changes.changedRecords, args, dm, original ? original.changedRecords : []);\n    req += this.generateDeleteRequest(changes.deletedRecords, args, dm);\n    req += args.cSet + '--\\n';\n    req += '--' + initialGuid + '--';\n    return {\n      type: 'POST',\n      url: url,\n      dataType: 'json',\n      contentType: 'multipart/mixed; charset=UTF-8;boundary=' + initialGuid,\n      data: req\n    };\n  }\n  /**\n   * Generate the string content from the removed records.\n   * The result will be send during batch update.\n   * @param  {Object[]} arr\n   * @param  {RemoteArgs} e\n   * @returns this\n   */\n\n\n  generateDeleteRequest(arr, e, dm) {\n    if (!arr) {\n      return '';\n    }\n\n    let req = '';\n    let stat = {\n      'method': 'DELETE ',\n      'url': (data, i, key) => {\n        let url = DataUtil.getObject(key, data[i]);\n\n        if (typeof url === 'number' || DataUtil.parse.isGuid(url)) {\n          return '(' + url + ')';\n        } else if (url instanceof Date) {\n          let dateTime = data[i][key];\n          return '(' + dateTime.toJSON() + ')';\n        } else {\n          return `('${url}')`;\n        }\n      },\n      'data': (data, i) => ''\n    };\n    req = this.generateBodyContent(arr, e, stat, dm);\n    return req + '\\n';\n  }\n  /**\n   * Generate the string content from the inserted records.\n   * The result will be send during batch update.\n   * @param  {Object[]} arr\n   * @param  {RemoteArgs} e\n   */\n\n\n  generateInsertRequest(arr, e, dm) {\n    if (!arr) {\n      return '';\n    }\n\n    let req = '';\n    let stat = {\n      'method': 'POST ',\n      'url': (data, i, key) => '',\n      'data': (data, i) => JSON.stringify(data[i]) + '\\n\\n'\n    };\n    req = this.generateBodyContent(arr, e, stat, dm);\n    return req;\n  }\n  /**\n   * Generate the string content from the updated records.\n   * The result will be send during batch update.\n   * @param  {Object[]} arr\n   * @param  {RemoteArgs} e\n   */\n\n\n  generateUpdateRequest(arr, e, dm, org) {\n    if (!arr) {\n      return '';\n    }\n\n    let req = '';\n    arr.forEach(change => change = this.compareAndRemove(change, org.filter(o => DataUtil.getObject(e.key, o) === DataUtil.getObject(e.key, change))[0], e.key));\n    let stat = {\n      'method': this.options.updateType + ' ',\n      'url': (data, i, key) => {\n        if (typeof data[i][key] === 'number' || DataUtil.parse.isGuid(data[i][key])) {\n          return '(' + data[i][key] + ')';\n        } else if (data[i][key] instanceof Date) {\n          let date = data[i][key];\n          return '(' + date.toJSON() + ')';\n        } else {\n          return `('${data[i][key]}')`;\n        }\n      },\n      'data': (data, i) => JSON.stringify(data[i]) + '\\n\\n'\n    };\n    req = this.generateBodyContent(arr, e, stat, dm);\n    return req;\n  }\n\n  static getField(prop) {\n    return prop.replace(/\\./g, '/');\n  }\n\n  generateBodyContent(arr, e, stat, dm) {\n    let req = '';\n\n    for (let i = 0; i < arr.length; i++) {\n      req += '\\n' + e.cSet + '\\n';\n      req += this.options.changeSetContent + '\\n\\n';\n      req += stat.method;\n\n      if (stat.method === 'POST ') {\n        req += (dm.dataSource.insertUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + ' HTTP/1.1\\n';\n      } else if (stat.method === 'PUT ' || stat.method === 'PATCH ') {\n        req += (dm.dataSource.updateUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + ' HTTP/1.1\\n';\n      } else if (stat.method === 'DELETE ') {\n        req += (dm.dataSource.removeUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + ' HTTP/1.1\\n';\n      }\n\n      req += 'Accept: ' + this.options.accept + '\\n';\n      req += 'Content-Id: ' + this.pvt.changeSet++ + '\\n';\n      req += this.options.batchChangeSetContentType + '\\n';\n\n      if (!isNullOrUndefined(arr[i]['@odata.etag'])) {\n        req += 'If-Match: ' + arr[i]['@odata.etag'] + '\\n\\n';\n        delete arr[i]['@odata.etag'];\n      } else {\n        req += '\\n';\n      }\n\n      req += stat.data(arr, i);\n    }\n\n    return req;\n  }\n\n  processBatchResponse(data, query, xhr, request, changes) {\n    if (xhr && xhr.getResponseHeader('Content-Type') && xhr.getResponseHeader('Content-Type').indexOf('xml') !== -1) {\n      return query.isCountRequired ? {\n        result: [],\n        count: 0\n      } : [];\n    }\n\n    if (request && this.options.batch && DataUtil.endsWith(request.url, this.options.batch) && request.type.toLowerCase() === 'post') {\n      let guid = xhr.getResponseHeader('Content-Type');\n      let cIdx;\n      let jsonObj;\n      let d = data + '';\n      guid = guid.substring(guid.indexOf('=batchresponse') + 1);\n      d = d.split(guid);\n\n      if (d.length < 2) {\n        return {};\n      }\n\n      d = d[1];\n      let exVal = /(?:\\bContent-Type.+boundary=)(changesetresponse.+)/i.exec(d);\n\n      if (exVal) {\n        d.replace(exVal[0], '');\n      }\n\n      let changeGuid = exVal ? exVal[1] : '';\n      d = d.split(changeGuid);\n\n      for (let i = d.length; i > -1; i--) {\n        if (!/\\bContent-ID:/i.test(d[i]) || !/\\bHTTP.+201/.test(d[i])) {\n          continue;\n        }\n\n        cIdx = parseInt(/\\bContent-ID: (\\d+)/i.exec(d[i])[1], 10);\n\n        if (changes.addedRecords[cIdx]) {\n          jsonObj = DataUtil.parse.parseJson(/^\\{.+\\}/m.exec(d[i])[0]);\n          extend({}, changes.addedRecords[cIdx], this.processResponse(jsonObj));\n        }\n      }\n\n      return changes;\n    }\n\n    return null;\n  }\n\n  compareAndRemove(data, original, key) {\n    if (isNullOrUndefined(original)) {\n      return data;\n    }\n\n    Object.keys(data).forEach(prop => {\n      if (prop !== key && prop !== '@odata.etag') {\n        if (DataUtil.isPlainObject(data[prop])) {\n          this.compareAndRemove(data[prop], original[prop]);\n          let final = Object.keys(data[prop]).filter(data => data !== '@odata.etag');\n\n          if (final.length === 0) {\n            delete data[prop];\n          }\n        } else if (data[prop] === original[prop]) {\n          delete data[prop];\n        } else if (data[prop] && original[prop] && data[prop].valueOf() === original[prop].valueOf()) {\n          delete data[prop];\n        }\n      }\n    });\n    return data;\n  }\n\n}\n/**\n * The OData v4 is an improved version of OData protocols.\n * The DataManager uses the ODataV4Adaptor to consume OData v4 services.\n * @hidden\n */\n\n\nclass ODataV4Adaptor extends ODataAdaptor {\n  constructor(props) {\n    super(props); // options replaced the default adaptor options\n\n    this.options = extend({}, this.options, {\n      requestType: 'get',\n      accept: 'application/json, text/javascript, */*; q=0.01',\n      multipartAccept: 'multipart/mixed',\n      sortBy: '$orderby',\n      select: '$select',\n      skip: '$skip',\n      take: '$top',\n      count: '$count',\n      search: '$search',\n      where: '$filter',\n      expand: '$expand',\n      batch: '$batch',\n      changeSet: '--changeset_',\n      batchPre: 'batch_',\n      contentId: 'Content-Id: ',\n      batchContent: 'Content-Type: multipart/mixed; boundary=',\n      changeSetContent: 'Content-Type: application/http\\nContent-Transfer-Encoding: binary ',\n      batchChangeSetContentType: 'Content-Type: application/json; charset=utf-8 ',\n      updateType: 'PATCH',\n      localTime: false,\n      apply: '$apply'\n    });\n    extend(this.options, props || {});\n  }\n  /**\n   * @hidden\n   */\n\n\n  getModuleName() {\n    return 'ODataV4Adaptor';\n  }\n  /**\n   * Returns the query string which requests total count from the data source.\n   * @param  {boolean} e\n   * @returns string\n   */\n\n\n  onCount(e) {\n    return e === true ? 'true' : '';\n  }\n  /**\n   * Generate request string based on the filter criteria from query.\n   * @param  {Predicate} pred\n   * @param  {boolean} requiresCast?\n   */\n\n\n  onPredicate(predicate, query, requiresCast) {\n    let returnValue = '';\n    let val = predicate.value;\n    let isDate = val instanceof Date;\n\n    if (query instanceof Query) {\n      let queries = this.getQueryRequest(query);\n\n      for (let i = 0; i < queries.filters.length; i++) {\n        if (queries.filters[i].e.key === predicate.value) {\n          requiresCast = true;\n        }\n      }\n    }\n\n    returnValue = super.onPredicate.call(this, predicate, query, requiresCast);\n\n    if (isDate) {\n      returnValue = returnValue.replace(/datetime'(.*)'$/, '$1');\n    }\n\n    if (DataUtil.parse.isGuid(val)) {\n      returnValue = returnValue.replace('guid', '').replace(/'/g, '');\n    }\n\n    return returnValue;\n  }\n  /**\n   *  Generate query string based on the multiple search criteria from query.\n   * @param  {{fields:string[]} e\n   * @param  {string} operator\n   * @param  {string} key\n   * @param  {boolean}} ignoreCase\n   */\n\n\n  onEachSearch(e) {\n    let search = this.pvt.searches || [];\n    search.push(e.key);\n    this.pvt.searches = search;\n  }\n  /**\n   *  Generate query string based on the search criteria from query.\n   * @param  {Object} e\n   */\n\n\n  onSearch(e) {\n    return this.pvt.searches.join(' OR ');\n  }\n  /**\n   * Returns the expand query string.\n   * @param  {string} e\n   */\n\n\n  onExpand(e) {\n    let selected = {};\n    let expanded = {};\n    let expands = e.expands.slice();\n    let exArr = [];\n    let selects = e.selects.filter(item => item.indexOf('.') > -1);\n    selects.forEach(select => {\n      let splits = select.split('.');\n\n      if (!(splits[0] in selected)) {\n        selected[splits[0]] = [];\n      }\n\n      selected[splits[0]].push(splits[1]);\n    }); //Auto expand from select query\n\n    Object.keys(selected).forEach(expand => {\n      if (expands.indexOf(expand) === -1) {\n        expands.push(expand);\n      }\n    });\n    expands.forEach(expand => {\n      expanded[expand] = expand in selected ? `${expand}(${this.options.select}=${selected[expand].join(',')})` : expand;\n    });\n    Object.keys(expanded).forEach(ex => exArr.push(expanded[ex]));\n    return exArr.join(',');\n  }\n  /**\n   * Returns the groupby query string.\n   * @param  {string} e\n   */\n\n\n  onDistinct(distinctFields) {\n    let fields = distinctFields.map(field => ODataAdaptor.getField(field)).join(',');\n    return `groupby((${fields}))`;\n  }\n  /**\n   * Returns the select query string.\n   * @param  {string[]} e\n   */\n\n\n  onSelect(e) {\n    return super.onSelect(e.filter(item => item.indexOf('.') === -1));\n  }\n  /**\n   * Method will trigger before send the request to server side.\n   * Used to set the custom header or modify the request options.\n   * @param  {DataManager} dm\n   * @param  {XMLHttpRequest} request\n   * @param  {Ajax} settings\n   * @returns void\n   */\n\n\n  beforeSend(dm, request, settings) {\n    if (settings.type === 'POST' || settings.type === 'PUT' || settings.type === 'PATCH') {\n      request.setRequestHeader('Prefer', 'return=representation');\n    }\n\n    request.setRequestHeader('Accept', this.options.accept);\n  }\n  /**\n   * Returns the data from the query processing.\n   * @param  {DataResult} data\n   * @param  {DataOptions} ds?\n   * @param  {Query} query?\n   * @param  {XMLHttpRequest} xhr?\n   * @param  {Ajax} request?\n   * @param  {CrudOptions} changes?\n   * @returns aggregateResult\n   */\n\n\n  processResponse(data, ds, query, xhr, request, changes) {\n    let metaName = '@odata.context';\n\n    if (request && request.type === 'GET' && !this.rootUrl && data[metaName]) {\n      let dataUrl = data[metaName].split('/$metadata#');\n      this.rootUrl = dataUrl[0];\n      this.resourceTableName = dataUrl[1];\n    }\n\n    let pvtData = 'pvtData';\n    let pvt = request && request[pvtData];\n    let emptyAndBatch = super.processBatchResponse(data, query, xhr, request, changes);\n\n    if (emptyAndBatch) {\n      return emptyAndBatch;\n    }\n\n    let count = null;\n    let dataCount = '@odata.count';\n\n    if (query && query.isCountRequired) {\n      if (dataCount in data) {\n        count = data[dataCount];\n      }\n    }\n\n    data = !isNullOrUndefined(data.value) ? data.value : data;\n    let args = {};\n    args.count = count;\n    args.result = data;\n    this.getAggregateResult(pvt, data, args, null, query);\n    return DataUtil.isNull(count) ? args.result : {\n      result: args.result,\n      count: count,\n      aggregates: args.aggregates\n    };\n  }\n\n}\n/**\n * The Web API is a programmatic interface to define the request and response messages system that is mostly exposed in JSON or XML.\n * The DataManager uses the WebApiAdaptor to consume Web API.\n * Since this adaptor is targeted to interact with Web API created using OData endpoint, it is extended from ODataAdaptor\n * @hidden\n */\n\n\nclass WebApiAdaptor extends ODataAdaptor {\n  getModuleName() {\n    return 'WebApiAdaptor';\n  }\n  /**\n   * Prepare and returns request body which is used to insert a new record in the table.\n   * @param  {DataManager} dm\n   * @param  {Object} data\n   * @param  {string} tableName?\n   */\n\n\n  insert(dm, data, tableName) {\n    return {\n      type: 'POST',\n      url: dm.dataSource.url,\n      data: JSON.stringify(data)\n    };\n  }\n  /**\n   * Prepare and return request body which is used to remove record from the table.\n   * @param  {DataManager} dm\n   * @param  {string} keyField\n   * @param  {number} value\n   * @param  {string} tableName?\n   */\n\n\n  remove(dm, keyField, value, tableName) {\n    return {\n      type: 'DELETE',\n      url: dm.dataSource.url + '/' + value,\n      data: JSON.stringify(value)\n    };\n  }\n  /**\n   * Prepare and return request body which is used to update record.\n   * @param  {DataManager} dm\n   * @param  {string} keyField\n   * @param  {Object} value\n   * @param  {string} tableName?\n   */\n\n\n  update(dm, keyField, value, tableName) {\n    return {\n      type: 'PUT',\n      url: dm.dataSource.url,\n      data: JSON.stringify(value)\n    };\n  }\n\n  batchRequest(dm, changes, e) {\n    let initialGuid = e.guid = DataUtil.getGuid(this.options.batchPre);\n    let url = dm.dataSource.url.replace(/\\/*$/, '/' + this.options.batch);\n    e.url = this.resourceTableName ? this.resourceTableName : e.url;\n    let req = []; //insertion\n\n    for (let i = 0, x = changes.addedRecords.length; i < x; i++) {\n      changes.addedRecords.forEach((j, d) => {\n        let stat = {\n          'method': 'POST ',\n          'url': (data, i, key) => '',\n          'data': (data, i) => JSON.stringify(data[i]) + '\\n\\n'\n        };\n        req.push('--' + initialGuid);\n        req.push('Content-Type: application/http; msgtype=request', '');\n        req.push('POST ' + '/api/' + (dm.dataSource.insertUrl || dm.dataSource.crudUrl || e.url) + stat.url(changes.addedRecords, i, e.key) + ' HTTP/1.1');\n        req.push('Content-Type: ' + 'application/json; charset=utf-8');\n        req.push('Host: ' + location.host);\n        req.push('', j ? JSON.stringify(j) : '');\n      });\n    } //updation \n\n\n    for (let i = 0, x = changes.changedRecords.length; i < x; i++) {\n      changes.changedRecords.forEach((j, d) => {\n        let stat = {\n          'method': this.options.updateType + ' ',\n          'url': (data, i, key) => '',\n          'data': (data, i) => JSON.stringify(data[i]) + '\\n\\n'\n        };\n        req.push('--' + initialGuid);\n        req.push('Content-Type: application/http; msgtype=request', '');\n        req.push('PUT ' + '/api/' + (dm.dataSource.updateUrl || dm.dataSource.crudUrl || e.url) + stat.url(changes.changedRecords, i, e.key) + ' HTTP/1.1');\n        req.push('Content-Type: ' + 'application/json; charset=utf-8');\n        req.push('Host: ' + location.host);\n        req.push('', j ? JSON.stringify(j) : '');\n      });\n    } //deletion\n\n\n    for (let i = 0, x = changes.deletedRecords.length; i < x; i++) {\n      changes.deletedRecords.forEach((j, d) => {\n        let state = {\n          'mtd': 'DELETE ',\n          'url': (data, i, key) => {\n            let url = DataUtil.getObject(key, data[i]);\n\n            if (typeof url === 'number' || DataUtil.parse.isGuid(url)) {\n              return '/' + url;\n            } else if (url instanceof Date) {\n              let datTime = data[i][key];\n              return '/' + datTime.toJSON();\n            } else {\n              return `/'${url}'`;\n            }\n          },\n          'data': (data, i) => ''\n        };\n        req.push('--' + initialGuid);\n        req.push('Content-Type: application/http; msgtype=request', '');\n        req.push('DELETE ' + '/api/' + (dm.dataSource.removeUrl || dm.dataSource.crudUrl || e.url) + state.url(changes.deletedRecords, i, e.key) + ' HTTP/1.1');\n        req.push('Content-Type: ' + 'application/json; charset=utf-8');\n        req.push('Host: ' + location.host);\n        req.push('', j ? JSON.stringify(j) : '');\n      });\n    }\n\n    req.push('--' + initialGuid + '--', '');\n    return {\n      type: 'POST',\n      url: url,\n      contentType: 'multipart/mixed; boundary=' + initialGuid,\n      data: req.join('\\r\\n')\n    };\n  }\n  /**\n   * Method will trigger before send the request to server side.\n   * Used to set the custom header or modify the request options.\n   * @param  {DataManager} dm\n   * @param  {XMLHttpRequest} request\n   * @param  {Ajax} settings\n   * @returns void\n   */\n\n\n  beforeSend(dm, request, settings) {\n    request.setRequestHeader('Accept', 'application/json, text/javascript, */*; q=0.01');\n  }\n  /**\n   * Returns the data from the query processing.\n   * @param  {DataResult} data\n   * @param  {DataOptions} ds?\n   * @param  {Query} query?\n   * @param  {XMLHttpRequest} xhr?\n   * @param  {Ajax} request?\n   * @param  {CrudOptions} changes?\n   * @returns aggregateResult\n   */\n\n\n  processResponse(data, ds, query, xhr, request, changes) {\n    let pvtData = 'pvtData';\n    let pvt = request && request[pvtData];\n    let count = null;\n    let args = {};\n\n    if (request && request.type.toLowerCase() !== 'post') {\n      let versionCheck = xhr && request.getResponseHeader('DataServiceVersion');\n      let version = versionCheck && parseInt(versionCheck, 10) || 2;\n\n      if (query && query.isCountRequired) {\n        if (!DataUtil.isNull(data.Count)) {\n          count = data.Count;\n        }\n      }\n\n      if (version < 3 && data.Items) {\n        data = data.Items;\n      }\n\n      args.count = count;\n      args.result = data;\n      this.getAggregateResult(pvt, data, args, null, query);\n    }\n\n    args.result = args.result || data;\n    return DataUtil.isNull(count) ? args.result : {\n      result: args.result,\n      count: args.count,\n      aggregates: args.aggregates\n    };\n  }\n\n}\n/**\n * WebMethodAdaptor can be used by DataManager to interact with web method.\n * @hidden\n */\n\n\nclass WebMethodAdaptor extends UrlAdaptor {\n  /**\n   * Prepare the request body based on the query.\n   * The query information can be accessed at the WebMethod using variable named `value`.\n   * @param  {DataManager} dm\n   * @param  {Query} query\n   * @param  {Object[]} hierarchyFilters?\n   * @returns application\n   */\n  processQuery(dm, query, hierarchyFilters) {\n    let obj = new UrlAdaptor().processQuery(dm, query, hierarchyFilters);\n    let getData = 'data';\n    let data = DataUtil.parse.parseJson(obj[getData]);\n    let result = {};\n    let value = 'value';\n\n    if (data.param) {\n      for (let i = 0; i < data.param.length; i++) {\n        let param = data.param[i];\n        let key = Object.keys(param)[0];\n        result[key] = param[key];\n      }\n    }\n\n    result[value] = data;\n    let pvtData = 'pvtData';\n    let url = 'url';\n    return {\n      data: JSON.stringify(result),\n      url: obj[url],\n      pvtData: obj[pvtData],\n      type: 'POST',\n      contentType: 'application/json; charset=utf-8'\n    };\n  }\n\n}\n/**\n * RemoteSaveAdaptor, extended from JsonAdaptor and it is used for binding local data and performs all DataManager queries in client-side.\n * It interacts with server-side only for CRUD operations.\n * @hidden\n */\n\n\nclass RemoteSaveAdaptor extends JsonAdaptor {\n  /**\n   * @hidden\n   */\n  constructor() {\n    super();\n    setValue('beforeSend', UrlAdaptor.prototype.beforeSend, this);\n  }\n\n  insert(dm, data, tableName, query, position) {\n    this.pvt.position = position;\n    this.updateType = 'add';\n    return {\n      url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,\n      data: JSON.stringify(extend({}, {\n        value: data,\n        table: tableName,\n        action: 'insert'\n      }, DataUtil.getAddParams(this, dm, query)))\n    };\n  }\n\n  remove(dm, keyField, val, tableName, query) {\n    super.remove(dm, keyField, val);\n    return {\n      type: 'POST',\n      url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,\n      data: JSON.stringify(extend({}, {\n        key: val,\n        keyColumn: keyField,\n        table: tableName,\n        action: 'remove'\n      }, DataUtil.getAddParams(this, dm, query)))\n    };\n  }\n\n  update(dm, keyField, val, tableName, query) {\n    this.updateType = 'update';\n    this.updateKey = keyField;\n    return {\n      type: 'POST',\n      url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,\n      data: JSON.stringify(extend({}, {\n        value: val,\n        action: 'update',\n        keyColumn: keyField,\n        key: val[keyField],\n        table: tableName\n      }, DataUtil.getAddParams(this, dm, query)))\n    };\n  }\n\n  processResponse(data, ds, query, xhr, request, changes, e) {\n    let i;\n    let newData = request ? JSON.parse(request.data) : data;\n    data = newData.action === 'batch' ? DataUtil.parse.parseJson(data) : data;\n\n    if (this.updateType === 'add') {\n      super.insert(ds, data, null, null, this.pvt.position);\n    }\n\n    if (this.updateType === 'update') {\n      super.update(ds, this.updateKey, data);\n    }\n\n    this.updateType = undefined;\n\n    if (data.added) {\n      for (i = 0; i < data.added.length; i++) {\n        super.insert(ds, data.added[i]);\n      }\n    }\n\n    if (data.changed) {\n      for (i = 0; i < data.changed.length; i++) {\n        super.update(ds, e.key, data.changed[i]);\n      }\n    }\n\n    if (data.deleted) {\n      for (i = 0; i < data.deleted.length; i++) {\n        super.remove(ds, e.key, data.deleted[i]);\n      }\n    }\n\n    return data;\n  }\n  /**\n   * Prepare the request body based on the newly added, removed and updated records.\n   * Also perform the changes in the locally cached data to sync with the remote data.\n   * The result is used by the batch request.\n   * @param  {DataManager} dm\n   * @param  {CrudOptions} changes\n   * @param  {RemoteArgs} e\n   */\n\n\n  batchRequest(dm, changes, e, query, original) {\n    return {\n      type: 'POST',\n      url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.url,\n      contentType: 'application/json; charset=utf-8',\n      dataType: 'json',\n      data: JSON.stringify(extend({}, {\n        changed: changes.changedRecords,\n        added: changes.addedRecords,\n        deleted: changes.deletedRecords,\n        action: 'batch',\n        table: e.url,\n        key: e.key\n      }, DataUtil.getAddParams(this, dm, query)))\n    };\n  }\n\n  addParams(options) {\n    let urlParams = new UrlAdaptor();\n    urlParams.addParams(options);\n  }\n\n}\n/**\n * Ajax Adaptor that is extended from URL Adaptor, is used for handle data operations with user defined functions.\n * @hidden\n */\n\n\nclass CustomDataAdaptor extends UrlAdaptor {\n  constructor(props) {\n    super(); // options replaced the default adaptor options\n\n    this.options = extend({}, this.options, {\n      getData: new Function(),\n      addRecord: new Function(),\n      updateRecord: new Function(),\n      deleteRecord: new Function(),\n      batchUpdate: new Function()\n    });\n    extend(this.options, props || {});\n  }\n\n  getModuleName() {\n    return 'CustomDataAdaptor';\n  }\n\n}\n/**\n * The GraphqlAdaptor that is extended from URL Adaptor, is used for retrieving data from the Graphql server.\n * It interacts with the Graphql server with all the DataManager Queries and performs CRUD operations.\n * @hidden\n */\n\n\nclass GraphQLAdaptor extends UrlAdaptor {\n  getModuleName() {\n    return 'GraphQLAdaptor';\n  }\n\n  constructor(options) {\n    super();\n    this.opt = options;\n    this.schema = this.opt.response;\n    this.query = this.opt.query;\n    this.getVariables = this.opt.getVariables ? this.opt.getVariables : () => {};\n\n    this.getQuery = () => this.query;\n  }\n  /**\n   * Process the JSON data based on the provided queries.\n   * @param  {DataManager} dm\n   * @param  {Query} query?\n   */\n\n\n  processQuery(datamanager, query) {\n    let urlQuery = super.processQuery.apply(this, arguments);\n    let dm = JSON.parse(urlQuery.data); // constructing GraphQL parameters\n\n    let keys = ['skip', 'take', 'sorted', 'table', 'select', 'where', 'search', 'requiresCounts', 'aggregates', 'params'];\n    let temp = {};\n    let str = 'searchwhereparams';\n    keys.filter(e => {\n      temp[e] = str.indexOf(e) > -1 ? JSON.stringify(dm[e]) : dm[e];\n    });\n    let vars = this.getVariables() || {};\n    vars['datamanager'] = temp;\n    let data = JSON.stringify({\n      query: this.getQuery(),\n      variables: vars\n    });\n    urlQuery.data = data;\n    return urlQuery;\n  }\n  /**\n   * Returns the data from the query processing.\n   * It will also cache the data for later usage.\n   * @param  {DataResult} data\n   * @param  {DataManager} ds?\n   * @param  {Query} query?\n   * @param  {XMLHttpRequest} xhr?\n   * @param  {Object} request?\n   * @returns DataResult\n   */\n\n\n  processResponse(resData, ds, query, xhr, request) {\n    const res = resData;\n    let count;\n    let aggregates;\n    let result = getValue(this.schema.result, res.data);\n\n    if (this.schema.count) {\n      count = getValue(this.schema.count, res.data);\n    }\n\n    if (this.schema.aggregates) {\n      aggregates = getValue(this.schema.aggregates, res.data);\n      aggregates = !isNullOrUndefined(aggregates) ? DataUtil.parse.parseJson(aggregates) : aggregates;\n    }\n\n    let pvt = request.pvtData || {};\n    let args = {\n      result: result,\n      aggregates: aggregates\n    };\n    let data = args;\n\n    if (pvt && pvt.groups && pvt.groups.length) {\n      this.getAggregateResult(pvt, data, args, null, query);\n    }\n\n    return !isNullOrUndefined(count) ? {\n      result: args.result,\n      count: count,\n      aggregates: aggregates\n    } : args.result;\n  }\n  /**\n   * Prepare and returns request body which is used to insert a new record in the table.\n   */\n\n\n  insert() {\n    let inserted = super.insert.apply(this, arguments);\n    return this.generateCrudData(inserted, 'insert');\n  }\n  /**\n   * Prepare and returns request body which is used to update a new record in the table.\n   */\n\n\n  update() {\n    let inserted = super.update.apply(this, arguments);\n    return this.generateCrudData(inserted, 'update');\n  }\n  /**\n   * Prepare and returns request body which is used to remove a new record in the table.\n   */\n\n\n  remove() {\n    let inserted = super.remove.apply(this, arguments);\n    return this.generateCrudData(inserted, 'remove');\n  }\n  /**\n   * Prepare the request body based on the newly added, removed and updated records.\n   * The result is used by the batch request.\n   * @param  {DataManager} dm\n   * @param  {CrudOptions} changes\n   * @param  {Object} e\n   * @param  {Query} query\n   * @param  {Object} original\n   */\n\n\n  batchRequest(dm, changes, e, query, original) {\n    let batch = super.batchRequest.apply(this, arguments);\n    let bData = JSON.parse(batch.data);\n    bData.key = e.key;\n    batch.data = JSON.stringify(bData);\n    return this.generateCrudData(batch, 'batch');\n  }\n\n  generateCrudData(crudData, action) {\n    let parsed = JSON.parse(crudData.data);\n    crudData.data = JSON.stringify({\n      query: this.opt.getMutation(action),\n      variables: parsed\n    });\n    return crudData;\n  }\n\n}\n/**\n * Cache Adaptor is used to cache the data of the visited pages. It prevents new requests for the previously visited pages.\n * You can configure cache page size and duration of caching by using cachingPageSize and timeTillExpiration properties of the DataManager\n * @hidden\n */\n\n\nclass CacheAdaptor extends UrlAdaptor {\n  /**\n   * Constructor for CacheAdaptor class.\n   * @param  {CacheAdaptor} adaptor?\n   * @param  {number} timeStamp?\n   * @param  {number} pageSize?\n   * @hidden\n   */\n  constructor(adaptor, timeStamp, pageSize) {\n    super();\n    this.isCrudAction = false;\n    this.isInsertAction = false;\n\n    if (!isNullOrUndefined(adaptor)) {\n      this.cacheAdaptor = adaptor;\n    }\n\n    this.pageSize = pageSize;\n    this.guidId = DataUtil.getGuid('cacheAdaptor');\n    let obj = {\n      keys: [],\n      results: []\n    };\n    window.localStorage.setItem(this.guidId, JSON.stringify(obj));\n    let guid = this.guidId;\n\n    if (!isNullOrUndefined(timeStamp)) {\n      setInterval(() => {\n        let data;\n        data = DataUtil.parse.parseJson(window.localStorage.getItem(guid));\n        let forDel = [];\n\n        for (let i = 0; i < data.results.length; i++) {\n          let currentTime = +new Date();\n          let requestTime = +new Date(data.results[i].timeStamp);\n          data.results[i].timeStamp = currentTime - requestTime;\n\n          if (currentTime - requestTime > timeStamp) {\n            forDel.push(i);\n          }\n        }\n\n        for (let i = 0; i < forDel.length; i++) {\n          data.results.splice(forDel[i], 1);\n          data.keys.splice(forDel[i], 1);\n        }\n\n        window.localStorage.removeItem(guid);\n        window.localStorage.setItem(guid, JSON.stringify(data));\n      }, timeStamp);\n    }\n  }\n  /**\n   * It will generate the key based on the URL when we send a request to server.\n   * @param  {string} url\n   * @param  {Query} query?\n   * @hidden\n   */\n\n\n  generateKey(url, query) {\n    let queries = this.getQueryRequest(query);\n    let singles = Query.filterQueryLists(query.queries, ['onSelect', 'onPage', 'onSkip', 'onTake', 'onRange']);\n    let key = url;\n    let page = 'onPage';\n\n    if (page in singles) {\n      key += singles[page].pageIndex;\n    }\n\n    queries.sorts.forEach(obj => {\n      key += obj.e.direction + obj.e.fieldName;\n    });\n    queries.groups.forEach(obj => {\n      key += obj.e.fieldName;\n    });\n    queries.searches.forEach(obj => {\n      key += obj.e.searchKey;\n    });\n\n    for (let filter = 0; filter < queries.filters.length; filter++) {\n      let currentFilter = queries.filters[filter];\n\n      if (currentFilter.e.isComplex) {\n        let newQuery = query.clone();\n        newQuery.queries = [];\n\n        for (let i = 0; i < currentFilter.e.predicates.length; i++) {\n          newQuery.queries.push({\n            fn: 'onWhere',\n            e: currentFilter.e.predicates[i],\n            filter: query.queries.filter\n          });\n        }\n\n        key += currentFilter.e.condition + this.generateKey(url, newQuery);\n      } else {\n        key += currentFilter.e.field + currentFilter.e.operator + currentFilter.e.value;\n      }\n    }\n\n    return key;\n  }\n  /**\n   * Process the query to generate request body.\n   * If the data is already cached, it will return the cached data.\n   * @param  {DataManager} dm\n   * @param  {Query} query?\n   * @param  {Object[]} hierarchyFilters?\n   */\n\n\n  processQuery(dm, query, hierarchyFilters) {\n    let key = this.generateKey(dm.dataSource.url, query);\n    let cachedItems;\n    cachedItems = DataUtil.parse.parseJson(window.localStorage.getItem(this.guidId));\n    let data = cachedItems ? cachedItems.results[cachedItems.keys.indexOf(key)] : null;\n\n    if (data != null && !this.isCrudAction && !this.isInsertAction) {\n      return data;\n    }\n\n    this.isCrudAction = null;\n    this.isInsertAction = null;\n    return this.cacheAdaptor.processQuery.apply(this.cacheAdaptor, [].slice.call(arguments, 0));\n  }\n  /**\n   * Returns the data from the query processing.\n   * It will also cache the data for later usage.\n   * @param  {DataResult} data\n   * @param  {DataManager} ds?\n   * @param  {Query} query?\n   * @param  {XMLHttpRequest} xhr?\n   * @param  {Ajax} request?\n   * @param  {CrudOptions} changes?\n   */\n\n\n  processResponse(data, ds, query, xhr, request, changes) {\n    if (this.isInsertAction || request && this.cacheAdaptor.options.batch && DataUtil.endsWith(request.url, this.cacheAdaptor.options.batch) && request.type.toLowerCase() === 'post') {\n      return this.cacheAdaptor.processResponse(data, ds, query, xhr, request, changes);\n    }\n\n    data = this.cacheAdaptor.processResponse.apply(this.cacheAdaptor, [].slice.call(arguments, 0));\n    let key = query ? this.generateKey(ds.dataSource.url, query) : ds.dataSource.url;\n    let obj = {};\n    obj = DataUtil.parse.parseJson(window.localStorage.getItem(this.guidId));\n    let index = obj.keys.indexOf(key);\n\n    if (index !== -1) {\n      obj.results.splice(index, 1);\n      obj.keys.splice(index, 1);\n    }\n\n    obj.results[obj.keys.push(key) - 1] = {\n      keys: key,\n      result: data.result,\n      timeStamp: new Date(),\n      count: data.count\n    };\n\n    while (obj.results.length > this.pageSize) {\n      obj.results.splice(0, 1);\n      obj.keys.splice(0, 1);\n    }\n\n    window.localStorage.setItem(this.guidId, JSON.stringify(obj));\n    return data;\n  }\n  /**\n   * Method will trigger before send the request to server side. Used to set the custom header or modify the request options.\n   * @param  {DataManager} dm\n   * @param  {XMLHttpRequest} request\n   * @param  {Ajax} settings?\n   */\n\n\n  beforeSend(dm, request, settings) {\n    if (!isNullOrUndefined(this.cacheAdaptor.options.batch) && DataUtil.endsWith(settings.url, this.cacheAdaptor.options.batch) && settings.type.toLowerCase() === 'post') {\n      request.setRequestHeader('Accept', this.cacheAdaptor.options.multipartAccept);\n    }\n\n    if (!dm.dataSource.crossDomain) {\n      request.setRequestHeader('Accept', this.cacheAdaptor.options.accept);\n    }\n  }\n  /**\n   * Updates existing record and saves the changes to the table.\n   * @param  {DataManager} dm\n   * @param  {string} keyField\n   * @param  {Object} value\n   * @param  {string} tableName\n   */\n\n\n  update(dm, keyField, value, tableName) {\n    this.isCrudAction = true;\n    return this.cacheAdaptor.update(dm, keyField, value, tableName);\n  }\n  /**\n   * Prepare and returns request body which is used to insert a new record in the table.\n   * @param  {DataManager} dm\n   * @param  {Object} data\n   * @param  {string} tableName?\n   */\n\n\n  insert(dm, data, tableName) {\n    this.isInsertAction = true;\n    return this.cacheAdaptor.insert(dm, data, tableName);\n  }\n  /**\n   * Prepare and return request body which is used to remove record from the table.\n   * @param  {DataManager} dm\n   * @param  {string} keyField\n   * @param  {Object} value\n   * @param  {string} tableName?\n   */\n\n\n  remove(dm, keyField, value, tableName) {\n    this.isCrudAction = true;\n    return this.cacheAdaptor.remove(dm, keyField, value, tableName);\n  }\n  /**\n   * Prepare the request body based on the newly added, removed and updated records.\n   * The result is used by the batch request.\n   * @param  {DataManager} dm\n   * @param  {CrudOptions} changes\n   * @param  {RemoteArgs} e\n   */\n\n\n  batchRequest(dm, changes, e) {\n    return this.cacheAdaptor.batchRequest(dm, changes, e);\n  }\n\n}\n/**\n * DataManager is used to manage and manipulate relational data.\n */\n\n\nclass DataManager {\n  /**\n   * Constructor for DataManager class\n   * @param  {DataOptions|JSON[]} dataSource?\n   * @param  {Query} query?\n   * @param  {AdaptorOptions|string} adaptor?\n   * @hidden\n   */\n  constructor(dataSource, query, adaptor) {\n    /** @hidden */\n    this.dateParse = true;\n    /** @hidden */\n\n    this.timeZoneHandling = true;\n    this.requests = [];\n\n    if (!dataSource && !this.dataSource) {\n      dataSource = [];\n    }\n\n    adaptor = adaptor || dataSource.adaptor;\n\n    if (dataSource && dataSource.timeZoneHandling === false) {\n      this.timeZoneHandling = dataSource.timeZoneHandling;\n    }\n\n    let data;\n\n    if (dataSource instanceof Array) {\n      data = {\n        json: dataSource,\n        offline: true\n      };\n    } else if (typeof dataSource === 'object') {\n      if (!dataSource.json) {\n        dataSource.json = [];\n      }\n\n      data = {\n        url: dataSource.url,\n        insertUrl: dataSource.insertUrl,\n        removeUrl: dataSource.removeUrl,\n        updateUrl: dataSource.updateUrl,\n        crudUrl: dataSource.crudUrl,\n        batchUrl: dataSource.batchUrl,\n        json: dataSource.json,\n        headers: dataSource.headers,\n        accept: dataSource.accept,\n        data: dataSource.data,\n        timeTillExpiration: dataSource.timeTillExpiration,\n        cachingPageSize: dataSource.cachingPageSize,\n        enableCaching: dataSource.enableCaching,\n        requestType: dataSource.requestType,\n        key: dataSource.key,\n        crossDomain: dataSource.crossDomain,\n        jsonp: dataSource.jsonp,\n        dataType: dataSource.dataType,\n        offline: dataSource.offline !== undefined ? dataSource.offline : dataSource.adaptor instanceof RemoteSaveAdaptor || dataSource.adaptor instanceof CustomDataAdaptor ? false : dataSource.url ? false : true,\n        requiresFormat: dataSource.requiresFormat\n      };\n    } else {\n      DataUtil.throwError('DataManager: Invalid arguments');\n    }\n\n    if (data.requiresFormat === undefined && !DataUtil.isCors()) {\n      data.requiresFormat = isNullOrUndefined(data.crossDomain) ? true : data.crossDomain;\n    }\n\n    if (data.dataType === undefined) {\n      data.dataType = 'json';\n    }\n\n    this.dataSource = data;\n    this.defaultQuery = query;\n\n    if (data.url && data.offline && !data.json.length) {\n      this.isDataAvailable = false;\n      this.adaptor = adaptor || new ODataAdaptor();\n      this.dataSource.offline = false;\n      this.ready = this.executeQuery(query || new Query());\n      this.ready.then(e => {\n        this.dataSource.offline = true;\n        this.isDataAvailable = true;\n        data.json = e.result;\n        this.adaptor = new JsonAdaptor();\n      });\n    } else {\n      this.adaptor = data.offline ? new JsonAdaptor() : new ODataAdaptor();\n    }\n\n    if (!data.jsonp && this.adaptor instanceof ODataAdaptor) {\n      data.jsonp = 'callback';\n    }\n\n    this.adaptor = adaptor || this.adaptor;\n\n    if (data.enableCaching) {\n      this.adaptor = new CacheAdaptor(this.adaptor, data.timeTillExpiration, data.cachingPageSize);\n    }\n\n    return this;\n  }\n  /**\n   * Overrides DataManager's default query with given query.\n   * @param  {Query} query - Defines the new default query.\n   */\n\n\n  setDefaultQuery(query) {\n    this.defaultQuery = query;\n    return this;\n  }\n  /**\n   * Executes the given query with local data source.\n   * @param  {Query} query - Defines the query to retrieve data.\n   */\n\n\n  executeLocal(query) {\n    if (!this.defaultQuery && !(query instanceof Query)) {\n      DataUtil.throwError('DataManager - executeLocal() : A query is required to execute');\n    }\n\n    if (!this.dataSource.json) {\n      DataUtil.throwError('DataManager - executeLocal() : Json data is required to execute');\n    }\n\n    query = query || this.defaultQuery;\n    let result = this.adaptor.processQuery(this, query);\n\n    if (query.subQuery) {\n      let from = query.subQuery.fromTable;\n      let lookup = query.subQuery.lookups;\n      let res = query.isCountRequired ? result.result : result;\n\n      if (lookup && lookup instanceof Array) {\n        DataUtil.buildHierarchy(query.subQuery.fKey, from, res, lookup, query.subQuery.key);\n      }\n\n      for (let j = 0; j < res.length; j++) {\n        if (res[j][from] instanceof Array) {\n          res[j] = extend({}, {}, res[j]);\n          res[j][from] = this.adaptor.processResponse(query.subQuery.using(new DataManager(res[j][from].slice(0))).executeLocal(), this, query);\n        }\n      }\n    }\n\n    return this.adaptor.processResponse(result, this, query);\n  }\n  /**\n   * Executes the given query with either local or remote data source.\n   * It will be executed as asynchronously and returns Promise object which will be resolved or rejected after action completed.\n   * @param  {Query|Function} query - Defines the query to retrieve data.\n   * @param  {Function} done - Defines the callback function and triggers when the Promise is resolved.\n   * @param  {Function} fail - Defines the callback function and triggers when the Promise is rejected.\n   * @param  {Function} always - Defines the callback function and triggers when the Promise is resolved or rejected.\n   */\n\n\n  executeQuery(query, done, fail, always) {\n    let makeRequest = 'makeRequest';\n\n    if (typeof query === 'function') {\n      always = fail;\n      fail = done;\n      done = query;\n      query = null;\n    }\n\n    if (!query) {\n      query = this.defaultQuery;\n    }\n\n    if (!(query instanceof Query)) {\n      DataUtil.throwError('DataManager - executeQuery() : A query is required to execute');\n    }\n\n    let deffered = new Deferred();\n    let args = {\n      query: query\n    };\n\n    if (!this.dataSource.offline && this.dataSource.url !== undefined && this.dataSource.url !== '' || !isNullOrUndefined(this.adaptor[makeRequest]) || this.isCustomDataAdaptor(this.adaptor)) {\n      let result = this.adaptor.processQuery(this, query);\n\n      if (!isNullOrUndefined(this.adaptor[makeRequest])) {\n        this.adaptor[makeRequest](result, deffered, args, query);\n      } else if (!isNullOrUndefined(result.url) || this.isCustomDataAdaptor(this.adaptor)) {\n        this.makeRequest(result, deffered, args, query);\n      } else {\n        args = DataManager.getDeferedArgs(query, result, args);\n        deffered.resolve(args);\n      }\n    } else {\n      DataManager.nextTick(() => {\n        let res = this.executeLocal(query);\n        args = DataManager.getDeferedArgs(query, res, args);\n        deffered.resolve(args);\n      });\n    }\n\n    if (done || fail) {\n      deffered.promise.then(done, fail);\n    }\n\n    if (always) {\n      deffered.promise.then(always, always);\n    }\n\n    return deffered.promise;\n  }\n\n  static getDeferedArgs(query, result, args) {\n    if (query.isCountRequired) {\n      args.result = result.result;\n      args.count = result.count;\n      args.aggregates = result.aggregates;\n    } else {\n      args.result = result;\n    }\n\n    return args;\n  }\n\n  static nextTick(fn) {\n    (window.setImmediate || window.setTimeout)(fn, 0);\n  }\n\n  extendRequest(url, fnSuccess, fnFail) {\n    return extend({}, {\n      type: 'GET',\n      dataType: this.dataSource.dataType,\n      crossDomain: this.dataSource.crossDomain,\n      jsonp: this.dataSource.jsonp,\n      cache: true,\n      processData: false,\n      onSuccess: fnSuccess,\n      onFailure: fnFail\n    }, url);\n  } // tslint:disable-next-line:max-func-body-length\n\n\n  makeRequest(url, deffered, args, query) {\n    let isSelector = !!query.subQuerySelector;\n\n    let fnFail = e => {\n      args.error = e;\n      deffered.reject(args);\n    };\n\n    let process = (data, count, xhr, request, actual, aggregates, virtualSelectRecords) => {\n      args.xhr = xhr;\n      args.count = count ? parseInt(count.toString(), 10) : 0;\n      args.result = data;\n      args.request = request;\n      args.aggregates = aggregates;\n      args.actual = actual;\n      args.virtualSelectRecords = virtualSelectRecords;\n      deffered.resolve(args);\n    };\n\n    let fnQueryChild = (data, selector) => {\n      let subDeffer = new Deferred();\n      let childArgs = {\n        parent: args\n      };\n      query.subQuery.isChild = true;\n      let subUrl = this.adaptor.processQuery(this, query.subQuery, data ? this.adaptor.processResponse(data) : selector);\n      let childReq = this.makeRequest(subUrl, subDeffer, childArgs, query.subQuery);\n\n      if (!isSelector) {\n        subDeffer.then(subData => {\n          if (data) {\n            DataUtil.buildHierarchy(query.subQuery.fKey, query.subQuery.fromTable, data, subData, query.subQuery.key);\n            process(data, subData.count, subData.xhr);\n          }\n        }, fnFail);\n      }\n\n      return childReq;\n    };\n\n    let fnSuccess = (data, request) => {\n      if (this.isGraphQLAdaptor(this.adaptor)) {\n        if (!isNullOrUndefined(data['errors'])) {\n          return fnFail(data['errors'], request);\n        }\n      }\n\n      if (this.isCustomDataAdaptor(this.adaptor)) {\n        request = extend({}, this.ajaxReqOption, request);\n      }\n\n      if (request.httpRequest.getResponseHeader('Content-Type').indexOf('xml') === -1 && this.dateParse) {\n        data = DataUtil.parse.parseJson(data);\n      }\n\n      let result = this.adaptor.processResponse(data, this, query, request.httpRequest, request);\n      let count = 0;\n      let aggregates = null;\n      let virtualSelectRecords = 'virtualSelectRecords';\n      let virtualRecords = data[virtualSelectRecords];\n\n      if (query.isCountRequired) {\n        count = result.count;\n        aggregates = result.aggregates;\n        result = result.result;\n      }\n\n      if (!query.subQuery) {\n        process(result, count, request.httpRequest, request.type, data, aggregates, virtualRecords);\n        return;\n      }\n\n      if (!isSelector) {\n        fnQueryChild(result, request);\n      }\n    };\n\n    let req = this.extendRequest(url, fnSuccess, fnFail);\n\n    if (!this.isCustomDataAdaptor(this.adaptor)) {\n      let ajax = new Ajax(req);\n\n      ajax.beforeSend = () => {\n        this.beforeSend(ajax.httpRequest, ajax);\n      };\n\n      req = ajax.send();\n      req.catch(e => true); // to handle failure remote requests.        \n\n      this.requests.push(ajax);\n    } else {\n      this.ajaxReqOption = req;\n      let request = req;\n      this.adaptor.options.getData({\n        data: request.data,\n        onSuccess: request.onSuccess,\n        onFailure: request.onFailure\n      });\n    }\n\n    if (isSelector) {\n      let promise;\n      let res = query.subQuerySelector.call(this, {\n        query: query.subQuery,\n        parent: query\n      });\n\n      if (res && res.length) {\n        promise = Promise.all([req, fnQueryChild(null, res)]);\n        promise.then((...args) => {\n          let result = args[0];\n          let pResult = this.adaptor.processResponse(result[0], this, query, this.requests[0].httpRequest, this.requests[0]);\n          let count = 0;\n\n          if (query.isCountRequired) {\n            count = pResult.count;\n            pResult = pResult.result;\n          }\n\n          let cResult = this.adaptor.processResponse(result[1], this, query.subQuery, this.requests[1].httpRequest, this.requests[1]);\n          count = 0;\n\n          if (query.subQuery.isCountRequired) {\n            count = cResult.count;\n            cResult = cResult.result;\n          }\n\n          DataUtil.buildHierarchy(query.subQuery.fKey, query.subQuery.fromTable, pResult, cResult, query.subQuery.key);\n          isSelector = false;\n          process(pResult, count, this.requests[0].httpRequest);\n        });\n      } else {\n        isSelector = false;\n      }\n    }\n\n    return req;\n  }\n\n  beforeSend(request, settings) {\n    this.adaptor.beforeSend(this, request, settings);\n    let headers = this.dataSource.headers;\n    let props;\n\n    for (let i = 0; headers && i < headers.length; i++) {\n      props = [];\n      let keys = Object.keys(headers[i]);\n\n      for (let prop of keys) {\n        props.push(prop);\n        request.setRequestHeader(prop, headers[i][prop]);\n      }\n    }\n  }\n  /**\n   * Save bulk changes to the given table name.\n   * User can add a new record, edit an existing record, and delete a record at the same time.\n   * If the datasource from remote, then updated in a single post.\n   * @param  {Object} changes - Defines the CrudOptions.\n   * @param  {string} key - Defines the column field.\n   * @param  {string|Query} tableName - Defines the table name.\n   * @param  {Query} query - Sets default query for the DataManager.\n   */\n\n\n  saveChanges(changes, key, tableName, query, original) {\n    if (tableName instanceof Query) {\n      query = tableName;\n      tableName = null;\n    }\n\n    let args = {\n      url: tableName,\n      key: key || this.dataSource.key\n    };\n    let req = this.adaptor.batchRequest(this, changes, args, query || new Query(), original);\n    let doAjaxRequest = 'doAjaxRequest';\n\n    if (this.dataSource.offline) {\n      return req;\n    }\n\n    if (!isNullOrUndefined(this.adaptor[doAjaxRequest])) {\n      return this.adaptor[doAjaxRequest](req);\n    } else if (!this.isCustomDataAdaptor(this.adaptor)) {\n      let deff = new Deferred();\n      let ajax = new Ajax(req);\n\n      ajax.beforeSend = () => {\n        this.beforeSend(ajax.httpRequest, ajax);\n      };\n\n      ajax.onSuccess = (data, request) => {\n        if (this.isGraphQLAdaptor(this.adaptor)) {\n          if (!isNullOrUndefined(data['errors'])) {\n            ajax.onFailure(JSON.stringify(data['errors']));\n          }\n        }\n\n        deff.resolve(this.adaptor.processResponse(data, this, null, request.httpRequest, request, changes, args));\n      };\n\n      ajax.onFailure = e => {\n        deff.reject([{\n          error: e\n        }]);\n      };\n\n      ajax.send().catch(e => true); // to handle the failure requests.        \n\n      return deff.promise;\n    } else {\n      return this.doAjaxRequest(req, this.adaptor.options.batchUpdate);\n    }\n  }\n  /**\n   * Inserts new record in the given table.\n   * @param  {Object} data - Defines the data to insert.\n   * @param  {string|Query} tableName - Defines the table name.\n   * @param  {Query} query - Sets default query for the DataManager.\n   */\n\n\n  insert(data, tableName, query, position) {\n    if (tableName instanceof Query) {\n      query = tableName;\n      tableName = null;\n    }\n\n    let req = this.adaptor.insert(this, data, tableName, query, position);\n    let doAjaxRequest = 'doAjaxRequest';\n\n    if (this.dataSource.offline) {\n      return req;\n    }\n\n    if (!isNullOrUndefined(this.adaptor[doAjaxRequest])) {\n      return this.adaptor[doAjaxRequest](req);\n    } else {\n      return this.doAjaxRequest(req, this.adaptor.options.addRecord);\n    }\n  }\n  /**\n   * Removes data from the table with the given key.\n   * @param  {string} keyField - Defines the column field.\n   * @param  {Object} value - Defines the value to find the data in the specified column.\n   * @param  {string|Query} tableName - Defines the table name\n   * @param  {Query} query - Sets default query for the DataManager.\n   */\n\n\n  remove(keyField, value, tableName, query) {\n    if (typeof value === 'object') {\n      value = DataUtil.getObject(keyField, value);\n    }\n\n    if (tableName instanceof Query) {\n      query = tableName;\n      tableName = null;\n    }\n\n    let res = this.adaptor.remove(this, keyField, value, tableName, query);\n    let doAjaxRequest = 'doAjaxRequest';\n\n    if (this.dataSource.offline) {\n      return res;\n    }\n\n    if (!isNullOrUndefined(this.adaptor[doAjaxRequest])) {\n      return this.adaptor[doAjaxRequest](res);\n    } else {\n      let remove = this.adaptor.options.deleteRecord;\n      return this.doAjaxRequest(res, remove);\n    }\n  }\n  /**\n   * Updates existing record in the given table.\n   * @param  {string} keyField - Defines the column field.\n   * @param  {Object} value - Defines the value to find the data in the specified column.\n   * @param  {string|Query} tableName - Defines the table name\n   * @param  {Query} query - Sets default query for the DataManager.\n   */\n\n\n  update(keyField, value, tableName, query, original) {\n    if (tableName instanceof Query) {\n      query = tableName;\n      tableName = null;\n    }\n\n    let res = this.adaptor.update(this, keyField, value, tableName, query, original);\n    let doAjaxRequest = 'doAjaxRequest';\n\n    if (this.dataSource.offline) {\n      return res;\n    }\n\n    if (!isNullOrUndefined(this.adaptor[doAjaxRequest])) {\n      return this.adaptor[doAjaxRequest](res);\n    } else {\n      let update = this.adaptor.options.updateRecord;\n      return this.doAjaxRequest(res, update);\n    }\n  }\n\n  isCustomDataAdaptor(dataSource) {\n    return this.adaptor.getModuleName && this.adaptor.getModuleName() === 'CustomDataAdaptor';\n  }\n\n  isGraphQLAdaptor(dataSource) {\n    return this.adaptor.getModuleName && this.adaptor.getModuleName() === 'GraphQLAdaptor';\n  }\n\n  successFunc(record, request) {\n    if (this.isGraphQLAdaptor(this.adaptor)) {\n      let data = JSON.parse(record);\n\n      if (!isNullOrUndefined(data['errors'])) {\n        this.failureFunc(JSON.stringify(data['errors']));\n      }\n    }\n\n    if (this.isCustomDataAdaptor(this.adaptor)) {\n      request = extend({}, this.ajaxReqOption, request);\n    }\n\n    try {\n      DataUtil.parse.parseJson(record);\n    } catch (e) {\n      record = [];\n    }\n\n    record = this.adaptor.processResponse(DataUtil.parse.parseJson(record), this, null, request.httpRequest, request);\n    this.ajaxDeffered.resolve(record);\n  }\n\n  failureFunc(e) {\n    this.ajaxDeffered.reject([{\n      error: e\n    }]);\n  }\n\n  doAjaxRequest(res, ajaxFunc) {\n    res = extend({}, {\n      type: 'POST',\n      contentType: 'application/json; charset=utf-8',\n      processData: false\n    }, res);\n    this.ajaxDeffered = new Deferred();\n\n    if (!this.isCustomDataAdaptor(this.adaptor)) {\n      let ajax = new Ajax(res);\n\n      ajax.beforeSend = () => {\n        this.beforeSend(ajax.httpRequest, ajax);\n      };\n\n      ajax.onSuccess = this.successFunc.bind(this);\n      ajax.onFailure = this.failureFunc.bind(this);\n      ajax.send().catch(e => true); // to handle the failure requests.\n    } else {\n      this.ajaxReqOption = res;\n      ajaxFunc.call(this, {\n        data: res.data,\n        onSuccess: this.successFunc.bind(this),\n        onFailure: this.failureFunc.bind(this)\n      });\n    }\n\n    return this.ajaxDeffered.promise;\n  }\n\n}\n/**\n * Deferred is used to handle asynchronous operation.\n */\n\n\nclass Deferred {\n  constructor() {\n    /**\n     * Promise is an object that represents a value that may not be available yet, but will be resolved at some point in the future.\n     */\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n    /**\n     * Defines the callback function triggers when the Deferred object is resolved.\n     */\n\n    this.then = this.promise.then.bind(this.promise);\n    /**\n     * Defines the callback function triggers when the Deferred object is rejected.\n     */\n\n    this.catch = this.promise.catch.bind(this.promise);\n  }\n\n}\n/**\n * Data modules\n */\n\n\nexport { DataManager, Deferred, Query, Predicate, Adaptor, JsonAdaptor, UrlAdaptor, ODataAdaptor, ODataV4Adaptor, WebApiAdaptor, WebMethodAdaptor, RemoteSaveAdaptor, CustomDataAdaptor, GraphQLAdaptor, CacheAdaptor, DataUtil }; //# sourceMappingURL=ej2-data.es2015.js.map","map":null,"metadata":{},"sourceType":"module"}