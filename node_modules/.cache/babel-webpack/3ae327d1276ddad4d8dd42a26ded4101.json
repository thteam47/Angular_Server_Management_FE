{"ast":null,"code":"/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Disposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $async from \"./AsyncPending\";\nimport * as $type from \"./Type\";\n/*export interface IEventDispatcher<T> {\r\n    isDisposed(): boolean;\r\n    dispose(): void;\r\n    hasListeners(): boolean;\r\n    enable(): void;\r\n    disable(): void;\r\n    enableType<Key extends keyof T>(type: Key): void;\r\n    disableType<Key extends keyof T>(type: Key, amount?: number): void;\r\n    isEnabled<Key extends keyof T>(type: Key): boolean;\r\n    has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean;\r\n    dispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n    dispatch<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n    onAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C): IDisposer;\r\n    on<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n    once<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n    off<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n    off<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n    copyFrom(source: this): void;\r\n}*/\n\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @important\r\n */\n\nvar EventDispatcher = function () {\n  /**\r\n   * Constructor\r\n   */\n  function EventDispatcher() {\n    this._listeners = [];\n    this._killed = [];\n    this._disabled = {};\n    this._iterating = 0;\n    this._enabled = true;\n    this._disposed = false;\n  }\n  /**\r\n   * Returns if this object has been already disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n\n\n  EventDispatcher.prototype.isDisposed = function () {\n    return this._disposed;\n  };\n  /**\r\n   * Dispose (destroy) this object.\r\n   */\n\n\n  EventDispatcher.prototype.dispose = function () {\n    if (!this._disposed) {\n      this._disposed = true;\n      var a = this._listeners;\n      this._iterating = 1;\n      this._listeners = null;\n      this._disabled = null;\n\n      try {\n        $array.each(a, function (x) {\n          x.disposer.dispose();\n        });\n      } finally {\n        this._killed = null;\n        this._iterating = null;\n      }\n    }\n  };\n  /**\r\n   * Checks if this particular event dispatcher has any listeners set.\r\n   *\r\n   * @return Has listeners?\r\n   */\n\n\n  EventDispatcher.prototype.hasListeners = function () {\n    return this._listeners.length !== 0;\n  };\n  /**\r\n   * Checks if this particular event dispatcher has any particular listeners set.\r\n   *\r\n   * @return Has particular event listeners?\r\n   */\n\n\n  EventDispatcher.prototype.hasListenersByType = function (type) {\n    return $array.any(this._listeners, function (x) {\n      return (x.type === null || x.type === type) && !x.killed;\n    });\n  };\n  /**\r\n   * Enable dispatching of events if they were previously disabled by\r\n   * `disable()`.\r\n   */\n\n\n  EventDispatcher.prototype.enable = function () {\n    this._enabled = true;\n  };\n  /**\r\n   * Disable dispatching of events until re-enabled by `enable()`.\r\n   */\n\n\n  EventDispatcher.prototype.disable = function () {\n    this._enabled = false;\n  };\n  /**\r\n   * Enable dispatching particular event, if it was disabled before by\r\n   * `disableType()`.\r\n   *\r\n   * @param type Event type\r\n   */\n\n\n  EventDispatcher.prototype.enableType = function (type) {\n    delete this._disabled[type];\n  };\n  /**\r\n   * Disable dispatching of events for a certain event type.\r\n   *\r\n   * Optionally, can set how many dispatches to skip before automatically\r\n   * re-enabling the dispatching.\r\n   *\r\n   * @param type    Event type\r\n   * @param amount  Number of event dispatches to skip\r\n   */\n\n\n  EventDispatcher.prototype.disableType = function (type, amount) {\n    if (amount === void 0) {\n      amount = Infinity;\n    }\n\n    this._disabled[type] = amount;\n  };\n  /**\r\n   * Removes listener from dispatcher.\r\n   *\r\n   * Will throw an exception if such listener does not exists.\r\n   *\r\n   * @param listener Listener to remove\r\n   */\n\n\n  EventDispatcher.prototype._removeListener = function (listener) {\n    if (this._iterating === 0) {\n      var index = this._listeners.indexOf(listener);\n\n      if (index === -1) {\n        throw new Error(\"Invalid state: could not remove listener\");\n      }\n\n      this._listeners.splice(index, 1);\n    } else {\n      this._killed.push(listener);\n    }\n  };\n  /**\r\n   * Removes existing listener by certain parameters.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n\n\n  EventDispatcher.prototype._removeExistingListener = function (once, type, callback, context) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n\n    this._eachListener(function (info) {\n      if (info.once === once && // TODO is this correct ?\n      info.type === type && (callback == null || info.callback === callback) && info.context === context) {\n        info.disposer.dispose();\n      }\n    });\n  };\n  /**\r\n   * Checks if dispatching for particular event type is enabled.\r\n   *\r\n   * @param type  Event type\r\n   * @return Enabled?\r\n   */\n\n\n  EventDispatcher.prototype.isEnabled = function (type) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    } // TODO is this check correct ?\n\n\n    return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] == null;\n  };\n  /**\r\n   * Checks if there's already a listener with specific parameters.\r\n   *\r\n   * @param type      Listener's type\r\n   * @param callback  Callback function\r\n   * @param context   Callback context\r\n   * @return Has listener?\r\n   */\n\n\n  EventDispatcher.prototype.has = function (type, callback, context) {\n    var index = $array.findIndex(this._listeners, function (info) {\n      return info.once !== true && // Ignoring \"once\" listeners\n      info.type === type && (callback == null || info.callback === callback) && info.context === context;\n    });\n    return index !== -1;\n  };\n  /**\r\n   * Checks whether event of the particular type should be dispatched.\r\n   *\r\n   * @param type  Event type\r\n   * @return Dispatch?\r\n   */\n\n\n  EventDispatcher.prototype._shouldDispatch = function (type) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n\n    var count = this._disabled[type];\n\n    if (!$type.isNumber(count)) {\n      return this._enabled;\n    } else {\n      if (count <= 1) {\n        delete this._disabled[type];\n      } else {\n        --this._disabled[type];\n      }\n\n      return false;\n    }\n  };\n  /**\r\n   * [_eachListener description]\r\n   *\r\n   * All of this extra code is needed when a listener is removed while iterating\r\n   *\r\n   * @todo Description\r\n   * @param fn [description]\r\n   */\n\n\n  EventDispatcher.prototype._eachListener = function (fn) {\n    var _this = this;\n\n    ++this._iterating;\n\n    try {\n      $array.each(this._listeners, fn);\n    } finally {\n      --this._iterating; // TODO should this be inside or outside the finally ?\n\n      if (this._iterating === 0 && this._killed.length !== 0) {\n        // Remove killed listeners\n        $array.each(this._killed, function (killed) {\n          _this._removeListener(killed);\n        });\n        this._killed.length = 0;\n      }\n    }\n  };\n  /**\r\n   * Dispatches an event immediately without waiting for next cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n\n\n  EventDispatcher.prototype.dispatchImmediately = function (type, event) {\n    if (this._shouldDispatch(type)) {\n      // TODO check if it's faster to use an object of listeners rather than a single big array\n      // TODO if the function throws, maybe it should keep going ?\n      this._eachListener(function (listener) {\n        if (!listener.killed && (listener.type === null || listener.type === type)) {\n          listener.dispatch(type, event);\n        }\n      });\n    }\n  };\n  /**\r\n   * Shelves the event to be dispatched within next update cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n\n\n  EventDispatcher.prototype.dispatch = function (type, event) {\n    if (this._shouldDispatch(type)) {\n      this._eachListener(function (listener) {\n        // TODO check if it's faster to use an object of listeners rather than a single big array\n        if (!listener.killed && (listener.type === null || listener.type === type)) {\n          // TODO if the function throws, maybe it should keep going ?\n          // TODO dispatch during the update cycle, rather than using whenIdle\n          $async.whenIdle(function () {\n            if (!listener.killed) {\n              listener.dispatch(type, event);\n            }\n          });\n        }\n      });\n    }\n  };\n  /**\r\n   * Creates, catalogs and returns an [[EventListener]].\r\n   *\r\n   * Event listener can be disposed.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @param dispatch\r\n   * @returns An event listener\r\n   */\n\n\n  EventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {\n    var _this = this;\n\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n\n    this._removeExistingListener(once, type, callback, context);\n\n    var info = {\n      type: type,\n      callback: callback,\n      context: context,\n      shouldClone: shouldClone,\n      dispatch: dispatch,\n      killed: false,\n      once: once,\n      disposer: new Disposer(function () {\n        info.killed = true;\n\n        _this._removeListener(info);\n      })\n    };\n\n    this._listeners.push(info);\n\n    return info;\n  };\n  /**\r\n   * Creates an event listener to be invoked on **any** event.\r\n   *\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   * @todo what if `listen` is called on the same function twice ?\r\n   */\n\n\n  EventDispatcher.prototype.onAll = function (callback, context, shouldClone) {\n    if (shouldClone === void 0) {\n      shouldClone = true;\n    }\n\n    return this._on(false, null, callback, context, shouldClone, function (type, event) {\n      return callback.call(context, type, event);\n    }).disposer;\n  };\n  /**\r\n   * Creates an event listener to be invoked on a specific event type.\r\n   *\r\n   * ```TypeScript\r\n   * series.events.on(\"hidden\", (ev) => {\r\n   *   console.log(\"Series hidden: \" + ev.target.name);\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * series.events.on(\"hidden\", function(ev) {\r\n   *   console.log(\"Series hidden: \" + ev.target.name);\r\n   * }, this);\r\n   * ```\r\n   * ```JSON\r\n   * {\r\n   *   // ...\r\n   *   \"series\": [{\r\n   *     // ...\r\n   *     \"events\": {\r\n   *     \t\"hidden\": function(ev) {\r\n   *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n   *     \t}\r\n   *     }\r\n   *   }]\r\n   * }\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler whenever series we put\r\n   * event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   * @todo what if `listen` is called on the same function twice ?\r\n   */\n\n\n  EventDispatcher.prototype.on = function (type, callback, context, shouldClone) {\n    if (shouldClone === void 0) {\n      shouldClone = true;\n    }\n\n    return this._on(false, type, callback, context, shouldClone, function (type, event) {\n      return callback.call(context, event);\n    }).disposer;\n  };\n  /**\r\n   * Creates an event listener to be invoked on a specific event type once.\r\n   *\r\n   * Once the event listener is invoked, it is automatically disposed.\r\n   *\r\n   * ```TypeScript\r\n   * series.events.on(\"hidden\", (ev) => {\r\n   *   console.log(\"Series hidden: \" + ev.target.name);\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * series.events.on(\"hidden\", function(ev) {\r\n   *   console.log(\"Series hidden: \" + ev.target.name);\r\n   * }, this);\r\n   * ```\r\n   * ```JSON\r\n   * {\r\n   *   // ...\r\n   *   \"series\": [{\r\n   *     // ...\r\n   *     \"events\": {\r\n   *     \t\"hidden\": function(ev) {\r\n   *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n   *     \t}\r\n   *     }\r\n   *   }]\r\n   * }\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler the first time series we\r\n   * put event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   * @todo what if `listen` is called on the same function twice ?\r\n   */\n\n\n  EventDispatcher.prototype.once = function (type, callback, context, shouldClone) {\n    if (shouldClone === void 0) {\n      shouldClone = true;\n    }\n\n    var x = this._on(true, type, callback, context, shouldClone, function (type, event) {\n      x.disposer.dispose();\n      callback.call(context, event);\n    }); // TODO maybe this should return a different Disposer ?\n\n\n    return x.disposer;\n  };\n  /**\r\n   * Removes the event listener with specific parameters.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n\n\n  EventDispatcher.prototype.off = function (type, callback, context) {\n    this._removeExistingListener(false, type, callback, context);\n  };\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   */\n\n\n  EventDispatcher.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n\n    if (source === this) {\n      throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n    }\n\n    $array.each(source._listeners, function (x) {\n      // TODO is this correct ?\n      if (!x.killed && x.shouldClone) {\n        if (x.type === null) {\n          _this.onAll(x.callback, x.context);\n        } else if (x.once) {\n          _this.once(x.type, x.callback, x.context);\n        } else {\n          _this.on(x.type, x.callback, x.context);\n        }\n      }\n    });\n  };\n\n  return EventDispatcher;\n}();\n\nexport { EventDispatcher };\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @important\r\n */\n\nvar TargetedEventDispatcher = function (_super) {\n  __extends(TargetedEventDispatcher, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param target Event dispatcher target\r\n   */\n\n\n  function TargetedEventDispatcher(target) {\n    var _this = _super.call(this) || this;\n\n    _this.target = target;\n    return _this;\n  }\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   */\n\n\n  TargetedEventDispatcher.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n\n    if (source === this) {\n      throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n    }\n\n    $array.each(source._listeners, function (x) {\n      // TODO very hacky\n      if (x.context === source.target) {\n        return;\n      } // TODO is this correct ?\n\n\n      if (!x.killed && x.shouldClone) {\n        if (x.type === null) {\n          _this.onAll(x.callback, x.context);\n        } else if (x.once) {\n          _this.once(x.type, x.callback, x.context);\n        } else {\n          _this.on(x.type, x.callback, x.context);\n        }\n      }\n    });\n  };\n\n  return TargetedEventDispatcher;\n}(EventDispatcher);\n\nexport { TargetedEventDispatcher };","map":{"version":3,"sources":["/home/unutu/fontend/Angular/Angular_Server_Management_FE/node_modules/@amcharts/amcharts4/.internal/core/utils/EventDispatcher.js"],"names":["__extends","Disposer","$array","$async","$type","EventDispatcher","_listeners","_killed","_disabled","_iterating","_enabled","_disposed","prototype","isDisposed","dispose","a","each","x","disposer","hasListeners","length","hasListenersByType","type","any","killed","enable","disable","enableType","disableType","amount","Infinity","_removeListener","listener","index","indexOf","Error","splice","push","_removeExistingListener","once","callback","context","_eachListener","info","isEnabled","has","findIndex","_shouldDispatch","count","isNumber","fn","_this","dispatchImmediately","event","dispatch","whenIdle","_on","shouldClone","onAll","call","on","off","copyFrom","source","TargetedEventDispatcher","_super","target"],"mappings":"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","sourcesContent":["/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Disposer } from \"./Disposer\";\r\nimport * as $array from \"./Array\";\r\nimport * as $async from \"./AsyncPending\";\r\nimport * as $type from \"./Type\";\r\n/*export interface IEventDispatcher<T> {\r\n    isDisposed(): boolean;\r\n    dispose(): void;\r\n    hasListeners(): boolean;\r\n    enable(): void;\r\n    disable(): void;\r\n    enableType<Key extends keyof T>(type: Key): void;\r\n    disableType<Key extends keyof T>(type: Key, amount?: number): void;\r\n    isEnabled<Key extends keyof T>(type: Key): boolean;\r\n    has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean;\r\n    dispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n    dispatch<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n    onAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C): IDisposer;\r\n    on<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n    once<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n    off<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n    off<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n    copyFrom(source: this): void;\r\n}*/\r\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @important\r\n */\r\nvar EventDispatcher = /** @class */ (function () {\r\n    /**\r\n     * Constructor\r\n     */\r\n    function EventDispatcher() {\r\n        this._listeners = [];\r\n        this._killed = [];\r\n        this._disabled = {};\r\n        this._iterating = 0;\r\n        this._enabled = true;\r\n        this._disposed = false;\r\n    }\r\n    /**\r\n     * Returns if this object has been already disposed.\r\n     *\r\n     * @return Disposed?\r\n     */\r\n    EventDispatcher.prototype.isDisposed = function () {\r\n        return this._disposed;\r\n    };\r\n    /**\r\n     * Dispose (destroy) this object.\r\n     */\r\n    EventDispatcher.prototype.dispose = function () {\r\n        if (!this._disposed) {\r\n            this._disposed = true;\r\n            var a = this._listeners;\r\n            this._iterating = 1;\r\n            this._listeners = null;\r\n            this._disabled = null;\r\n            try {\r\n                $array.each(a, function (x) {\r\n                    x.disposer.dispose();\r\n                });\r\n            }\r\n            finally {\r\n                this._killed = null;\r\n                this._iterating = null;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Checks if this particular event dispatcher has any listeners set.\r\n     *\r\n     * @return Has listeners?\r\n     */\r\n    EventDispatcher.prototype.hasListeners = function () {\r\n        return this._listeners.length !== 0;\r\n    };\r\n    /**\r\n     * Checks if this particular event dispatcher has any particular listeners set.\r\n     *\r\n     * @return Has particular event listeners?\r\n     */\r\n    EventDispatcher.prototype.hasListenersByType = function (type) {\r\n        return $array.any(this._listeners, function (x) { return (x.type === null || x.type === type) && !x.killed; });\r\n    };\r\n    /**\r\n     * Enable dispatching of events if they were previously disabled by\r\n     * `disable()`.\r\n     */\r\n    EventDispatcher.prototype.enable = function () {\r\n        this._enabled = true;\r\n    };\r\n    /**\r\n     * Disable dispatching of events until re-enabled by `enable()`.\r\n     */\r\n    EventDispatcher.prototype.disable = function () {\r\n        this._enabled = false;\r\n    };\r\n    /**\r\n     * Enable dispatching particular event, if it was disabled before by\r\n     * `disableType()`.\r\n     *\r\n     * @param type Event type\r\n     */\r\n    EventDispatcher.prototype.enableType = function (type) {\r\n        delete this._disabled[type];\r\n    };\r\n    /**\r\n     * Disable dispatching of events for a certain event type.\r\n     *\r\n     * Optionally, can set how many dispatches to skip before automatically\r\n     * re-enabling the dispatching.\r\n     *\r\n     * @param type    Event type\r\n     * @param amount  Number of event dispatches to skip\r\n     */\r\n    EventDispatcher.prototype.disableType = function (type, amount) {\r\n        if (amount === void 0) { amount = Infinity; }\r\n        this._disabled[type] = amount;\r\n    };\r\n    /**\r\n     * Removes listener from dispatcher.\r\n     *\r\n     * Will throw an exception if such listener does not exists.\r\n     *\r\n     * @param listener Listener to remove\r\n     */\r\n    EventDispatcher.prototype._removeListener = function (listener) {\r\n        if (this._iterating === 0) {\r\n            var index = this._listeners.indexOf(listener);\r\n            if (index === -1) {\r\n                throw new Error(\"Invalid state: could not remove listener\");\r\n            }\r\n            this._listeners.splice(index, 1);\r\n        }\r\n        else {\r\n            this._killed.push(listener);\r\n        }\r\n    };\r\n    /**\r\n     * Removes existing listener by certain parameters.\r\n     *\r\n     * @param once         Listener's once setting\r\n     * @param type         Listener's type\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     */\r\n    EventDispatcher.prototype._removeExistingListener = function (once, type, callback, context) {\r\n        if (this._disposed) {\r\n            throw new Error(\"EventDispatcher is disposed\");\r\n        }\r\n        this._eachListener(function (info) {\r\n            if (info.once === once && // TODO is this correct ?\r\n                info.type === type &&\r\n                (callback == null || info.callback === callback) &&\r\n                info.context === context) {\r\n                info.disposer.dispose();\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Checks if dispatching for particular event type is enabled.\r\n     *\r\n     * @param type  Event type\r\n     * @return Enabled?\r\n     */\r\n    EventDispatcher.prototype.isEnabled = function (type) {\r\n        if (this._disposed) {\r\n            throw new Error(\"EventDispatcher is disposed\");\r\n        }\r\n        // TODO is this check correct ?\r\n        return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] == null;\r\n    };\r\n    /**\r\n     * Checks if there's already a listener with specific parameters.\r\n     *\r\n     * @param type      Listener's type\r\n     * @param callback  Callback function\r\n     * @param context   Callback context\r\n     * @return Has listener?\r\n     */\r\n    EventDispatcher.prototype.has = function (type, callback, context) {\r\n        var index = $array.findIndex(this._listeners, function (info) {\r\n            return info.once !== true && // Ignoring \"once\" listeners\r\n                info.type === type &&\r\n                (callback == null || info.callback === callback) &&\r\n                info.context === context;\r\n        });\r\n        return index !== -1;\r\n    };\r\n    /**\r\n     * Checks whether event of the particular type should be dispatched.\r\n     *\r\n     * @param type  Event type\r\n     * @return Dispatch?\r\n     */\r\n    EventDispatcher.prototype._shouldDispatch = function (type) {\r\n        if (this._disposed) {\r\n            throw new Error(\"EventDispatcher is disposed\");\r\n        }\r\n        var count = this._disabled[type];\r\n        if (!$type.isNumber(count)) {\r\n            return this._enabled;\r\n        }\r\n        else {\r\n            if (count <= 1) {\r\n                delete this._disabled[type];\r\n            }\r\n            else {\r\n                --this._disabled[type];\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * [_eachListener description]\r\n     *\r\n     * All of this extra code is needed when a listener is removed while iterating\r\n     *\r\n     * @todo Description\r\n     * @param fn [description]\r\n     */\r\n    EventDispatcher.prototype._eachListener = function (fn) {\r\n        var _this = this;\r\n        ++this._iterating;\r\n        try {\r\n            $array.each(this._listeners, fn);\r\n        }\r\n        finally {\r\n            --this._iterating;\r\n            // TODO should this be inside or outside the finally ?\r\n            if (this._iterating === 0 && this._killed.length !== 0) {\r\n                // Remove killed listeners\r\n                $array.each(this._killed, function (killed) {\r\n                    _this._removeListener(killed);\r\n                });\r\n                this._killed.length = 0;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Dispatches an event immediately without waiting for next cycle.\r\n     *\r\n     * @param type   Event type\r\n     * @param event  Event object\r\n     * @todo automatically add in type and target properties if they are missing\r\n     */\r\n    EventDispatcher.prototype.dispatchImmediately = function (type, event) {\r\n        if (this._shouldDispatch(type)) {\r\n            // TODO check if it's faster to use an object of listeners rather than a single big array\r\n            // TODO if the function throws, maybe it should keep going ?\r\n            this._eachListener(function (listener) {\r\n                if (!listener.killed && (listener.type === null || listener.type === type)) {\r\n                    listener.dispatch(type, event);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Shelves the event to be dispatched within next update cycle.\r\n     *\r\n     * @param type   Event type\r\n     * @param event  Event object\r\n     * @todo automatically add in type and target properties if they are missing\r\n     */\r\n    EventDispatcher.prototype.dispatch = function (type, event) {\r\n        if (this._shouldDispatch(type)) {\r\n            this._eachListener(function (listener) {\r\n                // TODO check if it's faster to use an object of listeners rather than a single big array\r\n                if (!listener.killed && (listener.type === null || listener.type === type)) {\r\n                    // TODO if the function throws, maybe it should keep going ?\r\n                    // TODO dispatch during the update cycle, rather than using whenIdle\r\n                    $async.whenIdle(function () {\r\n                        if (!listener.killed) {\r\n                            listener.dispatch(type, event);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Creates, catalogs and returns an [[EventListener]].\r\n     *\r\n     * Event listener can be disposed.\r\n     *\r\n     * @param once         Listener's once setting\r\n     * @param type         Listener's type\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n     * @param dispatch\r\n     * @returns An event listener\r\n     */\r\n    EventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {\r\n        var _this = this;\r\n        if (this._disposed) {\r\n            throw new Error(\"EventDispatcher is disposed\");\r\n        }\r\n        this._removeExistingListener(once, type, callback, context);\r\n        var info = {\r\n            type: type,\r\n            callback: callback,\r\n            context: context,\r\n            shouldClone: shouldClone,\r\n            dispatch: dispatch,\r\n            killed: false,\r\n            once: once,\r\n            disposer: new Disposer(function () {\r\n                info.killed = true;\r\n                _this._removeListener(info);\r\n            })\r\n        };\r\n        this._listeners.push(info);\r\n        return info;\r\n    };\r\n    /**\r\n     * Creates an event listener to be invoked on **any** event.\r\n     *\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n     * @returns A disposable event listener\r\n     * @todo what if `listen` is called on the same function twice ?\r\n     */\r\n    EventDispatcher.prototype.onAll = function (callback, context, shouldClone) {\r\n        if (shouldClone === void 0) { shouldClone = true; }\r\n        return this._on(false, null, callback, context, shouldClone, function (type, event) { return callback.call(context, type, event); }).disposer;\r\n    };\r\n    /**\r\n     * Creates an event listener to be invoked on a specific event type.\r\n     *\r\n     * ```TypeScript\r\n     * series.events.on(\"hidden\", (ev) => {\r\n     *   console.log(\"Series hidden: \" + ev.target.name);\r\n     * }, this);\r\n     * ```\r\n     * ```JavaScript\r\n     * series.events.on(\"hidden\", function(ev) {\r\n     *   console.log(\"Series hidden: \" + ev.target.name);\r\n     * }, this);\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"series\": [{\r\n     *     // ...\r\n     *     \"events\": {\r\n     *     \t\"hidden\": function(ev) {\r\n     *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n     *     \t}\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * The above will invoke our custom event handler whenever series we put\r\n     * event on is hidden.\r\n     *\r\n     * @param type         Listener's type\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n     * @returns A disposable event listener\r\n     * @todo what if `listen` is called on the same function twice ?\r\n     */\r\n    EventDispatcher.prototype.on = function (type, callback, context, shouldClone) {\r\n        if (shouldClone === void 0) { shouldClone = true; }\r\n        return this._on(false, type, callback, context, shouldClone, function (type, event) { return callback.call(context, event); }).disposer;\r\n    };\r\n    /**\r\n     * Creates an event listener to be invoked on a specific event type once.\r\n     *\r\n     * Once the event listener is invoked, it is automatically disposed.\r\n     *\r\n     * ```TypeScript\r\n     * series.events.on(\"hidden\", (ev) => {\r\n     *   console.log(\"Series hidden: \" + ev.target.name);\r\n     * }, this);\r\n     * ```\r\n     * ```JavaScript\r\n     * series.events.on(\"hidden\", function(ev) {\r\n     *   console.log(\"Series hidden: \" + ev.target.name);\r\n     * }, this);\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"series\": [{\r\n     *     // ...\r\n     *     \"events\": {\r\n     *     \t\"hidden\": function(ev) {\r\n     *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n     *     \t}\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * The above will invoke our custom event handler the first time series we\r\n     * put event on is hidden.\r\n     *\r\n     * @param type         Listener's type\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n     * @returns A disposable event listener\r\n     * @todo what if `listen` is called on the same function twice ?\r\n     */\r\n    EventDispatcher.prototype.once = function (type, callback, context, shouldClone) {\r\n        if (shouldClone === void 0) { shouldClone = true; }\r\n        var x = this._on(true, type, callback, context, shouldClone, function (type, event) {\r\n            x.disposer.dispose();\r\n            callback.call(context, event);\r\n        });\r\n        // TODO maybe this should return a different Disposer ?\r\n        return x.disposer;\r\n    };\r\n    /**\r\n     * Removes the event listener with specific parameters.\r\n     *\r\n     * @param type         Listener's type\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     */\r\n    EventDispatcher.prototype.off = function (type, callback, context) {\r\n        this._removeExistingListener(false, type, callback, context);\r\n    };\r\n    /**\r\n     * Copies all dispatcher parameters, including listeners, from another event\r\n     * dispatcher.\r\n     *\r\n     * @param source Source event dispatcher\r\n     */\r\n    EventDispatcher.prototype.copyFrom = function (source) {\r\n        var _this = this;\r\n        if (this._disposed) {\r\n            throw new Error(\"EventDispatcher is disposed\");\r\n        }\r\n        if (source === this) {\r\n            throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n        }\r\n        $array.each(source._listeners, function (x) {\r\n            // TODO is this correct ?\r\n            if (!x.killed && x.shouldClone) {\r\n                if (x.type === null) {\r\n                    _this.onAll(x.callback, x.context);\r\n                }\r\n                else if (x.once) {\r\n                    _this.once(x.type, x.callback, x.context);\r\n                }\r\n                else {\r\n                    _this.on(x.type, x.callback, x.context);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    return EventDispatcher;\r\n}());\r\nexport { EventDispatcher };\r\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @important\r\n */\r\nvar TargetedEventDispatcher = /** @class */ (function (_super) {\r\n    __extends(TargetedEventDispatcher, _super);\r\n    /**\r\n     * Constructor\r\n     *\r\n     * @param target Event dispatcher target\r\n     */\r\n    function TargetedEventDispatcher(target) {\r\n        var _this = _super.call(this) || this;\r\n        _this.target = target;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Copies all dispatcher parameters, including listeners, from another event\r\n     * dispatcher.\r\n     *\r\n     * @param source Source event dispatcher\r\n     */\r\n    TargetedEventDispatcher.prototype.copyFrom = function (source) {\r\n        var _this = this;\r\n        if (this._disposed) {\r\n            throw new Error(\"EventDispatcher is disposed\");\r\n        }\r\n        if (source === this) {\r\n            throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n        }\r\n        $array.each(source._listeners, function (x) {\r\n            // TODO very hacky\r\n            if (x.context === source.target) {\r\n                return;\r\n            }\r\n            // TODO is this correct ?\r\n            if (!x.killed && x.shouldClone) {\r\n                if (x.type === null) {\r\n                    _this.onAll(x.callback, x.context);\r\n                }\r\n                else if (x.once) {\r\n                    _this.once(x.type, x.callback, x.context);\r\n                }\r\n                else {\r\n                    _this.on(x.type, x.callback, x.context);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    return TargetedEventDispatcher;\r\n}(EventDispatcher));\r\nexport { TargetedEventDispatcher };\r\n"]},"metadata":{},"sourceType":"module"}