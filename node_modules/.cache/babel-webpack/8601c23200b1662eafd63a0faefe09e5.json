{"ast":null,"code":"import { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { registry } from \"../Registry\";\nimport * as $path from \"./Path\";\nimport * as $array from \"../utils/Array\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $math from \"../utils/Math\";\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\n\nvar Tension = function () {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param tensionX [description]\r\n   * @param tensionY [description]\r\n   */\n  function Tension(tensionX, tensionY) {\n    this._tensionX = tensionX;\n    this._tensionY = tensionY;\n  }\n  /**\r\n   * [smooth description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return [description]\r\n   */\n\n\n  Tension.prototype.smooth = function (points) {\n    for (var i = points.length - 1; i > 0; i--) {\n      var p0 = points[i];\n      var p1 = points[i - 1];\n\n      if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n        points.splice(i - 1, 1);\n      }\n    }\n\n    var tensionX = this._tensionX;\n    var tensionY = this._tensionY;\n\n    if (points.length < 3 || tensionX >= 1 && tensionY >= 1) {\n      return $path.polyline(points);\n    }\n\n    var first = points[0];\n    var last = points[points.length - 1];\n    var closed = false;\n\n    if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n      closed = true;\n    } // Can't moveTo here, as it wont be possible to have fill then.\n\n\n    var path = \"\";\n\n    for (var i = 0, len = points.length - 1; i < len; i++) {\n      var p0 = points[i - 1];\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var p3 = points[i + 2];\n\n      if (i === 0) {\n        if (closed) {\n          p0 = points[points.length - 2];\n        } else {\n          p0 = points[i];\n        }\n      } else if (i == points.length - 2) {\n        if (closed) {\n          p3 = points[1];\n        } else {\n          p3 = points[i + 1];\n        }\n      }\n\n      var controlPointA = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\n      var controlPointB = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\n      path += $path.cubicCurveTo(p2, controlPointA, controlPointB);\n    }\n\n    return path;\n  };\n\n  return Tension;\n}();\n\nexport { Tension };\n/**\r\n * Returns a waved line SVG path between two points.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point1            Starting point\r\n * @param point2            Ending point\r\n * @param waveLength        Wave length\r\n * @param waveHeight        Wave height\r\n * @param adjustWaveLength  Adjust wave length based on the actual line length\r\n * @return SVG path\r\n */\n\nexport function wavedLine(point1, point2, waveLength, waveHeight, tension, adjustWaveLength) {\n  var x1 = point1.x;\n  var y1 = point1.y;\n  var x2 = point2.x;\n  var y2 = point2.y;\n  var distance = $math.getDistance(point1, point2);\n\n  if (adjustWaveLength) {\n    waveLength = distance / Math.round(distance / waveLength);\n  }\n\n  var d = registry.getCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]));\n\n  if (!d) {\n    if (distance > 0) {\n      var angle = Math.atan2(y2 - y1, x2 - x1);\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      var waveLengthX = waveLength * cos;\n      var waveLengthY = waveLength * sin;\n\n      if (waveLength <= 1 || waveHeight <= 1) {\n        d = $path.lineTo(point2);\n      } else {\n        var halfWaveCount = Math.round(2 * distance / waveLength);\n        var points = [];\n        var sign_1 = 1;\n\n        if (x2 < x1) {\n          sign_1 *= -1;\n        }\n\n        if (y2 < y1) {\n          sign_1 *= -1;\n        }\n\n        for (var i = 0; i <= halfWaveCount; i++) {\n          sign_1 *= -1;\n          var x = x1 + i * waveLengthX / 2 + sign_1 * waveHeight / 2 * sin;\n          var y = y1 + i * waveLengthY / 2 - sign_1 * waveHeight / 2 * cos;\n          points.push({\n            x: x,\n            y: y\n          });\n        }\n\n        d = new Tension(tension, tension).smooth(points);\n      }\n    } else {\n      d = \"\";\n    }\n\n    registry.setCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]), d);\n  }\n\n  return d;\n}\n\nvar Monotone = function () {\n  function Monotone(reversed, info) {\n    this._reversed = reversed;\n    this._closed = info.closed;\n  } // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n  // \"you can express cubic Hermite interpolation in terms of cubic BÃ©zier curves\n  // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\n\n\n  Monotone.prototype._curve = function (x0, x1, y0, y1, t0, t1) {\n    var dx = (x1 - x0) / 3;\n\n    if (this._reversed) {\n      return $path.cubicCurveTo({\n        x: y1,\n        y: x1\n      }, {\n        x: y0 + dx * t0,\n        y: x0 + dx\n      }, {\n        x: y1 - dx * t1,\n        y: x1 - dx\n      });\n    } else {\n      return $path.cubicCurveTo({\n        x: x1,\n        y: y1\n      }, {\n        x: x0 + dx,\n        y: y0 + dx * t0\n      }, {\n        x: x1 - dx,\n        y: y1 - dx * t1\n      });\n    }\n  };\n\n  Monotone.prototype.smooth = function (points) {\n    var _this = this;\n\n    var x0 = NaN;\n    var x1 = NaN;\n    var y0 = NaN;\n    var y1 = NaN;\n    var t0 = NaN;\n    var point = 0;\n    var output = \"\";\n    $array.each(points, function (_a) {\n      var x = _a.x,\n          y = _a.y;\n\n      if (_this._reversed) {\n        var temp = x;\n        x = y;\n        y = temp;\n      }\n\n      var t1 = NaN;\n\n      if (!(x === x1 && y === y1)) {\n        switch (point) {\n          case 0:\n            point = 1;\n\n            if (_this._reversed) {\n              output += $path.lineTo({\n                x: y,\n                y: x\n              });\n            } else {\n              output += $path.lineTo({\n                x: x,\n                y: y\n              });\n            }\n\n            break;\n\n          case 1:\n            point = 2;\n            break;\n\n          case 2:\n            point = 3;\n            output += _this._curve(x0, x1, y0, y1, slope2(x0, x1, y0, y1, t1 = slope3(x0, x1, y0, y1, x, y)), t1);\n            break;\n\n          default:\n            output += _this._curve(x0, x1, y0, y1, t0, t1 = slope3(x0, x1, y0, y1, x, y));\n            break;\n        }\n\n        x0 = x1;\n        x1 = x;\n        y0 = y1;\n        y1 = y;\n        t0 = t1;\n      }\n    });\n\n    switch (point) {\n      case 2:\n        if (this._reversed) {\n          output += $path.lineTo({\n            x: y1,\n            y: x1\n          });\n        } else {\n          output += $path.lineTo({\n            x: x1,\n            y: y1\n          });\n        }\n\n        break;\n\n      case 3:\n        output += this._curve(x0, x1, y0, y1, t0, slope2(x0, x1, y0, y1, t0));\n        break;\n    }\n\n    if (this._closed) {\n      output += $path.closePath();\n    }\n\n    return output;\n  };\n\n  return Monotone;\n}();\n\nexport { Monotone }; // TODO move this someplace else\n\nfunction sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\nfunction slope2(x0, x1, y0, y1, t) {\n  var h = x1 - x0;\n  return h ? (3 * (y1 - y0) / h - t) / 2 : t;\n}\n\nfunction slope3(x0, x1, y0, y1, x2, y2) {\n  var h0 = x1 - x0;\n  var h1 = x2 - x1;\n  var s0 = (y1 - y0) / (h0 || h1 < 0 && -0);\n  var s1 = (y2 - y1) / (h1 || h0 < 0 && -0);\n  var p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\nvar MonotoneX = function (_super) {\n  __extends(MonotoneX, _super);\n\n  function MonotoneX(info) {\n    return _super.call(this, false, info) || this;\n  }\n\n  return MonotoneX;\n}(Monotone);\n\nexport { MonotoneX };\n\nvar MonotoneY = function (_super) {\n  __extends(MonotoneY, _super);\n\n  function MonotoneY(info) {\n    return _super.call(this, true, info) || this;\n  }\n\n  return MonotoneY;\n}(Monotone);\n\nexport { MonotoneY };\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\n\nvar Basis = function () {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param info  [description]\r\n   */\n  function Basis(info) {\n    this._closed = info.closed;\n  }\n  /**\r\n   * [smooth description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return [description]\r\n   */\n\n\n  Basis.prototype.smooth = function (points) {\n    var _this = this;\n\n    var x0 = NaN;\n    var x1 = NaN;\n    var x2 = NaN;\n    var x3 = NaN;\n    var x4 = NaN;\n    var y0 = NaN;\n    var y1 = NaN;\n    var y2 = NaN;\n    var y3 = NaN;\n    var y4 = NaN;\n    var point = 0;\n    var output = \"\";\n\n    var pushCurve = function (x, y) {\n      output += $path.cubicCurveTo({\n        x: (x0 + 4 * x1 + x) / 6,\n        y: (y0 + 4 * y1 + y) / 6\n      }, {\n        x: (2 * x0 + x1) / 3,\n        y: (2 * y0 + y1) / 3\n      }, {\n        x: (x0 + 2 * x1) / 3,\n        y: (y0 + 2 * y1) / 3\n      });\n    };\n\n    var pushPoint = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n\n      switch (point) {\n        case 0:\n          point = 1;\n\n          if (_this._closed) {\n            x2 = x;\n            y2 = y;\n          } else {\n            output += $path.lineTo({\n              x: x,\n              y: y\n            });\n          }\n\n          break;\n\n        case 1:\n          point = 2;\n\n          if (_this._closed) {\n            x3 = x;\n            y3 = y;\n          }\n\n          break;\n\n        case 2:\n          point = 3;\n\n          if (_this._closed) {\n            x4 = x;\n            y4 = y;\n            output += $path.moveTo({\n              x: (x0 + 4 * x1 + x) / 6,\n              y: (y0 + 4 * y1 + y) / 6\n            });\n            break;\n          } else {\n            output += $path.lineTo({\n              x: (5 * x0 + x1) / 6,\n              y: (5 * y0 + y1) / 6\n            }); // fall-through\n          }\n\n        default:\n          pushCurve(x, y);\n          break;\n      }\n\n      x0 = x1;\n      x1 = x;\n      y0 = y1;\n      y1 = y;\n    };\n\n    $array.each(points, pushPoint);\n\n    if (this._closed) {\n      switch (point) {\n        case 1:\n          output += $path.moveTo({\n            x: x2,\n            y: y2\n          });\n          output += $path.closePath();\n          break;\n\n        case 2:\n          output += $path.moveTo({\n            x: (x2 + 2 * x3) / 3,\n            y: (y2 + 2 * y3) / 3\n          });\n          output += $path.lineTo({\n            x: (x3 + 2 * x2) / 3,\n            y: (y3 + 2 * y2) / 3\n          });\n          output += $path.closePath();\n          break;\n\n        case 3:\n          pushPoint({\n            x: x2,\n            y: y2\n          });\n          pushPoint({\n            x: x3,\n            y: y3\n          });\n          pushPoint({\n            x: x4,\n            y: y4\n          });\n          break;\n      }\n    } else {\n      switch (point) {\n        case 3:\n          pushCurve(x1, y1);\n        // fall-through\n\n        case 2:\n          output += $path.lineTo({\n            x: x1,\n            y: y1\n          });\n          break;\n      }\n\n      output += $path.closePath();\n    }\n\n    return output;\n  };\n\n  return Basis;\n}();\n\nexport { Basis }; //# sourceMappingURL=Smoothing.js.map","map":null,"metadata":{},"sourceType":"module"}