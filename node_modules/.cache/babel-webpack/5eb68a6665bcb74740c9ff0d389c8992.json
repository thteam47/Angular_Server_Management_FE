{"ast":null,"code":"import { __read, __spread } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { system } from \"../System\";\nimport { registry } from \"../Registry\";\nimport { Container } from \"../Container\";\nimport { Component } from \"../Component\";\nimport { Paper } from \"../rendering/Paper\";\nimport { SVGContainer, svgContainers } from \"../rendering/SVGContainer\";\nimport { FocusFilter } from \"../rendering/filters/FocusFilter\";\nimport { Preloader } from \"../elements/Preloader\";\nimport { AmChartsLogo } from \"../elements/AmChartsLogo\";\nimport { Tooltip } from \"../elements/Tooltip\";\nimport { Disposer, MultiDisposer } from \"../utils/Disposer\";\nimport { percent } from \"./Percent\";\nimport { options } from \"../Options\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\nimport * as $dom from \"./DOM\";\nimport * as $utils from \"./Utils\";\nimport * as $log from \"./Log\";\n/**\r\n * ============================================================================\r\n * INSTANTIATION FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates all HTML and SVG containers needed for the chart instance, as well\r\n * as the new [[Sprite]] (as specified in `classType` parameter).\r\n *\r\n * @param htmlElement  A container to creat elements in\r\n * @param classType    A class definition of the new element to create\r\n * @return Newly-created Sprite object\r\n */\n\nfunction createChild(htmlElement, classType) {\n  var htmlContainer = $dom.getElement(htmlElement); // If there's no container available yet, we create a fake one\n\n  var tmpContainer = false;\n\n  if (!htmlContainer) {\n    htmlContainer = document.createElement(\"div\");\n    htmlContainer.style.width = \"200px\";\n    htmlContainer.style.height = \"200px\";\n    htmlContainer.style.top = \"0\";\n    htmlContainer.style.left = \"0\";\n    htmlContainer.style.visibility = \"hidden\";\n    htmlContainer.style.position = \"absolute\";\n    document.body.appendChild(htmlContainer);\n    tmpContainer = true;\n  }\n\n  if (htmlContainer) {\n    htmlContainer.innerHTML = \"\"; //htmlContainer.style.overflow = \"hidden\";\n\n    var svgDiv_1 = new SVGContainer(htmlContainer);\n    var paper = new Paper(svgDiv_1.SVGContainer, \"svg-\" + (svgContainers.length - 1)); // the approach with masks is chosen because overflow:visible is set on SVG element in order tooltips could go outside\n    // svg area - this is often needed when working with small charts.\n    // main container which holds content container and tooltips container\n\n    var container_1 = new Container();\n    container_1.htmlContainer = htmlContainer;\n    container_1.svgContainer = svgDiv_1;\n    container_1.width = percent(100);\n    container_1.height = percent(100);\n    container_1.background.fillOpacity = 0;\n    container_1.paper = paper;\n    paper.append(container_1.group); // Set up moving to proper element container if it's not yet ready at call time\n\n    if (tmpContainer) {\n      $dom.ready(function () {\n        container_1.moveHtmlContainer(htmlElement);\n      });\n    } // this is set from parent container, but this one doesn't have, so do it manually.\n\n\n    container_1.relativeWidth = 1;\n    container_1.relativeHeight = 1;\n    svgDiv_1.container = container_1; // creating classType instance\n\n    var sprite_1 = container_1.createChild(classType);\n    sprite_1.topParent = container_1;\n    var uid = sprite_1.uid;\n    registry.invalidSprites[uid] = [];\n    registry.invalidDatas[uid] = [];\n    registry.invalidPositions[uid] = [];\n    registry.invalidLayouts[uid] = [];\n    container_1.baseId = uid;\n    sprite_1.isBaseSprite = true;\n    sprite_1.focusFilter = new FocusFilter();\n    registry.baseSprites.push(sprite_1);\n    registry.baseSpritesByUid[uid] = sprite_1;\n    sprite_1.maskRectangle = {\n      x: 0,\n      y: 0,\n      width: Math.max(svgDiv_1.width || 0, 0),\n      height: Math.max(svgDiv_1.height || 0, 0)\n    }; // this solves issues with display:none, as all children are measured as 0x0\n\n    container_1.events.on(\"maxsizechanged\", function (event) {\n      if (event.previousWidth == 0 || event.previousHeight == 0) {\n        container_1.deepInvalidate();\n      }\n\n      if (sprite_1.maskRectangle) {\n        sprite_1.maskRectangle = {\n          x: 0,\n          y: 0,\n          width: Math.max(svgDiv_1.width || 0, 0),\n          height: Math.max(svgDiv_1.height || 0, 0)\n        };\n      }\n    });\n    var loopTimer_1 = null; // Checks to see whether the chart was properly disposed or not\n\n    var loop_1 = function () {\n      if (!sprite_1.isDisposed()) {\n        if ($dom.getRoot(sprite_1.dom) == null) {\n          if (options.autoDispose) {\n            container_1.htmlContainer = undefined;\n            svgDiv_1.htmlElement = undefined;\n            sprite_1.dispose();\n          } else {\n            $log.warn(\"Chart was not disposed\", sprite_1.uid);\n          }\n\n          loopTimer_1 = null;\n        } else {\n          loopTimer_1 = window.setTimeout(loop_1, 1000);\n        }\n      } else {\n        loopTimer_1 = null;\n      }\n    };\n\n    loop_1();\n    sprite_1.addDisposer(new Disposer(function () {\n      if (loopTimer_1 !== null) {\n        clearTimeout(loopTimer_1);\n      }\n\n      $array.remove(registry.baseSprites, sprite_1);\n      registry.baseSpritesByUid[sprite_1.uid] = undefined;\n    })); // TODO figure out a better way of doing this\n\n    sprite_1.addDisposer(container_1); // tooltip container\n\n    var tooltipContainer_1 = container_1.createChild(Container);\n    tooltipContainer_1.topParent = container_1;\n    tooltipContainer_1.width = percent(100);\n    tooltipContainer_1.height = percent(100);\n    tooltipContainer_1.isMeasured = false;\n    container_1.tooltipContainer = tooltipContainer_1;\n    sprite_1.tooltip = new Tooltip();\n    sprite_1.tooltip.hide(0);\n    sprite_1.tooltip.setBounds({\n      x: 0,\n      y: 0,\n      width: tooltipContainer_1.maxWidth,\n      height: tooltipContainer_1.maxHeight\n    });\n    tooltipContainer_1.events.on(\"maxsizechanged\", function () {\n      $type.getValue(sprite_1.tooltip).setBounds({\n        x: 0,\n        y: 0,\n        width: tooltipContainer_1.maxWidth,\n        height: tooltipContainer_1.maxHeight\n      });\n    }, undefined, false); //@todo: maybe we don't need to create one by default but only on request?\n\n    var preloader_1 = new Preloader();\n    preloader_1.events.on(\"inited\", function () {\n      preloader_1.__disabled = true;\n    }, undefined, false);\n    container_1.preloader = preloader_1; //if (!options.commercialLicense) {\n\n    if (sprite_1 instanceof Container && !sprite_1.hasLicense()) {\n      var logo_1 = tooltipContainer_1.createChild(AmChartsLogo);\n      tooltipContainer_1.events.on(\"maxsizechanged\", function (ev) {\n        if (tooltipContainer_1.maxWidth <= 100 || tooltipContainer_1.maxHeight <= 50) {\n          logo_1.hide();\n        } else if (logo_1.isHidden || logo_1.isHiding) {\n          logo_1.show();\n        }\n      }, undefined, false);\n      sprite_1.logo = logo_1;\n      logo_1.align = \"left\";\n      logo_1.valign = \"bottom\";\n    }\n\n    $utils.used(sprite_1.numberFormatter); // need to create one.\n    // Set this as an autonomouse instance\n    // Controls like Preloader, Export will use this.\n\n    container_1.isStandaloneInstance = true;\n\n    if (options.onlyShowOnViewport) {\n      if (!$dom.isElementInViewport(htmlContainer, options.viewportTarget)) {\n        sprite_1.__disabled = true;\n        sprite_1.tooltipContainer.__disabled = true;\n        var disposers = [$dom.addEventListener(window, \"DOMContentLoaded\", function () {\n          viewPortHandler(sprite_1);\n        }), $dom.addEventListener(window, \"load\", function () {\n          viewPortHandler(sprite_1);\n        }), $dom.addEventListener(window, \"resize\", function () {\n          viewPortHandler(sprite_1);\n        }), $dom.addEventListener(window, \"scroll\", function () {\n          viewPortHandler(sprite_1);\n        })];\n\n        if (options.viewportTarget) {\n          var targets = $type.isArray(options.viewportTarget) ? options.viewportTarget : options.viewportTarget ? [options.viewportTarget] : [];\n\n          for (var i = 0; i < targets.length; i++) {\n            var target = targets[i];\n            disposers.push($dom.addEventListener(target, \"resize\", function () {\n              viewPortHandler(sprite_1);\n            }));\n            disposers.push($dom.addEventListener(target, \"scroll\", function () {\n              viewPortHandler(sprite_1);\n            }));\n          }\n        }\n\n        var disposer = new MultiDisposer(disposers);\n        sprite_1.addDisposer(disposer);\n        sprite_1.vpDisposer = disposer;\n      } else if (options.queue) {\n        addToQueue(sprite_1);\n      }\n    } else if (options.queue) {\n      addToQueue(sprite_1);\n    }\n\n    return sprite_1;\n  } else {\n    system.log(\"html container not found\");\n    throw new Error(\"html container not found\");\n  }\n}\n/**\r\n * Disposes all of the currently active charts.\r\n */\n\n\nexport function disposeAllCharts() {\n  while (registry.baseSprites.length !== 0) {\n    registry.baseSprites.pop().dispose();\n  }\n}\nexport function addToQueue(sprite) {\n  if (registry.queue.indexOf(sprite) == -1) {\n    sprite.__disabled = true;\n    sprite.tooltipContainer.__disabled = true;\n    sprite.events.disableType(\"appeared\");\n\n    if (registry.queue.length == 0) {\n      registry.events.once(\"exitframe\", function () {\n        queueHandler(sprite);\n      });\n      system.requestFrame();\n    }\n\n    sprite.addDisposer(new Disposer(function () {\n      removeFromQueue(sprite);\n    }));\n    registry.queue.push(sprite);\n  }\n}\nexport function removeFromQueue(sprite) {\n  var index = registry.queue.indexOf(sprite);\n\n  if (index >= 0) {\n    registry.queue.splice(registry.queue.indexOf(sprite), 1);\n    var nextSprite = registry.queue[index];\n\n    if (nextSprite) {\n      queueHandler(nextSprite);\n    }\n  }\n}\n/**\r\n * Checks whether the chart was not initialized fully due to setting\r\n * of `onlyShowOnViewport`. If it hasn't and is now in the viewport\r\n * the chart will be initialized.\r\n *\r\n * @since 4.9.12\r\n * @param  sprite  Top-level chart object\r\n */\n\nexport function viewPortHandler(sprite) {\n  if (sprite.__disabled && $dom.isElementInViewport(sprite.htmlContainer, options.viewportTarget)) {\n    if (sprite.vpDisposer) {\n      sprite.vpDisposer.dispose();\n    }\n\n    addToQueue(sprite);\n  }\n}\nexport function queueHandler(sprite) {\n  sprite.__disabled = false;\n  sprite.tooltipContainer.__disabled = false;\n  sprite.events.enableType(\"appeared\");\n  sprite.dispatch(\"removedfromqueue\");\n\n  if (sprite.showOnInit) {\n    sprite.events.on(\"appeared\", function () {\n      removeFromQueue(sprite);\n    });\n  }\n\n  if (sprite.vpDisposer) {\n    sprite.vpDisposer.dispose();\n  }\n\n  if (sprite instanceof Container) {\n    sprite.invalidateLabels();\n  }\n\n  if (sprite.tooltipContainer) {\n    sprite.tooltipContainer.invalidateLayout();\n  }\n\n  if (sprite instanceof Component) {\n    sprite.invalidateData();\n    sprite.reinit();\n    sprite.events.once(\"datavalidated\", function () {\n      if (sprite.showOnInit) {\n        sprite.appear();\n      } else {\n        removeFromQueue(sprite);\n      }\n    });\n  } else {\n    sprite.reinit();\n    sprite.events.once(\"inited\", function () {\n      removeFromQueue(sprite);\n    });\n\n    if (sprite.showOnInit) {\n      sprite.appear();\n    }\n  }\n}\n/**\r\n * A shortcut to creating a chart instance.\r\n *\r\n * The first argument is either a reference to or an id of a DOM element to be\r\n * used as a container for the chart.\r\n *\r\n * The second argument is the type reference of the chart type. (for plain\r\n * JavaScript users this can also be a string indicating chart type)\r\n *\r\n * ```TypeScript\r\n * let chart = am4core.create(\"chartdiv\", am4charts.PieChart);\r\n * ```\r\n * ```JavaScript\r\n * // Can pass in chart type reference like this:\r\n * var chart = am4core.create(\"chartdiv\", am4charts.PieChart);\r\n *\r\n * // ... or chart class type as a string:\r\n * var chart = am4core.create(\"chartdiv\", \"PieChart\");\r\n * ```\r\n *\r\n * @param htmlElement  Reference or id of the target container element\r\n * @param classType    Class type of the target chart type\r\n * @return Chart instance\r\n */\n\nexport function create(htmlElement, classType) {\n  // This is a nasty hack for the benefit of vanilla JS users, who do not\n  // enjoy benefits of type-check anyway.\n  // We're allowing passing in a name of the class rather than type reference\n  // itself.\n  var classError;\n\n  if ($type.isString(classType)) {\n    if ($type.hasValue(registry.registeredClasses[classType])) {\n      classType = registry.registeredClasses[classType];\n    } else {\n      classType = registry.registeredClasses[\"Container\"];\n      classError = new Error(\"Class [\" + classType + \"] is not loaded.\");\n    }\n  } // Create the chart\n\n\n  var chart = createChild(htmlElement, classType); // Error?\n\n  if (classError) {\n    chart.raiseCriticalError(classError);\n  }\n\n  return chart;\n}\n/**\r\n * A shortcut to creating a chart from a config object.\r\n *\r\n * Example:\r\n *\r\n * ```TypeScript\r\n * let chart am4core.createFromConfig({ ... }, \"chartdiv\", am4charts.XYChart );\r\n * ```\r\n * ```JavaScript\r\n * var chart am4core.createFromConfig({ ... }, \"chartdiv\", \"XYChart\" );\r\n * ```\r\n *\r\n * If `chartType` parameter is not supplied it must be set in a config object,\r\n * via reference to chart type, e.g.:\r\n *\r\n * ```TypeScript\r\n * {\r\n *   \"type\": am4charts.XYChart,\r\n *   // ...\r\n * }\r\n * ```\r\n * ```JavaScript\r\n * {\r\n *   \"type\": am4charts.XYChart,\r\n *   // ...\r\n * }\r\n * ```\r\n *\r\n * Or via string: (if you are using JavaScript)\r\n *\r\n * ```TypeScript\r\n * {\r\n *   \"type\": \"XYChart\",\r\n *   // ...\r\n * }\r\n * ```\r\n * ```JavaScript\r\n * {\r\n *   \"type\": \"XYChart\",\r\n *   // ...\r\n * }\r\n * ```\r\n *\r\n * A `container` can either be a reference to an HTML container to put chart\r\n * in, or it's unique id.\r\n *\r\n * If `container` is not specified, it must be included in the config object:\r\n *\r\n * ```TypeScript\r\n * {\r\n *   \"type\": \"XYChart\",\r\n *   \"container\": \"chartdiv\",\r\n *   // ...\r\n * }\r\n * ```\r\n * ```JavaScript\r\n * {\r\n *   \"type\": \"XYChart\",\r\n *   \"container\": \"chartdiv\",\r\n *   // ...\r\n * }\r\n * ```\r\n *\r\n * @param config       Config object in property/value pairs\r\n * @param htmlElement  Container reference or ID\r\n * @param objectType   Chart type\r\n * @return A newly created chart instance\r\n * @todo Throw exception if type is not correct\r\n */\n\nexport function createFromConfig(config, htmlElement, classType) {\n  // Extract chart type from config if necessary\n  if (!$type.hasValue(classType)) {\n    classType = config.type;\n    delete config.type;\n  } // Extract element from config if necessary\n\n\n  if (!$type.hasValue(htmlElement)) {\n    htmlElement = config.container;\n    delete config.container;\n  } // Check if we need to extract actual type reference\n\n\n  var finalType;\n  var classError;\n\n  if ($type.isString(classType) && $type.hasValue(registry.registeredClasses[classType])) {\n    finalType = registry.registeredClasses[classType];\n  } else if (typeof classType !== \"function\") {\n    finalType = Container;\n    classError = new Error(\"Class [\" + classType + \"] is not loaded.\");\n  } else {\n    finalType = classType;\n  } // Create the chart\n\n\n  var chart = createChild(htmlElement, finalType); // Set config\n\n  if (classError) {\n    chart.raiseCriticalError(classError);\n  } else {\n    chart.config = config;\n  }\n\n  return chart;\n}\n/**\r\n * Useful in creating real queues form mult-chart creation.\r\n *\r\n * Accepts a reference to a function which crates and returns actual chart\r\n * object.\r\n *\r\n * It returns a `Promise` which you can use to catch chart instance once it's\r\n * created.\r\n *\r\n * ```TypeScript\r\n * am4core.createDeferred(function(div) {\r\n *   // Create first chart\r\n *   let chart = am4core.create(div, am4charts.XYChart);\r\n *   // ...\r\n *   return chart;\r\n * }, \"chartdiv1\").then(chart) {\r\n *   // `chart` variable holds an instance of the chart\r\n *   console.log(\"Chart ready\", chart);\r\n * }\r\n *\r\n * am4core.createDeferred(function(div) {\r\n *   // Create second chart\r\n *   let chart = am4core.create(div, am4charts.PieChart);\r\n *   // ...\r\n *   return chart;\r\n * }, \"chartdiv2\").then(chart) {\r\n *   // `chart` variable holds an instance of the chart\r\n *   console.log(\"Chart ready\", chart);\r\n * }\r\n * ```\r\n * ```JavaScript\r\n * am4core.createDeferred(function(div) {\r\n *   // Create first chart\r\n *   var chart = am4core.create(div, am4charts.XYChart);\r\n *   // ...\r\n *   return chart;\r\n * }, \"chartdiv1\").then(chart) {\r\n *   // `chart` variable holds an instance of the chart\r\n *   console.log(\"Chart ready\", chart);\r\n * }\r\n *\r\n * am4core.createDeferred(function(div) {\r\n *   // Create second chart\r\n *   var chart = am4core.create(div, am4charts.PieChart);\r\n *   // ...\r\n *   return chart;\r\n * }, \"chartdiv2\").then(chart) {\r\n *   // `chart` variable holds an instance of the chart\r\n *   console.log(\"Chart ready\", chart);\r\n * }\r\n * ```\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Deferred_daisy_chained_instantiation} for more information\r\n * @since 4.10.0\r\n * @param  callback  Callback function that creates chart\r\n * @param  scope     Scope to call callback in\r\n * @param  ...rest   Parameters to pass into callback\r\n * @return           Promise with chart instance\r\n */\n\nexport function createDeferred(callback, scope) {\n  var rest = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    rest[_i - 2] = arguments[_i];\n  }\n\n  return new Promise(function (resolve, reject) {\n    registry.deferred.push({\n      scope: scope,\n      callback: callback,\n      args: rest,\n      resolve: resolve\n    });\n\n    if (registry.deferred.length == 1) {\n      processNextDeferred();\n    }\n  });\n}\n\nfunction processNextDeferred() {\n  var _a;\n\n  var next = registry.deferred[0];\n\n  if (next) {\n    var sprite_2 = (_a = next.callback).call.apply(_a, __spread([next.scope], next.args));\n\n    sprite_2.events.on(\"ready\", function () {\n      next.resolve(sprite_2);\n      registry.deferred.shift();\n\n      if (options.deferredDelay) {\n        setTimeout(processNextDeferred, options.deferredDelay);\n      } else {\n        processNextDeferred();\n      }\n    });\n  }\n}\n/**\r\n * Applies a theme to System, and subsequently all chart instances created\r\n * from that point forward.\r\n *\r\n * amCharts supports multiple themes. Calling `useTheme` multiple times will\r\n * make the System apply multiple themes, rather than overwrite previously\r\n * set one.\r\n *\r\n * This enables combining features from multiple themes on the same chart.\r\n * E.g.:\r\n *\r\n * ```TypeScript\r\n * am4core.useTheme(am4themes.material);\r\n * am4core.useTheme(am4themes.animated);\r\n * ```\r\n * ```JavaScript\r\n * am4core.useTheme(am4themes.material);\r\n * am4core.useTheme(am4themes.animated);\r\n * ```\r\n *\r\n * The above will apply both the Material color and animation options to all\r\n * charts created.\r\n *\r\n * @param value  A reference to a theme\r\n */\n\n\nexport function useTheme(value) {\n  if (registry.themes.indexOf(value) === -1) {\n    registry.themes.push(value);\n  }\n}\n/**\r\n * Removes a theme from \"active themes\" list, so it won't get applied to any\r\n * charts created subsequently.\r\n *\r\n * @param value  A reference to a theme\r\n */\n\nexport function unuseTheme(value) {\n  $array.remove(registry.themes, value);\n}\n/**\r\n * Removes all \"active\" themes. Any charts created subsequently will not have\r\n * any theme applied to them.\r\n */\n\nexport function unuseAllThemes() {\n  registry.themes = [];\n}\n/**\r\n * Adds a license, e.g.:\r\n *\r\n * ```TypeScript\r\n * am4core.addLicense(\"xxxxxxxx\");\r\n * ```\r\n * ```JavaScript\r\n * am4core.addLicense(\"xxxxxxxx\");\r\n * ```\r\n *\r\n * Multiple licenses can be added to cover for multiple products.\r\n *\r\n * @since 4.5.16\r\n * @param  license  License key\r\n */\n\nexport function addLicense(license) {\n  options.licenses.push(license);\n} //# sourceMappingURL=Instance.js.map","map":null,"metadata":{},"sourceType":"module"}