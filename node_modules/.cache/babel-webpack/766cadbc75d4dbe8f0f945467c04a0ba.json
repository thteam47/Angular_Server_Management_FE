{"ast":null,"code":"/**\r\n * A module with functionality for buildin a scrollbar with an XY graph in it.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Scrollbar } from \"../../core/elements/Scrollbar\";\nimport { Sprite } from \"../../core/Sprite\";\nimport { List } from \"../../core/utils/List\";\nimport { MutableValueDisposer } from \"../../core/utils/Disposer\";\nimport { XYChart } from \"../types/XYChart\";\nimport { ValueAxis } from \"../axes/ValueAxis\";\nimport { DateAxis } from \"../axes/DateAxis\";\nimport { registry } from \"../../core/Registry\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport { DesaturateFilter } from \"../../core/rendering/filters/DesaturateFilter\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport { percent } from \"../../core/utils/Percent\";\nimport { color } from \"../../core/utils/Color\";\nimport { options } from \"../../core/Options\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A special version of the Scrollbar that has an XY chart in it.\r\n *\r\n * Used mainly as an advanced scrollbar with a preview for other XY charts.\r\n *\r\n * However, can be used as standalone element.\r\n *\r\n * @see {@link IXYChartScrollbarEvents} for a list of available events\r\n * @see {@link IXYChartScrollbarAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar XYChartScrollbar = function (_super) {\n  __extends(XYChartScrollbar, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function XYChartScrollbar() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A chart element Scrollbar is for.\r\n     */\n\n\n    _this._chart = new MutableValueDisposer();\n    _this.className = \"XYChartScrollbar\";\n    var interfaceColors = new InterfaceColorSet();\n\n    _this.padding(0, 0, 0, 0);\n\n    var scrollbarChart = _this.createChild(XYChart);\n\n    scrollbarChart.shouldClone = false;\n    scrollbarChart.margin(0, 0, 0, 0);\n    scrollbarChart.padding(0, 0, 0, 0);\n    scrollbarChart.interactionsEnabled = false;\n    _this._scrollbarChart = scrollbarChart;\n\n    if (!$utils.isIE()) {\n      var filter = new DesaturateFilter();\n      filter.filterUnits = \"userSpaceOnUse\";\n      scrollbarChart.plotContainer.filters.push(filter);\n    }\n\n    _this._disposers.push(_this._scrollbarChart);\n\n    _this.minHeight = 60;\n    _this.minWidth = 60;\n\n    var unselectedOverlay = _this.createChild(Sprite);\n\n    unselectedOverlay.shouldClone = false;\n    unselectedOverlay.setElement(_this.paper.add(\"path\"));\n    unselectedOverlay.fill = interfaceColors.getFor(\"background\");\n    unselectedOverlay.fillOpacity = 0.8;\n    unselectedOverlay.interactionsEnabled = false;\n    unselectedOverlay.isMeasured = false;\n    unselectedOverlay.toBack();\n    _this._unselectedOverlay = unselectedOverlay;\n\n    _this._disposers.push(_this._unselectedOverlay);\n\n    scrollbarChart.toBack();\n\n    _this.background.cornerRadius(0, 0, 0, 0);\n\n    var thumbBackground = _this.thumb.background;\n    thumbBackground.cornerRadius(0, 0, 0, 0);\n    thumbBackground.fillOpacity = 0;\n    thumbBackground.fill = interfaceColors.getFor(\"background\");\n    var hoverState = thumbBackground.states.getKey(\"hover\");\n\n    if (hoverState) {\n      hoverState.properties.fillOpacity = 0.2;\n    }\n\n    var downState = thumbBackground.states.getKey(\"down\");\n\n    if (downState) {\n      downState.properties.fillOpacity = 0.4;\n    }\n\n    _this._disposers.push(_this._chart);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(XYChartScrollbar.prototype, \"series\", {\n    /**\r\n     * A list of series that are used to draw graph(s) on the scrollbar.\r\n     *\r\n     * @readonly\r\n     * @return Series\r\n     */\n    get: function () {\n      if (!this._series) {\n        this._series = new List();\n\n        this._disposers.push(this._series.events.on(\"inserted\", this.handleSeriesAdded, this, false));\n\n        this._disposers.push(this._series.events.on(\"removed\", this.handleSeriesRemoved, this, false));\n      }\n\n      return this._series;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Decorates a new series when they are pushed into a `series` list.\r\n   *\r\n   * @param event Event\r\n   */\n\n  XYChartScrollbar.prototype.handleSeriesAdded = function (event) {\n    var _this = this;\n\n    var sourceSeries = event.newValue;\n\n    if (!sourceSeries.xAxis || !sourceSeries.yAxis) {\n      return;\n    }\n\n    var scrollbarChart = this.scrollbarChart;\n    scrollbarChart.zoomOutButton.disabled = true;\n    this.chart = sourceSeries.chart;\n    scrollbarChart.dateFormatter.inputDateFormat = this.chart.dateFormatter.inputDateFormat; // Ensure that scrollbar chart shares the same locale as parent chart\n\n    scrollbarChart.language.locale = this.chart.language.locale;\n    var addXAxis = true;\n    var addYAxis = true; // check if we haven't added clone of x or y axis before\n\n    $iter.each(this.series.iterator(), function (series) {\n      if (series != sourceSeries) {\n        if (series.xAxis == sourceSeries.xAxis && _this.scrollbarChart.xAxes.length > 0) {\n          addXAxis = false;\n        }\n\n        if (series.yAxis == sourceSeries.yAxis && _this.scrollbarChart.yAxes.length > 0) {\n          addYAxis = false;\n        }\n      }\n    });\n    sourceSeries.events.on(\"beforedisposed\", function () {\n      _this.series.removeValue(sourceSeries);\n    });\n    var interfaceColors = new InterfaceColorSet();\n    var series = sourceSeries.clone();\n\n    if (options.onlyShowOnViewport || options.queue) {\n      this.addDisposer(this.chart.events.on(\"removedfromqueue\", function () {\n        scrollbarChart.invalidateData();\n      }));\n    }\n\n    if ($utils.isIE()) {\n      series.stroke = color(\"#aaaaaa\");\n      series.fill = series.stroke;\n      series.propertyFields.fill = undefined;\n      series.propertyFields.stroke = undefined;\n    }\n\n    sourceSeries.scrollbarSeries = series;\n\n    if (addXAxis) {\n      var xAxis = sourceSeries.xAxis.clone();\n      scrollbarChart.xAxes.moveValue(xAxis);\n      xAxis.title.disabled = true;\n      xAxis.rangeChangeDuration = 0; //xAxis.id = sourceSeries.uid;\n\n      var renderer = xAxis.renderer;\n      renderer.ticks.template.disabled = true;\n      renderer.inside = true;\n      renderer.labels.template.inside = true;\n      renderer.line.strokeOpacity = 0;\n      renderer.minLabelPosition = 0.02;\n      renderer.maxLabelPosition = 0.98;\n      renderer.line.disabled = true;\n      renderer.axisFills.template.disabled = true;\n      renderer.baseGrid.disabled = true;\n      renderer.grid.template.strokeOpacity = 0.05;\n      renderer.minWidth = undefined;\n      renderer.minHeight = undefined;\n      renderer.padding(0, 0, 0, 0);\n      renderer.chart = scrollbarChart;\n      renderer.margin(0, 0, 0, 0);\n      xAxis.width = percent(100);\n      var labelsTemplate = renderer.labels.template;\n      labelsTemplate.fillOpacity = 0.5;\n      xAxis.maxZoomCount = undefined;\n      xAxis.minZoomCount = undefined;\n\n      if (xAxis instanceof DateAxis) {\n        var vAxis_1 = xAxis;\n        var sourceAxis = sourceSeries.xAxis;\n        vAxis_1.groupCount = sourceAxis.groupCount * 5;\n        vAxis_1.min = undefined;\n        vAxis_1.max = undefined;\n\n        this._disposers.push(vAxis_1.clonedFrom.events.on(\"extremeschanged\", function () {\n          if ($type.isNumber(vAxis_1.clonedFrom.minDefined)) {\n            vAxis_1.min = vAxis_1.clonedFrom.minDefined;\n          }\n\n          if ($type.isNumber(vAxis_1.clonedFrom.maxDefined)) {\n            vAxis_1.max = vAxis_1.clonedFrom.maxDefined;\n          }\n        }, undefined, false));\n      } else if (xAxis instanceof ValueAxis) {\n        var vAxis_2 = xAxis;\n        vAxis_2.min = undefined;\n        vAxis_2.max = undefined;\n\n        if (!$type.isNumber(vAxis_2.clonedFrom.minDefined)) {\n          vAxis_2.min = undefined;\n        }\n\n        if (!$type.isNumber(vAxis_2.clonedFrom.maxDefined)) {\n          vAxis_2.max = undefined;\n        }\n\n        this._disposers.push(vAxis_2.clonedFrom.events.on(\"extremeschanged\", function () {\n          if ($type.isNumber(vAxis_2.clonedFrom.minDefined)) {\n            vAxis_2.min = vAxis_2.clonedFrom.min;\n          }\n\n          if ($type.isNumber(vAxis_2.clonedFrom.maxDefined)) {\n            vAxis_2.max = vAxis_2.clonedFrom.max;\n          }\n        }, undefined, false));\n      }\n\n      series.xAxis = xAxis;\n    } else {\n      this.scrollbarChart.xAxes.each(function (xAxis) {\n        if (xAxis.clonedFrom == sourceSeries.xAxis) {\n          series.xAxis = xAxis;\n        }\n      });\n    }\n\n    if (addYAxis) {\n      var yAxis = sourceSeries.yAxis.clone();\n      scrollbarChart.yAxes.moveValue(yAxis);\n      yAxis.title.disabled = true;\n      yAxis.rangeChangeDuration = 0;\n      var renderer = yAxis.renderer;\n      renderer.ticks.template.disabled = true;\n      renderer.inside = true;\n      renderer.labels.template.inside = true;\n      renderer.line.strokeOpacity = 0;\n      renderer.minLabelPosition = 0.02;\n      renderer.maxLabelPosition = 0.98;\n      renderer.line.disabled = true;\n      renderer.axisFills.template.disabled = true;\n      renderer.grid.template.stroke = interfaceColors.getFor(\"background\");\n      renderer.baseGrid.disabled = true;\n      renderer.grid.template.strokeOpacity = 0.05;\n      renderer.minWidth = undefined;\n      renderer.minHeight = undefined;\n      renderer.chart = scrollbarChart;\n      renderer.padding(0, 0, 0, 0);\n      renderer.margin(0, 0, 0, 0);\n      yAxis.height = percent(100);\n      var labelsTemplate = renderer.labels.template;\n      labelsTemplate.fillOpacity = 0.5;\n      series.yAxis = yAxis;\n      yAxis.maxZoomCount = undefined;\n      yAxis.minZoomCount = undefined;\n\n      if (yAxis instanceof DateAxis) {\n        var vAxis_3 = yAxis;\n        vAxis_3.min = undefined;\n        vAxis_3.max = undefined;\n        var sourceAxis = sourceSeries.yAxis;\n        yAxis.groupCount = sourceAxis.groupCount * 5;\n\n        this._disposers.push(vAxis_3.clonedFrom.events.on(\"extremeschanged\", function () {\n          if ($type.isNumber(vAxis_3.clonedFrom.minDefined)) {\n            vAxis_3.min = vAxis_3.clonedFrom.minDefined;\n          }\n\n          if ($type.isNumber(vAxis_3.clonedFrom.maxDefined)) {\n            vAxis_3.max = vAxis_3.clonedFrom.maxDefined;\n          }\n        }));\n      } else if (yAxis instanceof ValueAxis) {\n        var vAxis_4 = yAxis;\n        vAxis_4.min = undefined;\n        vAxis_4.max = undefined;\n\n        if (!$type.isNumber(vAxis_4.clonedFrom.minDefined)) {\n          vAxis_4.min = undefined;\n        }\n\n        if (!$type.isNumber(vAxis_4.clonedFrom.maxDefined)) {\n          vAxis_4.max = undefined;\n        }\n\n        this._disposers.push(vAxis_4.clonedFrom.events.on(\"extremeschanged\", function () {\n          if ($type.isNumber(vAxis_4.clonedFrom.minDefined)) {\n            vAxis_4.min = vAxis_4.clonedFrom.minDefined;\n          }\n\n          if ($type.isNumber(vAxis_4.clonedFrom.maxDefined)) {\n            vAxis_4.max = vAxis_4.clonedFrom.maxDefined;\n          }\n        }));\n      }\n    } else {\n      this.scrollbarChart.yAxes.each(function (yAxis) {\n        if (yAxis.clonedFrom == sourceSeries.yAxis) {\n          series.yAxis = yAxis;\n        }\n      });\n    }\n\n    series.rangeChangeDuration = 0;\n    series.interpolationDuration = 0;\n    series.defaultState.transitionDuration = 0;\n    series.showOnInit = false;\n\n    this._disposers.push(series.events.on(\"validated\", this.zoomOutAxes, this, false)); // data might be set drectly on series\n\n\n    this._disposers.push(sourceSeries.events.on(\"datavalidated\", function () {\n      if (series.data != sourceSeries.data) {\n        // data setter doesn't check this\n        series.data = sourceSeries.data;\n      }\n    }, undefined, false));\n\n    series.defaultState.properties.visible = true;\n    scrollbarChart.series.push(series);\n    this.updateByOrientation();\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  XYChartScrollbar.prototype.updateByOrientation = function () {\n    var _this = this;\n\n    if (this._scrollbarChart) {\n      $iter.each(this._scrollbarChart.xAxes.iterator(), function (xAxis) {\n        var renderer = xAxis.renderer;\n\n        if (_this.orientation == \"vertical\") {\n          renderer.grid.template.disabled = true;\n          renderer.labels.template.disabled = true;\n          renderer.minGridDistance = 10;\n        } else {\n          renderer.grid.template.disabled = false;\n          renderer.labels.template.disabled = false;\n          renderer.minGridDistance = xAxis.clonedFrom.renderer.minGridDistance;\n        }\n      });\n      $iter.each(this._scrollbarChart.yAxes.iterator(), function (yAxis) {\n        var renderer = yAxis.renderer;\n\n        if (_this.orientation == \"horizontal\") {\n          renderer.grid.template.disabled = true;\n          renderer.labels.template.disabled = true;\n          renderer.minGridDistance = 10;\n        } else {\n          renderer.grid.template.disabled = false;\n          renderer.labels.template.disabled = false;\n          renderer.minGridDistance = yAxis.clonedFrom.renderer.minGridDistance;\n        }\n      });\n    }\n  };\n  /**\r\n   * Cleans up after series are removed from Scrollbar.\r\n   *\r\n   * @param event  Event\r\n   */\n\n\n  XYChartScrollbar.prototype.handleSeriesRemoved = function (event) {\n    var sourceSeries = event.oldValue;\n    var scrollbarChart = this.scrollbarChart;\n    scrollbarChart.series.each(function (series) {\n      if (series && series.clonedFrom == sourceSeries) {\n        scrollbarChart.series.removeValue(series);\n      }\n    });\n\n    if (scrollbarChart.series.length == 0) {\n      scrollbarChart.xAxes.clear();\n      scrollbarChart.yAxes.clear();\n    }\n\n    try {\n      sourceSeries.events.off(\"validated\", this.zoomOutAxes, this);\n    } catch (err) {}\n  };\n\n  Object.defineProperty(XYChartScrollbar.prototype, \"scrollbarChart\", {\n    /**\r\n     * A chart element that is used to display graphs in the Scrollbar.\r\n     *\r\n     * This is not the same as `chart`. It's a totally independent instance of\r\n     * [[XYChart]] with separate config, series, etc.\r\n     *\r\n     * It can be configured just like any other [[XYChart]].\r\n     *\r\n     * @readonly\r\n     * @return Scrollbar's internal chart\r\n     */\n    get: function () {\n      return this._scrollbarChart;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYChartScrollbar.prototype, \"chart\", {\n    /**\r\n     * @return Chart\r\n     */\n    get: function () {\n      return this._chart.get();\n    },\n\n    /**\r\n     * A chart that Scrollbar belongs to.\r\n     *\r\n     * @param chart  Chart\r\n     */\n    set: function (chart) {\n      if (this._chart.get() !== chart) {\n        this._chart.set(chart, chart.events.on(\"datavalidated\", this.handleDataChanged, this, false));\n\n        this.handleDataChanged();\n        this._scrollbarChart.dataProvider = chart; // this makes scrollbar chart do not validate data untill charts' data is validated\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYChartScrollbar.prototype, \"unselectedOverlay\", {\n    /**\r\n     * A [[Sprite]] object representing overlay that is used to dim area of the\r\n     * scrollbar that is currently not selected.\r\n     *\r\n     * Use its `fillOpacity` to set opacity of the fill, with `0` (zero)\r\n     * completely disabling the dimming, and `1` making unselected area completely\r\n     * blank.\r\n     *\r\n     * @since 4.6.1\r\n     * @readonly\r\n     * @return Unselected area curtain element\r\n     */\n    get: function () {\n      return this._unselectedOverlay;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates Scrollbar's internal chart's data when the main chart's data\r\n   * changes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  XYChartScrollbar.prototype.handleDataChanged = function () {\n    if (this.chart.data != this.scrollbarChart.data) {\n      this.scrollbarChart.data = this.chart.data;\n    } else {\n      // add data is handled in XYChart\n      // invalidating all data caused the problem: https://github.com/amcharts/amcharts4/issues/2096\n      this.scrollbarChart.invalidateRawData();\n    }\n  };\n  /**\r\n   * Zooms out all axes on the internal chart.\r\n   */\n\n\n  XYChartScrollbar.prototype.zoomOutAxes = function () {\n    var scrollbarChart = this.scrollbarChart;\n    $iter.each(scrollbarChart.xAxes.iterator(), function (x) {\n      x.zoom({\n        start: 0,\n        end: 1\n      }, true, true);\n    });\n    $iter.each(scrollbarChart.yAxes.iterator(), function (y) {\n      y.zoom({\n        start: 0,\n        end: 1\n      }, true, true);\n    });\n  };\n  /**\r\n   * Updates scrollbar thumb.\r\n   */\n\n\n  XYChartScrollbar.prototype.updateThumb = function () {\n    _super.prototype.updateThumb.call(this);\n\n    if (this._unselectedOverlay) {\n      var thumb = this.thumb;\n      var x = thumb.pixelX || 0;\n      var y = thumb.pixelY || 0;\n      var w = thumb.pixelWidth || 0;\n      var h = thumb.pixelHeight || 0;\n      var path = \"\";\n\n      if (this.orientation == \"horizontal\") {\n        path = $path.rectToPath({\n          x: -1,\n          y: 0,\n          width: x,\n          height: h\n        });\n        path += $path.rectToPath({\n          x: x + w,\n          y: 0,\n          width: (this.pixelWidth || 0) - x - w,\n          height: h\n        });\n      } else {\n        path = $path.rectToPath({\n          x: 0,\n          y: 0,\n          width: w,\n          height: y\n        });\n        path += $path.rectToPath({\n          x: 0,\n          y: y + h,\n          width: w,\n          height: (this.pixelHeight || 0) - y - h\n        });\n      }\n\n      this._unselectedOverlay.path = path;\n    }\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n\n  XYChartScrollbar.prototype.processConfig = function (config) {\n    if (config) {\n      if ($type.hasValue(config.series) && $type.isArray(config.series)) {\n        for (var i = 0, len = config.series.length; i < len; i++) {\n          var series = config.series[i];\n\n          if ($type.hasValue(series) && $type.isString(series)) {\n            if (this.map.hasKey(series)) {\n              config.series[i] = this.map.getKey(series);\n            } else {\n              throw Error(\"XYChartScrollbar error: Series with id `\" + series + \"` does not exist.\");\n            }\n          }\n        }\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return XYChartScrollbar;\n}(Scrollbar);\n\nexport { XYChartScrollbar };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"XYChartScrollbar\"] = XYChartScrollbar; //# sourceMappingURL=XYChartScrollbar.js.map","map":null,"metadata":{},"sourceType":"module"}