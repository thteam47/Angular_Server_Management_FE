{"ast":null,"code":"/**\r\n * Legend-related functionality.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Component } from \"../core/Component\";\nimport { DataItem } from \"../core/DataItem\";\nimport { ListTemplate, ListDisposer } from \"../core/utils/List\";\nimport { RoundedRectangle } from \"../core/elements/RoundedRectangle\";\nimport { Container } from \"../core/Container\";\nimport { Label } from \"../core/elements/Label\";\nimport { keyboard } from \"../core/utils/Keyboard\";\nimport { registry } from \"../core/Registry\";\nimport { getInteraction } from \"../core/interaction/Interaction\";\nimport { percent, Percent } from \"../core/utils/Percent\";\nimport { InterfaceColorSet } from \"../core/utils/InterfaceColorSet\";\nimport * as $utils from \"../core/utils/Utils\";\nimport * as $type from \"../core/utils/Type\";\nimport * as $math from \"../core/utils/Math\";\nimport { Sprite } from \"../core/Sprite\";\nimport { Disposer } from \"../core/utils/Disposer\";\nimport { MouseCursorStyle } from \"../core/interaction/Mouse\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../core/utils/Responsive\";\nimport { Scrollbar } from \"../core/elements/Scrollbar\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[Legend]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar LegendDataItem = function (_super) {\n  __extends(LegendDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function LegendDataItem() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * @ignore\r\n     */\n\n\n    _this.childrenCreated = false;\n    _this.className = \"LegendDataItem\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(LegendDataItem.prototype, \"label\", {\n    /**\r\n     * A legend item's [[Label]] element.\r\n     *\r\n     * @return Label\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._label) {\n        var label_1 = this.component.labels.create();\n        this._label = label_1;\n        this.addSprite(label_1);\n\n        this._disposers.push(label_1);\n\n        label_1.parent = this.itemContainer;\n\n        this._disposers.push(new Disposer(function () {\n          if ($type.hasValue(_this.component)) {\n            _this.component.labels.removeValue(label_1);\n          }\n        }));\n      }\n\n      return this._label;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LegendDataItem.prototype, \"color\", {\n    /**\r\n     * @return Main color\r\n     */\n    get: function () {\n      return this.properties.color;\n    },\n\n    /**\r\n     * Main color of legend data item.\r\n     *\r\n     * This is set by the target element this legend item represents, like\r\n     * a Series or a Slice.\r\n     *\r\n     * It can be used to derive a color in legend's sub-items, like label:\r\n     *\r\n     * ```TypeScript\r\n     * chart.legend.labels.template.text = \"[{color}]{name}[/]\";\r\n     * ```\r\n     * ```JavaScript\r\n     * chart.legend.labels.template.text = \"[{color}]{name}[/]\";\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"legend\": {\r\n     *     // ...\r\n     *     \"labels\": {\r\n     *       \"text\": \"[{color}]{name}[/]\"\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/#Legend_labels} For more information about configuring legend labels.\r\n     * @param value  Main color\r\n     */\n    set: function (value) {\n      this.setProperty(\"color\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LegendDataItem.prototype, \"valueLabel\", {\n    /**\r\n     * A legend item's [[Label]] element for \"value label\".\r\n     *\r\n     * @return Label\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._valueLabel) {\n        var valueLabel_1 = this.component.valueLabels.create();\n        this._valueLabel = valueLabel_1;\n        this.addSprite(valueLabel_1);\n\n        this._disposers.push(valueLabel_1);\n\n        valueLabel_1.parent = this.itemContainer;\n\n        this._disposers.push(new Disposer(function () {\n          if ($type.hasValue(_this.component)) {\n            _this.component.valueLabels.removeValue(valueLabel_1);\n          }\n        }));\n      }\n\n      return this._valueLabel;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LegendDataItem.prototype, \"itemContainer\", {\n    /**\r\n     * A reference to the main [[Container]] that holds legend item's elements:\r\n     * marker and labels.\r\n     *\r\n     * @return Item container\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._itemContainer) {\n        var component_1 = this.component;\n        var itemContainer_1 = component_1.itemContainers.create();\n        itemContainer_1.parent = component_1;\n        this._itemContainer = itemContainer_1;\n        this.addSprite(itemContainer_1);\n\n        this._disposers.push(itemContainer_1); // Add click/tap event to toggle item\n\n\n        if (itemContainer_1.togglable) {\n          itemContainer_1.events.on(\"toggled\", function (ev) {\n            component_1.toggleDataItem(ev.target.dataItem);\n          }, undefined, false);\n        } // Add focus event so that we can track which object is currently in focus\n        // for keyboard toggling\n\n\n        if (itemContainer_1.focusable) {\n          itemContainer_1.events.on(\"hit\", function (ev) {\n            // We need this here in order to reset focused item when it is clicked\n            // normally so that it is not toggled by ENTER afterwards\n            component_1.focusedItem = undefined;\n          }, undefined, false);\n          itemContainer_1.events.on(\"focus\", function (ev) {\n            component_1.focusedItem = ev.target.dataItem;\n          }, undefined, false);\n          itemContainer_1.events.on(\"blur\", function (ev) {\n            component_1.focusedItem = undefined;\n          }, undefined, false);\n        }\n\n        this._disposers.push(new Disposer(function () {\n          if ($type.hasValue(_this.component)) {\n            _this.component.itemContainers.removeValue(itemContainer_1);\n          }\n        }));\n\n        if (this.dataContext.uidAttr) {\n          itemContainer_1.readerControls = this.dataContext.uidAttr();\n          itemContainer_1.readerLabelledBy = this.dataContext.uidAttr();\n        }\n\n        var sprite = this.dataContext;\n\n        if ((sprite instanceof DataItem || sprite instanceof Sprite) && !sprite.isDisposed()) {\n          var visibilitychanged = function (ev) {\n            itemContainer_1.readerChecked = ev.visible;\n            itemContainer_1.events.disableType(\"toggled\");\n            itemContainer_1.isActive = !ev.visible;\n            itemContainer_1.events.enableType(\"toggled\");\n          };\n\n          sprite.addDisposer(new Disposer(function () {\n            if (_this.component) {\n              _this.component.dataItems.remove(_this);\n            }\n          }));\n\n          if (sprite instanceof Sprite) {\n            itemContainer_1.addDisposer(sprite.events.on(\"visibilitychanged\", visibilitychanged, undefined, false));\n            itemContainer_1.addDisposer(sprite.events.on(\"hidden\", function (ev) {\n              itemContainer_1.readerChecked = false;\n              itemContainer_1.events.disableType(\"toggled\");\n              itemContainer_1.isActive = true;\n              itemContainer_1.events.enableType(\"toggled\");\n            }, undefined, false));\n            itemContainer_1.addDisposer(sprite.events.on(\"shown\", function (ev) {\n              itemContainer_1.readerChecked = true;\n              itemContainer_1.events.disableType(\"toggled\");\n              itemContainer_1.isActive = false;\n              itemContainer_1.events.enableType(\"toggled\");\n            }, undefined, false));\n          } else {\n            itemContainer_1.addDisposer(sprite.events.on(\"visibilitychanged\", visibilitychanged, undefined, false));\n          }\n        }\n      }\n\n      return this._itemContainer;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LegendDataItem.prototype, \"marker\", {\n    /**\r\n     * A [[Container]] that holds legend item's marker element.\r\n     *\r\n     * @return Marker\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._marker) {\n        var marker_1 = this.component.markers.create();\n        this._marker = marker_1;\n        marker_1.parent = this.itemContainer;\n        this.addSprite(marker_1);\n\n        this._disposers.push(marker_1);\n\n        this._disposers.push(new Disposer(function () {\n          if ($type.hasValue(_this.component)) {\n            _this.component.markers.removeValue(marker_1);\n          }\n        }));\n      }\n\n      return this._marker;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LegendDataItem;\n}(DataItem);\n\nexport { LegendDataItem };\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a class that carries legend settings.\r\n *\r\n * A legend might change its settings dynamically. Legend can also be shared\r\n * by several elements, requiring different settings.\r\n *\r\n * Having legend's settings in a separate object is a good way to \"hot swap\"\r\n * a set of settings for the legend.\r\n */\n\nvar LegendSettings = function () {\n  function LegendSettings() {\n    /**\r\n     * Should marker be created for each legend item.\r\n     */\n    this.createMarker = true;\n  }\n\n  return LegendSettings;\n}();\n\nexport { LegendSettings };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * [[Legend]] class is used to create legend for the chart.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/} for Legend documentation\r\n * @see {@link ILegendEvents} for a list of available events\r\n * @see {@link ILegendAdapters} for a list of available Adapters\r\n */\n\nvar Legend = function (_super) {\n  __extends(Legend, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Legend() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"Legend\"; // Set defaults\n\n    _this.layout = \"grid\";\n\n    _this.setPropertyValue(\"useDefaultMarker\", false);\n\n    _this.setPropertyValue(\"scrollable\", false);\n\n    _this.setPropertyValue(\"contentAlign\", \"center\"); // Create a template container and list for legend items\n\n\n    var itemContainer = new Container();\n    itemContainer.applyOnClones = true;\n    itemContainer.padding(8, 0, 8, 0);\n    itemContainer.margin(0, 10, 0, 10);\n    itemContainer.layout = \"horizontal\";\n    itemContainer.clickable = true;\n    itemContainer.focusable = true;\n    itemContainer.role = \"switch\";\n    itemContainer.togglable = true;\n    itemContainer.cursorOverStyle = MouseCursorStyle.pointer;\n    itemContainer.background.fillOpacity = 0; // creates hit area\n    // Create container list using item template we just created\n\n    _this.itemContainers = new ListTemplate(itemContainer);\n\n    _this._disposers.push(new ListDisposer(_this.itemContainers));\n\n    _this._disposers.push(_this.itemContainers.template); // Set up global keyboard events for toggling elements\n\n\n    _this._disposers.push(getInteraction().body.events.on(\"keyup\", function (ev) {\n      if (keyboard.isKey(ev.event, \"enter\") && _this.focusedItem) {\n        var focusedItem = _this.focusedItem;\n        var target = focusedItem.itemContainer;\n\n        if (target.togglable) {\n          _this.toggleDataItem(focusedItem);\n        } else if (target.clickable && target.events.isEnabled(\"hit\")) {\n          target.dispatchImmediately(\"hit\", {\n            event: ev\n          }); // We need this here because \"hit\" event resets `this.focusedItem`\n          // And we need it here\n\n          _this.focusedItem = focusedItem;\n        }\n      }\n    }, _this));\n\n    var interfaceColors = new InterfaceColorSet(); // Create a template container and list for the a marker\n\n    var marker = new Container();\n    marker.width = 23;\n    marker.height = 23;\n    marker.interactionsEnabled = false;\n    marker.applyOnClones = true;\n    marker.setStateOnChildren = true;\n    marker.background.fillOpacity = 0;\n    marker.background.strokeOpacity = 0;\n    marker.propertyFields.fill = \"fill\";\n    marker.valign = \"middle\";\n    var disabledColor = interfaceColors.getFor(\"disabledBackground\");\n    marker.events.on(\"childadded\", function (event) {\n      var child = event.newValue;\n      var activeState = child.states.create(\"active\");\n      activeState.properties.stroke = disabledColor;\n      activeState.properties.fill = disabledColor;\n    });\n    _this.markers = new ListTemplate(marker);\n\n    _this._disposers.push(new ListDisposer(_this.markers));\n\n    _this._disposers.push(_this.markers.template); // Create a legend background element\n\n\n    var rectangle = marker.createChild(RoundedRectangle);\n    rectangle.width = percent(100);\n    rectangle.height = percent(100);\n    rectangle.applyOnClones = true;\n    rectangle.propertyFields.fill = \"fill\"; //othrwise old edge doesn't like as the same pattern is set both on parent and child https://codepen.io/team/amcharts/pen/72d7a98f3fb811d3118795220ff63182\n\n    rectangle.strokeOpacity = 0; // Create a template container and list for item labels\n\n    var label = new Label();\n    label.text = \"{name}\";\n    label.margin(0, 5, 0, 5);\n    label.valign = \"middle\";\n    label.applyOnClones = true;\n    label.states.create(\"active\").properties.fill = interfaceColors.getFor(\"disabledBackground\");\n    _this.labels = new ListTemplate(label);\n\n    _this._disposers.push(new ListDisposer(_this.labels));\n\n    _this._disposers.push(_this.labels.template);\n\n    label.interactionsEnabled = false;\n    label.truncate = true;\n    label.fullWords = false; // Create a template container and list for item value labels\n\n    var valueLabel = new Label();\n    valueLabel.margin(0, 5, 0, 0);\n    valueLabel.valign = \"middle\";\n    valueLabel.width = 50; // to avoid rearranging legend entries when value changes.\n\n    valueLabel.align = \"right\";\n    valueLabel.textAlign = \"end\";\n    valueLabel.applyOnClones = true;\n    valueLabel.states.create(\"active\").properties.fill = interfaceColors.getFor(\"disabledBackground\");\n    valueLabel.interactionsEnabled = false;\n    _this.valueLabels = new ListTemplate(valueLabel);\n\n    _this._disposers.push(new ListDisposer(_this.valueLabels));\n\n    _this._disposers.push(_this.valueLabels.template);\n\n    _this.position = \"bottom\"; // don't use setPropertyValue here!\n    // Create a state for disabled legend items\n\n    itemContainer.states.create(\"active\");\n    itemContainer.setStateOnChildren = true; // Apply accessibility settings\n\n    _this.role = \"group\";\n\n    _this.events.on(\"layoutvalidated\", _this.handleScrollbar, _this, false);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  Legend.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Legend\");\n    }\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  Legend.prototype.createDataItem = function () {\n    return new LegendDataItem();\n  };\n  /**\r\n   * [validateDataElements description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Legend.prototype.validateDataElements = function () {\n    if (this.scrollbar) {\n      this.scrollbar.start = 0;\n      this.scrollbar.end = 1;\n    }\n\n    _super.prototype.validateDataElements.call(this);\n  };\n  /**\r\n   * [validateDataElement description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem Data item\r\n   * @todo Description\r\n   * @todo Figure out how to update appearance of legend item without losing focus\r\n   * @todo Update legend marker appearance as apperance of related series changes\r\n   */\n\n\n  Legend.prototype.validateDataElement = function (dataItem) {\n    _super.prototype.validateDataElement.call(this, dataItem); // Get data item (legend item's) container\n\n\n    var container = dataItem.itemContainer;\n    var marker = dataItem.marker;\n    $utils.used(dataItem.label);\n    var valueLabel = dataItem.valueLabel; // Set parent and update current state\n\n    container.readerChecked = dataItem.dataContext.visible; // Tell series its legend data item\n\n    dataItem.dataContext.legendDataItem = dataItem;\n    var tempMaxWidth = dataItem.label.maxWidth;\n\n    if (!(dataItem.label.width instanceof Percent)) {\n      dataItem.label.width = undefined;\n    }\n\n    if (tempMaxWidth > 0) {\n      dataItem.label.maxWidth = tempMaxWidth;\n    }\n\n    if (valueLabel.align == \"right\") {\n      valueLabel.width = undefined;\n    }\n\n    var legendSettings = dataItem.dataContext.legendSettings; // If we are not using default markers, create a unique legend marker based\n    // on the data item type\n\n    var dataContext = dataItem.dataContext;\n\n    if (dataContext.createLegendMarker && (!this.useDefaultMarker || !(dataContext instanceof Sprite))) {\n      if (!dataItem.childrenCreated) {\n        dataContext.createLegendMarker(marker);\n        dataItem.childrenCreated = true;\n      }\n    } else {\n      this.markers.template.propertyFields.fill = undefined;\n    }\n\n    if (dataContext.updateLegendValue) {\n      dataContext.updateLegendValue(); // this solves issue with external legend, as legend is created after chart updates legend values\n    }\n\n    if (dataContext.component && dataContext.component.updateLegendValue) {\n      dataContext.component.updateLegendValue(dataContext);\n    }\n\n    if (valueLabel.invalid) {\n      valueLabel.validate();\n    }\n\n    if (valueLabel.text == \"\" || valueLabel.text == undefined) {\n      valueLabel.__disabled = true;\n    } else {\n      valueLabel.__disabled = false;\n    }\n\n    if (legendSettings && (legendSettings.itemValueText != undefined || legendSettings.valueText != undefined)) {\n      valueLabel.__disabled = false;\n    }\n\n    var visible = dataItem.dataContext.visible;\n\n    if (visible === undefined) {\n      visible = true;\n    }\n\n    visible = $type.toBoolean(visible);\n    dataItem.dataContext.visible = visible;\n    container.events.disableType(\"toggled\");\n    container.isActive = !visible;\n\n    if (container.isActive) {\n      container.setState(\"active\", 0);\n    } else {\n      container.setState(\"default\", 0);\n    }\n\n    container.events.enableType(\"toggled\");\n  };\n\n  Legend.prototype.afterDraw = function () {\n    var _this = this;\n\n    var maxWidth = this.getPropertyValue(\"maxWidth\");\n    var maxLabelWidth = 0;\n    this.labels.each(function (label) {\n      if (label.invalid) {\n        label.maxWidth = undefined;\n        label.validate();\n      }\n\n      if (label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight > maxLabelWidth) {\n        maxLabelWidth = label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight;\n      }\n    });\n    var maxValueLabelWidth = 0;\n    this.valueLabels.each(function (label) {\n      if (label.invalid) {\n        label.validate();\n      }\n\n      if (label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight > maxValueLabelWidth) {\n        maxValueLabelWidth = label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight;\n      }\n    });\n    var maxMarkerWidth = 0;\n    this.markers.each(function (marker) {\n      if (marker.invalid) {\n        marker.validate();\n      }\n\n      if (marker.measuredWidth + marker.pixelMarginLeft + marker.pixelMarginRight > maxMarkerWidth) {\n        maxMarkerWidth = marker.measuredWidth + marker.pixelMarginLeft + marker.pixelMarginRight;\n      }\n    });\n    var itemContainer = this.itemContainers.template;\n    var margin = itemContainer.pixelMarginRight + itemContainer.pixelMarginLeft;\n    var maxAdjustedLabelWidth;\n    var trueMaxWidth = maxLabelWidth + maxValueLabelWidth + maxMarkerWidth;\n\n    if (!$type.isNumber(maxWidth)) {\n      maxAdjustedLabelWidth = maxLabelWidth;\n    } else {\n      maxWidth = maxWidth - margin;\n\n      if (maxWidth > trueMaxWidth) {\n        maxWidth = trueMaxWidth;\n      }\n\n      maxAdjustedLabelWidth = maxWidth - maxMarkerWidth - maxValueLabelWidth;\n    }\n\n    this.labels.each(function (label) {\n      if (_this.valueLabels.template.align == \"right\" || label.measuredWidth > maxAdjustedLabelWidth) {\n        if (!(label.width instanceof Percent)) {\n          label.width = Math.min(label.maxWidth, maxAdjustedLabelWidth - label.pixelMarginLeft - label.pixelMarginRight);\n          label.maxWidth = label.width;\n        }\n      }\n    });\n\n    if (this.valueLabels.template.align == \"right\") {\n      this.valueLabels.each(function (valueLabel) {\n        valueLabel.width = maxValueLabelWidth - valueLabel.pixelMarginRight - valueLabel.pixelMarginLeft;\n      });\n    }\n\n    _super.prototype.afterDraw.call(this);\n  };\n\n  Legend.prototype.handleScrollbar = function () {\n    var scrollbar = this.scrollbar;\n\n    if (this.scrollable && scrollbar) {\n      scrollbar.height = this.measuredHeight;\n      scrollbar.x = this.measuredWidth - scrollbar.pixelWidth - scrollbar.pixelMarginLeft;\n\n      if (this.contentHeight > this.measuredHeight) {\n        scrollbar.visible = true;\n        scrollbar.thumb.height = scrollbar.height * this.measuredHeight / this.contentHeight;\n        this.paddingRight = scrollbar.pixelWidth + scrollbar.pixelMarginLeft + +scrollbar.pixelMarginRight;\n      } else {\n        scrollbar.visible = false;\n      }\n\n      this.updateMasks();\n    }\n  };\n\n  Object.defineProperty(Legend.prototype, \"position\", {\n    /**\r\n     * @return Position\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"position\");\n    },\n\n    /**\r\n     * Position of the legend.\r\n     *\r\n     * Options: \"left\", \"right\", \"top\", \"bottom\" (default), or \"absolute\".\r\n     *\r\n     * IMPORTANT: [[MapChart]] will ignore this setting, as it is using different\r\n     * layout structure than other charts.\r\n     *\r\n     * To position legend in [[MapChart]] set legend's `align` (`\"left\"` or\r\n     * `\"right\"`) and `valign` (`\"top\"` or `\"bottom\"`) properties instead.\r\n     *\r\n     * @default \"bottom\"\r\n     * @param value  Position\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"position\", value)) {\n        if (value == \"left\" || value == \"right\") {\n          this.margin(10, 5, 10, 10);\n          this.valign = \"middle\";\n          this.contentAlign = \"none\";\n          this.valueLabels.template.align = \"right\";\n\n          if (!$type.isNumber(this.maxColumns)) {\n            this.maxColumns = 1;\n          }\n\n          this.width = undefined;\n          this.maxWidth = 220;\n        } else {\n          this.maxColumns = undefined;\n          this.width = percent(100);\n          this.valueLabels.template.align = \"left\";\n        }\n\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Legend.prototype, \"useDefaultMarker\", {\n    /**\r\n     * @return Use default marker?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"useDefaultMarker\");\n    },\n\n    /**\r\n     * Should legend try to mirror the look of the related item when building\r\n     * the marker for legend item?\r\n     *\r\n     * If set to `false` it will try to make the marker look like its related\r\n     * item.\r\n     *\r\n     * E.g. if an item is for a Line Series, it will display a line of the\r\n     * same thickness, color, and will use the same bullets if series have them.\r\n     *\r\n     * If set to `true`, all markers will be shown as squares, regardless of te\r\n     * series type.\r\n     *\r\n     * @default false\r\n     * @param value Use default marker?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"useDefaultMarker\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Legend.prototype, \"scrollable\", {\n    /**\r\n     * @return Legend Scrollable?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"scrollable\");\n    },\n\n    /**\r\n     * If set to `true` the Legend will display a scrollbar if its contents do\r\n     * not fit into its `maxHeight`.\r\n     *\r\n     * Please note that `maxHeight` is automatically set for Legend when its\r\n     * `position` is set to `\"left\"` or `\"right\"`.\r\n     *\r\n     * @default false\r\n     * @since 4.8.0\r\n     * @param  value  Legend Scrollable?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"scrollable\", value, true)) {\n        if (value) {\n          var scrollbar = this.createChild(Scrollbar);\n          this.scrollbar = scrollbar;\n          scrollbar.isMeasured = false;\n          scrollbar.orientation = \"vertical\";\n          scrollbar.endGrip.__disabled = true;\n          scrollbar.startGrip.__disabled = true;\n          scrollbar.visible = false;\n          scrollbar.marginLeft = 5;\n          this._mouseWheelDisposer = this.events.on(\"wheel\", this.handleWheel, this, false);\n\n          this._disposers.push(this._mouseWheelDisposer);\n\n          this._disposers.push(scrollbar.events.on(\"rangechanged\", this.updateMasks, this, false));\n        } else {\n          if (this._mouseWheelDisposer) {\n            this._mouseWheelDisposer.dispose();\n\n            if (this.scrollbar) {\n              this.scrollbar.dispose();\n              this.scrollbar = undefined;\n            }\n          }\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Handles mouse wheel scrolling of legend.\r\n   *\r\n   * @param  event  Event\r\n   */\n\n  Legend.prototype.handleWheel = function (event) {\n    var shift = event.shift.y;\n    var scrollbar = this.scrollbar;\n\n    if (scrollbar) {\n      var ds = shift / 1000 * this.measuredHeight / this.contentHeight;\n      var delta = scrollbar.end - scrollbar.start;\n\n      if (shift > 0) {\n        scrollbar.start = $math.max(0, scrollbar.start - ds);\n        scrollbar.end = scrollbar.start + delta;\n      } else {\n        scrollbar.end = $math.min(1, scrollbar.end - ds);\n        scrollbar.start = scrollbar.end - delta;\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Legend.prototype.updateMasks = function () {\n    var _this = this;\n\n    if (this.scrollbar) {\n      this.itemContainers.each(function (itemContainer) {\n        itemContainer.dy = -_this.scrollbar.thumb.pixelY * _this.contentHeight / _this.measuredHeight;\n        itemContainer.maskRectangle = {\n          x: 0,\n          y: -itemContainer.dy,\n          width: _this.measuredWidth,\n          height: _this.measuredHeight\n        };\n      });\n    }\n  };\n  /**\r\n   * Toggles a legend item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param item Legend item\r\n   * @todo Maybe do it with togglable instead\r\n   */\n\n\n  Legend.prototype.toggleDataItem = function (item) {\n    var dataContext = item.dataContext;\n\n    if (!dataContext.visible || dataContext.isHiding || dataContext instanceof Sprite && dataContext.isHidden) {\n      item.color = item.colorOrig;\n      item.itemContainer.isActive = false;\n\n      if (dataContext.hidden === true) {\n        dataContext.hidden = false;\n      }\n\n      if (dataContext.show) {\n        dataContext.show();\n      } else {\n        dataContext.visible = true;\n      }\n\n      this.svgContainer.readerAlert(this.language.translate(\"%1 shown\", this.language.locale, item.label.readerTitle));\n    } else {\n      item.itemContainer.isActive = true;\n\n      if (dataContext.hide) {\n        dataContext.hide();\n      } else {\n        dataContext.visible = false;\n      }\n\n      this.svgContainer.readerAlert(this.language.translate(\"%1 hidden\", this.language.locale, item.label.readerTitle));\n      item.color = new InterfaceColorSet().getFor(\"disabledBackground\");\n    }\n  };\n\n  Object.defineProperty(Legend.prototype, \"preloader\", {\n    /**\r\n     * Override preloader method so that legend does not accidentally show its\r\n     * own preloader.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Always `undefined`\r\n     */\n    get: function () {\n      return;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [handleDataItemPropertyChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Legend.prototype.handleDataItemPropertyChange = function (dataItem, name) {\n    dataItem.valueLabel.invalidate();\n    dataItem.label.invalidate();\n  };\n\n  return Legend;\n}(Component);\n\nexport { Legend };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Legend\"] = Legend;\n/**\r\n * Add default responsive rules\r\n */\n\n/**\r\n * Move legend to below the chart if chart is narrow\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.widthXS,\n  state: function (target, stateId) {\n    if (target instanceof Legend && (target.position == \"left\" || target.position == \"right\")) {\n      var state = target.states.create(stateId);\n      state.properties.position = \"bottom\";\n      return state;\n    }\n\n    return null;\n  }\n});\n/**\r\n * Move legend to the right if chart is very short\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXS,\n  state: function (target, stateId) {\n    if (target instanceof Legend && (target.position == \"top\" || target.position == \"bottom\")) {\n      var state = target.states.create(stateId);\n      state.properties.position = \"right\";\n      return state;\n    }\n\n    return null;\n  }\n});\n/**\r\n * Disable legend altogether on small charts\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.isXS,\n  state: function (target, stateId) {\n    if (target instanceof Legend) {\n      var state = target.states.create(stateId);\n      state.properties.disabled = true;\n      return state;\n    }\n\n    return null;\n  }\n}); //# sourceMappingURL=Legend.js.map","map":null,"metadata":{},"sourceType":"module"}