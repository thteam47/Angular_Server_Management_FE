{"ast":null,"code":"/**\r\n * This module contains PatternSet object definition\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../Base\";\nimport { Color } from \"./Color\";\nimport { InterfaceColorSet } from \"./InterfaceColorSet\";\nimport { LinePattern } from \"../rendering/fills/LinePattern\";\nimport { RectPattern } from \"../rendering/fills/RectPattern\";\nimport { CirclePattern } from \"../rendering/fills/CirclePattern\";\nimport { registry } from \"../Registry\";\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines an interable list of distinctive patterns that can be used in\r\n * conjunction to colors to generate various fill patterns.\r\n *\r\n * @important\r\n * @since 4.7.5\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/colors/} for color-related info\r\n */\n\nvar PatternSet = function (_super) {\n  __extends(PatternSet, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function PatternSet() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Holds the list of the colors in this set. (preset or auto-generated)\r\n     */\n\n\n    _this._list = [];\n    /**\r\n     * Current step.\r\n     */\n\n    _this._currentStep = 0;\n    /**\r\n     * If set to non-zero value, the PatternSet will start iterating patterns from\r\n     * that particular index, not the first pattern in the list.\r\n     */\n\n    _this._startIndex = 0;\n    /**\r\n     * Current pass in cycle. Once all patterns in the list are iterated,\r\n     * iteration restarts from beginning and currentPass is incremented.\r\n     */\n\n    _this._currentPass = 0;\n    /**\r\n     * A base color. If there are no colors pre-set in the color list, ColorSet\r\n     * will use this color as a base when generating new ones, applying\r\n     * `stepOptions` and `passOptions` to this base color.\r\n     */\n\n    _this.baseColor = new Color({\n      r: 103,\n      g: 183,\n      b: 220\n    });\n    _this.className = \"PatternSet\"; // Set base color to be used for pattern elements\n\n    var interfaceColors = new InterfaceColorSet(); // Set default patterns\n\n    _this.list = [_this.getLinePattern(1000, 45, 1, 6), _this.getRectPattern(10, 0, 4), _this.getLinePattern(1000, -45, 1, 6), _this.getCirclePattern(11, 2, true), _this.getLinePattern(6, 90, 1), _this.getRectPattern(12, 45, 6, true), _this.getLinePattern(6, 0, 1), _this.getRectPattern(7, 0, 4), _this.getLinePattern(1000, 45, 2, 3, \"4,2\"), _this.getCirclePattern(9, 3, false), _this.getLinePattern(1000, -45, 2, 3, \"4,2\"), _this.getRectPattern(10, 45, Math.sqrt(50)), _this.getLinePattern(1000, -45, 2, 1), _this.getRectPattern(10, 0, 9), _this.getLinePattern(1000, 45, 2, 1), _this.getLinePattern(1000, 0, 3, 1), _this.getRectPattern(10, 45, 10), _this.getLinePattern(1000, 90, 3, 1)];\n    _this.baseColor = interfaceColors.getFor(\"stroke\");\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  PatternSet.prototype.getLinePattern = function (size, rotation, thickness, gap, strokeDashArray) {\n    var pattern = new LinePattern();\n    pattern.width = size;\n    pattern.height = size;\n    pattern.stroke = this.baseColor;\n    pattern.gap = gap;\n    pattern.strokeDasharray = strokeDashArray;\n    pattern.strokeWidth = thickness;\n    pattern.rotation = rotation;\n    return pattern;\n  };\n\n  PatternSet.prototype.getRectPattern = function (size, rotation, thickness, outline) {\n    var pattern = new RectPattern();\n    pattern.width = size;\n    pattern.height = size;\n    pattern.rectWidth = thickness;\n    pattern.rectHeight = thickness;\n\n    if (outline) {\n      pattern.stroke = this.baseColor;\n      pattern.strokeWidth = 1;\n      pattern.fillOpacity = 0;\n    } else {\n      pattern.fill = this.baseColor;\n      pattern.strokeWidth = 0;\n    }\n\n    if (rotation != 0) {\n      pattern.shapeRendering = \"auto\";\n    }\n\n    pattern.rotation = rotation;\n    return pattern;\n  };\n\n  PatternSet.prototype.getCirclePattern = function (size, radius, outline) {\n    var pattern = new CirclePattern();\n    pattern.width = size;\n    pattern.height = size;\n    pattern.shapeRendering = \"auto\";\n    pattern.radius = radius;\n\n    if (outline) {\n      pattern.stroke = this.baseColor;\n      pattern.strokeWidth = 1;\n      pattern.fillOpacity = 0;\n    } else {\n      pattern.fill = this.baseColor;\n      pattern.strokeWidth = 0;\n    }\n\n    return pattern;\n  };\n\n  Object.defineProperty(PatternSet.prototype, \"list\", {\n    /**\r\n     * @return Pattern list\r\n     */\n    get: function () {\n      return this._list;\n    },\n\n    /**\r\n     * List of pre-defined patterns to be used in set.\r\n     *\r\n     * @param value Pattern list\r\n     */\n    set: function (value) {\n      this._list = value;\n      this.reset();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns the next pattern in list.\r\n   *\r\n   * @return Pattern\r\n   */\n\n  PatternSet.prototype.next = function () {\n    var pattern = this.getIndex(this.currentStep);\n    this._currentStep++;\n    return pattern;\n  };\n  /**\r\n   * Returns a color at specific index in the list.\r\n   *\r\n   * @param  i  Index\r\n   * @return Pattern\r\n   */\n\n\n  PatternSet.prototype.getIndex = function (i) {\n    var pattern;\n\n    while (this.list.length <= i) {\n      this.generatePatterns();\n    }\n\n    pattern = this.list[i];\n    return pattern.clone();\n  };\n  /**\r\n   * Generates a new set of patterns.\r\n   */\n\n\n  PatternSet.prototype.generatePatterns = function () {\n    var count = this.list.length / (this._currentPass + 1);\n    this._currentPass++;\n\n    for (var i = 0; i < count; i++) {\n      this.list.push(this.list[i].clone());\n    }\n  };\n  /**\r\n   * Resets internal iterator.\r\n   *\r\n   * Calling `next()` after this will return the very first color in the color\r\n   * list, even if it was already returned before.\r\n   */\n\n\n  PatternSet.prototype.reset = function () {\n    this._currentStep = this._startIndex;\n  };\n\n  Object.defineProperty(PatternSet.prototype, \"currentStep\", {\n    /**\r\n     * @return Step\r\n     */\n    get: function () {\n      return this._currentStep;\n    },\n\n    /**\r\n     * Sets current color iteration. You can use this property to skip some\r\n     * colors from iteration. E.g. setting it to `10` will skip first ten\r\n     * colors.\r\n     *\r\n     * Please note that the number is zero-based.\r\n     *\r\n     * @param value  Step\r\n     */\n    set: function (value) {\n      this._currentStep = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PatternSet.prototype, \"startIndex\", {\n    /**\r\n     * @return Index\r\n     */\n    get: function () {\n      return this._startIndex;\n    },\n\n    /**\r\n     * If set to non-zero value, the ColorSet will start iterating colors from\r\n     * that particular index, not the first color in the list.\r\n     *\r\n     * @default 0\r\n     * @param  value  Index\r\n     */\n    set: function (value) {\n      this._startIndex = value;\n      this.reset();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  PatternSet.prototype.processConfig = function (config) {\n    // if (config) {\n    // \t// Set up axis ranges\n    // \tif ($type.hasValue(config.list) && $type.isArray(config.list)) {\n    // \t\tfor (let i = 0, len = config.list.length; i < len; i++) {\n    // \t\t\tif (!(config.list[i] instanceof Color)) {\n    // \t\t\t\tconfig.list[i] = color(config.list[i]);\n    // \t\t\t}\n    // \t\t}\n    // \t}\n    // }\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return PatternSet;\n}(BaseObject);\n\nexport { PatternSet };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"PatternSet\"] = PatternSet; //# sourceMappingURL=PatternSet.js.map","map":null,"metadata":{},"sourceType":"module"}