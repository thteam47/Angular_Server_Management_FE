{"ast":null,"code":"import { Injectable, ɵɵdefineInjectable, EventEmitter, Component, Input, Output, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { Terminal } from 'xterm';\nimport { FitAddon } from 'xterm-addon-fit';\nimport { Subject, combineLatest } from 'rxjs';\nimport { ResizableModule } from 'angular-resizable-element';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/ng-terminal.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'angular-resizable-element';\nimport * as ɵngcc2 from '@angular/common';\nconst _c0 = [\"terminal\"];\n\nconst _c1 = function () {\n  return {\n    bottom: true,\n    right: true\n  };\n};\n\nconst _c2 = function () {\n  return {\n    bottom: false,\n    right: false\n  };\n};\n\nclass NgTerminalService {\n  constructor() {}\n\n}\n\nNgTerminalService.ɵfac = function NgTerminalService_Factory(t) {\n  return new (t || NgTerminalService)();\n};\n\nNgTerminalService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: NgTerminalService,\n  factory: NgTerminalService.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\n/** @nocollapse */\nNgTerminalService.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function NgTerminalService_Factory() {\n    return new NgTerminalService();\n  },\n  token: NgTerminalService,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/ng-terminal.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet NgTerminalComponent = /*#__PURE__*/(() => {\n  class NgTerminalComponent {\n    constructor() {\n      this.keyInputSubject = new Subject();\n      this.keyEventSubject = new Subject();\n      this.termSnippetSubject = new Subject();\n      this.afterViewInitSubject = new Subject();\n      this.h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n      this.displayOption = {};\n      this.terminalStyle = {};\n      this.keyInputEmitter = new EventEmitter();\n      this.keyEventEmitter = new EventEmitter();\n      this.termSnippetSubscription = combineLatest(this.termSnippetSubject, this.afterViewInitSubject).subscribe(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ([snippet]) => {\n        snippet();\n      });\n    }\n    /**\n     * @param {?} ds\n     * @return {?}\n     */\n\n\n    set _dataSource(ds) {\n      if (this.dataSourceSubscription != null) {\n        this.dataSourceSubscription.unsubscribe();\n      }\n\n      this.dataSource = ds;\n      this.dataSourceSubscription = this.dataSource.subscribe(\n      /**\n      * @param {?} data\n      * @return {?}\n      */\n      data => {\n        this.write(data);\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get _dataSource() {\n      return this.dataSource;\n    }\n    /**\n     * @param {?} opt\n     * @return {?}\n     */\n\n\n    set _displayOption(opt) {\n      this.setDisplayOption(opt);\n    }\n    /**\n     * @param {?} opt\n     * @return {?}\n     */\n\n\n    set _style(opt) {\n      this.setStyle(opt);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    observableSetup() {\n      this.term.onData(\n      /**\n      * @param {?} input\n      * @return {?}\n      */\n      input => {\n        this.keyInputSubject.next(input);\n      });\n      this.term.onKey(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {\n        this.keyEventSubject.next(e);\n      });\n      this.keyInputSubjectSubscription = this.keyInputSubject.subscribe(\n      /**\n      * @param {?} data\n      * @return {?}\n      */\n      data => {\n        this.keyInputEmitter.emit(data);\n      });\n      this.keyEventSubjectSubscription = this.keyEventSubject.subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {\n        this.keyEventEmitter.emit(e);\n      });\n      this.afterViewInitSubject.next();\n    }\n    /**\n     * set block or inline-block to #terminal for fitting client or outer element\n     * @private\n     * @param {?} isBlock\n     * @return {?}\n     */\n\n\n    setTerminalBlock(isBlock) {\n      if (isBlock) this.terminalStyle['display'] = 'block';else this.terminalStyle['display'] = 'inline-block';\n    }\n    /**\n     * set dimensions\n     * @private\n     * @param {?} left\n     * @param {?} top\n     * @param {?} width\n     * @param {?} height\n     * @return {?}\n     */\n\n\n    setTerminalDimensions(left, top, width, height) {\n      this.terminalStyle['left'] = left ? `${left}px` : undefined;\n      this.terminalStyle['top'] = top ? `${top}px` : undefined;\n      this.terminalStyle['width'] = width ? `${width}px` : undefined;\n      this.terminalStyle['height'] = height ? `${height}px` : undefined;\n    }\n    /**\n     * remove dimensions\n     * @private\n     * @return {?}\n     */\n\n\n    removeTerminalDimensions() {\n      this.terminalStyle['left'] = undefined;\n      this.terminalStyle['top'] = undefined;\n      this.terminalStyle['width'] = undefined;\n      this.terminalStyle['height'] = undefined;\n    }\n    /**\n     * @param {?} styleObject\n     * @return {?}\n     */\n\n\n    setStyle(styleObject) {\n      Object.assign(this.terminalStyle, styleObject);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {}\n    /**\n     * When a dimension of div changes, fit a terminal in div.\n     * @return {?}\n     */\n\n\n    ngAfterViewChecked() {\n      /** @type {?} */\n      let dims = this.fitAddon.proposeDimensions();\n\n      if (dims === undefined || isNaN(dims.rows) || dims.rows == Infinity || isNaN(dims.cols) || dims.cols == Infinity) {\n        this.term.resize(10, 10);\n      } else if (!this.displayOption.fixedGrid) {\n        this.fitAddon.fit();\n      } else {\n        this.term.resize(this.displayOption.fixedGrid.cols, this.displayOption.fixedGrid.rows);\n        /** @type {?} */\n\n        let xtermScreen = this.term.element.getElementsByClassName('xterm-screen')[0];\n        /** @type {?} */\n\n        let scrollArea = this.term.element.getElementsByClassName('xterm-scroll-area')[0];\n        /** @type {?} */\n\n        let terminal = this.term.element;\n        /** @type {?} */\n\n        const contentWidth = xtermScreen.clientWidth;\n        /** @type {?} */\n\n        const scrollWidth = terminal.clientWidth - scrollArea.clientWidth;\n        this.setTerminalDimensions(undefined, undefined, contentWidth + scrollWidth, undefined);\n      }\n    }\n    /**\n     * It creates new terminal in #terminal.\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this.fitAddon = new FitAddon();\n      this.term = new Terminal();\n      this.term.open(this.terminalDiv.nativeElement);\n      this.term.loadAddon(this.fitAddon);\n      this.observableSetup();\n    }\n    /**\n     * clean all resources\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.keyInputSubjectSubscription) this.keyInputSubjectSubscription.unsubscribe();\n      if (this.dataSourceSubscription) this.dataSourceSubscription.unsubscribe();\n      if (this.keyEventSubjectSubscription) this.keyEventSubjectSubscription.unsubscribe();\n      if (this.termSnippetSubscription) this.termSnippetSubscription.unsubscribe();\n      if (this.term) this.term.dispose();\n    }\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n\n\n    write(chars) {\n      this.term.write(chars);\n    }\n    /**\n     * @param {?} opt\n     * @return {?}\n     */\n\n\n    setDisplayOption(opt) {\n      if (opt) {\n        if (opt.fixedGrid != null) {\n          console.debug(\"resizable will be ignored.\");\n          this.setTerminalBlock(false);\n          this.removeTerminalDimensions();\n        } else {\n          this.setTerminalBlock(true);\n        }\n\n        this.displayOption = opt;\n      } else console.warn(`A falsy option is not allowed`);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get keyInput() {\n      return this.keyInputSubject;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get keyEventInput() {\n      return this.keyEventSubject;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get underlying() {\n      return this.term;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get isDraggableOnEdgeActivated() {\n      return this.displayOption.activateDraggableOnEdge != undefined && this.displayOption.fixedGrid == undefined;\n    }\n    /**\n     * After user coordinate dimensions of terminal, it's called.\n     * @param {?} left\n     * @param {?} top\n     * @param {?} width\n     * @param {?} height\n     * @return {?}\n     */\n\n\n    onResizeEnd(left, top, width, height) {\n      this.setTerminalDimensions(left, top, width, height);\n    }\n    /**\n     * Before onResizeEnd is called, it valiates dimensions to change.\n     * @return {?}\n     */\n\n\n    validatorFactory() {\n      /** @type {?} */\n      const comp = this;\n      return (\n        /**\n        * @param {?} re\n        * @return {?}\n        */\n        re => {\n          /** @type {?} */\n          const displayOption = comp.displayOption;\n\n          if (displayOption.activateDraggableOnEdge) {\n            /** @type {?} */\n            let left = re.rectangle.left;\n            /** @type {?} */\n\n            let top = re.rectangle.top;\n            /** @type {?} */\n\n            let width = re.rectangle.width;\n            /** @type {?} */\n\n            let height = re.rectangle.height;\n\n            if (width < displayOption.activateDraggableOnEdge.minWidth || height < displayOption.activateDraggableOnEdge.minHeight) {\n              return false;\n            } else return true;\n          }\n        }\n      );\n    }\n\n  }\n\n  NgTerminalComponent.ɵfac = function NgTerminalComponent_Factory(t) {\n    return new (t || NgTerminalComponent)();\n  };\n\n  NgTerminalComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgTerminalComponent,\n    selectors: [[\"ng-terminal\"]],\n    viewQuery: function NgTerminalComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.terminalDiv = _t.first);\n      }\n    },\n    inputs: {\n      _dataSource: [\"dataSource\", \"_dataSource\"],\n      _displayOption: [\"displayOption\", \"_displayOption\"],\n      _style: [\"style\", \"_style\"]\n    },\n    outputs: {\n      keyInputEmitter: \"keyInput\",\n      keyEventEmitter: \"keyEvent\"\n    },\n    decls: 3,\n    vars: 6,\n    consts: [[\"mwlResizable\", \"\", 1, \"terminal-outer\", 3, \"ngStyle\", \"validateResize\", \"enableGhostResize\", \"resizeEdges\", \"resizeEnd\"], [\"terminal\", \"\"]],\n    template: function NgTerminalComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"global-style\");\n        ɵngcc0.ɵɵelementStart(1, \"div\", 0, 1);\n        ɵngcc0.ɵɵlistener(\"resizeEnd\", function NgTerminalComponent_Template_div_resizeEnd_1_listener($event) {\n          return ctx.onResizeEnd($event.rectangle.left, $event.rectangle.top, $event.rectangle.width, $event.rectangle.height);\n        });\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.terminalStyle)(\"validateResize\", ctx.validatorFactory())(\"enableGhostResize\", true)(\"resizeEdges\", ctx.isDraggableOnEdgeActivated ? ɵngcc0.ɵɵpureFunction0(4, _c1) : ɵngcc0.ɵɵpureFunction0(5, _c2));\n      }\n    },\n    directives: function () {\n      return [GlobalStyleComponent, ɵngcc1.ResizableDirective, ɵngcc2.NgStyle];\n    },\n    styles: [\".terminal-outer[_ngcontent-%COMP%]{box-sizing:border-box;height:100%}\"]\n  });\n  /** @nocollapse */\n\n  return NgTerminalComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  NgTerminalComponent.prototype.term;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.fitAddon;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.keyInputSubject;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.keyEventSubject;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.termSnippetSubject;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.afterViewInitSubject;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.keyInputSubjectSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.keyEventSubjectSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.termSnippetSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.h;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.displayOption;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.dataSource;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NgTerminalComponent.prototype.dataSourceSubscription;\n  /** @type {?} */\n\n  NgTerminalComponent.prototype.terminalStyle;\n  /** @type {?} */\n\n  NgTerminalComponent.prototype.keyInputEmitter;\n  /** @type {?} */\n\n  NgTerminalComponent.prototype.keyEventEmitter;\n  /** @type {?} */\n\n  NgTerminalComponent.prototype.terminalDiv;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/global-style/global-style.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet GlobalStyleComponent = /*#__PURE__*/(() => {\n  class GlobalStyleComponent {\n    constructor() {}\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {}\n\n  }\n\n  GlobalStyleComponent.ɵfac = function GlobalStyleComponent_Factory(t) {\n    return new (t || GlobalStyleComponent)();\n  };\n\n  GlobalStyleComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: GlobalStyleComponent,\n    selectors: [[\"global-style\"]],\n    decls: 0,\n    vars: 0,\n    template: function GlobalStyleComponent_Template(rf, ctx) {},\n    styles: [\".xterm{position:relative;-moz-user-select:none;user-select:none;-ms-user-select:none;-webkit-user-select:none;cursor:text}.xterm.focus,.xterm:focus{outline:0}.xterm .xterm-helpers{position:absolute;top:0;z-index:5}.xterm .xterm-helper-textarea{padding:0;border:0;margin:0;position:absolute;opacity:0;left:-9999em;top:0;width:0;height:0;z-index:-5;white-space:nowrap;overflow:hidden;resize:none}.xterm .composition-view{background:#000;color:#fff;display:none;position:absolute;white-space:nowrap;z-index:1}.xterm .composition-view.active{display:block}.xterm .xterm-viewport{background-color:#000;overflow-y:scroll;cursor:default;position:absolute;right:0;left:0;top:0;bottom:0}.xterm .xterm-screen{position:relative}.xterm .xterm-screen canvas{position:absolute;left:0;top:0}.xterm .xterm-scroll-area{visibility:hidden}.xterm-char-measure-element{display:inline-block;visibility:hidden;position:absolute;top:0;left:-9999em;line-height:normal}.xterm.enable-mouse-events{cursor:default}.xterm.xterm-cursor-pointer{cursor:pointer}.xterm.column-select.focus{cursor:crosshair}.xterm .xterm-accessibility,.xterm .xterm-message{position:absolute;left:0;top:0;bottom:0;right:0;z-index:10;color:transparent}.xterm .live-region{position:absolute;left:-9999px;width:1px;height:1px;overflow:hidden}.xterm-dim{opacity:.5}.xterm-underline{text-decoration:underline}.xterm-strikethrough{text-decoration:line-through}\"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return GlobalStyleComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/ng-terminal.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet NgTerminalModule = /*#__PURE__*/(() => {\n  class NgTerminalModule {}\n\n  NgTerminalModule.ɵfac = function NgTerminalModule_Factory(t) {\n    return new (t || NgTerminalModule)();\n  };\n\n  NgTerminalModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgTerminalModule\n  });\n  NgTerminalModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[ResizableModule, CommonModule]]\n  });\n  return NgTerminalModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgTerminalModule, {\n    declarations: function () {\n      return [NgTerminalComponent, GlobalStyleComponent];\n    },\n    imports: function () {\n      return [ResizableModule, CommonModule];\n    },\n    exports: function () {\n      return [NgTerminalComponent];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/functions-using-csi.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n *\n * It is a CSI sequences generator\n * https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Functions-using-CSI-_-ordered-by-the-final-character_s_\n * @type {?}\n */\n\n\nlet CSI = '\\x9b';\n\nclass FunctionsUsingCSI {\n  /**\n   *  CSI Ps \\@  Insert Ps (Blank) Character(s) (default = 1) (ICH).\n   *\n   *\n   * @param {?} count\n   * @return {?}\n   */\n  static insertBlank(count) {\n    return `${CSI}${count}@`;\n  }\n  /**\n       *  CSI Ps SP @ */\n\n  /**\n   *  CSI Ps A  Cursor Up Ps Times (default = 1) (CUU).\n   * \\x9b3A\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static cursorUp(count) {\n    return `${CSI}${count}A`;\n  }\n  /**\n       *  CSI Ps SP A */\n\n  /**\n   *  CSI Ps B  Cursor Down Ps Times (default = 1) (CUD).\n   * \\x9b3B\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static cursorDown(count) {\n    return `${CSI}${count}B`;\n  }\n  /**\n   *  CSI Ps C  Cursor Forward Ps Times (default = 1) (CUF).\n   * \\x9b3C\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static cursorForward(count) {\n    return `${CSI}${count}C`;\n  }\n  /**\n   *  CSI Ps D  Cursor Backward Ps Times (default = 1) (CUB).\n   * \\x9b3D\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static cursorBackward(count) {\n    return `${CSI}${count}D`;\n  }\n  /**\n   *  CSI Ps E  Cursor Next Line Ps Times (default = 1) (CNL).\n   * \\x9b3E\n   *\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static cursorNextLine(count) {\n    return `${CSI}${count}E`;\n  }\n  /**\n   *  CSI Ps F  Cursor Preceding Line Ps Times (default = 1) (CPL).\n   * \\x9b3F\n   *\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static cursorPrecedingLine(count) {\n    return `${CSI}${count}F`;\n  }\n  /**\n   *  CSI Ps G  Cursor Character Absolute  [column] (default = [row,1]) (CHA).\n   *  \\x9b9G\n   *\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static cursorColumn(count) {\n    return `${CSI}${count}G`;\n  }\n  /**\n   *  CSI Ps ; Ps H  Cursor Position [row;column] (default = [1,1]) (CUP).\n   * \\x9b2;2H\n   *\n   * @param {?} row\n   * @param {?} col\n   * @return {?}\n   */\n\n\n  static cursorPosition(row, col) {\n    return `${CSI}${row};${col}H`;\n  }\n  /**\n       *  CSI Ps I  Cursor Forward Tabulation Ps tab stops (default = 1) (CHT). */\n\n  /**\n   *  CSI Ps J  Erase in Display (ED), VT100.\n   *      Ps = 0  -> Erase Below (default).\n   *      Ps = 1  -> Erase Above.\n   *      Ps = 2  -> Erase All.\n   *      Ps = 3  -> Erase Saved Lines (xterm).\n   * \\x9b2J\n   *\n   * @param {?} category\n   * @return {?}\n   */\n\n\n  static eraseInDisplay(category) {\n    return `${CSI}${category}J`;\n  }\n  /**\n   *  CSI ? Ps J\n   *  Erase in Display (DECSED), VT220.\n   *    Ps = 0  -> Selective Erase Below (default).\n   *    Ps = 1  -> Selective Erase Above.\n   *    Ps = 2  -> Selective Erase All.\n   *    Ps = 3  -> Selective Erase Saved Lines (xterm).\n   * \\x9b?2J\n   *\n   * @param {?} category\n   * @return {?}\n   */\n\n\n  static eraseSelectiveThingsInDisplay(category) {\n    return `${CSI}?${category}J`;\n  }\n  /**\n   *  CSI Ps K\n   *   Erase in Line (EL), VT100.\n   *     Ps = 0  -> Erase to Right (default).\n   *     Ps = 1  -> Erase to Left.\n   *     Ps = 2  -> Erase All.\n   * \\x9b?1K\n   *\n   * @param {?} category\n   * @return {?}\n   */\n\n\n  static eraseInLine(category) {\n    return `${CSI}${category}K`;\n  }\n  /**\n   *  CSI ? Ps K\n   *    Erase in Line (DECSEL), VT220.\n   *      Ps = 0  -> Selective Erase to Right (default).\n   *      Ps = 1  -> Selective Erase to Left.\n   *      Ps = 2  -> Selective Erase All.\n   * \\x9b?1K\n   *\n   * @param {?} category\n   * @return {?}\n   */\n\n\n  static eraseSelectiveThingsInLine(category) {\n    return `${CSI}?${category}K`;\n  }\n  /**\n   *  CSI Ps L  Insert Ps Line(s) (default = 1) (IL).\n   * \\x9b2L\n   *\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static insertLines(count) {\n    return `${CSI}${count}L`;\n  }\n  /**\n   *  CSI Ps M  Delete Ps Line(s) (default = 1) (DL).\n   * \\x9b2M\n   *\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static deleteLines(count) {\n    return `${CSI}${count}M`;\n  }\n  /**\n   *  CSI Ps P  Delete Ps Character(s) (default = 1) (DCH).\n   * \\x9b2P\n   *\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static deleteCharacter(count) {\n    return `${CSI}${count}P`;\n  }\n  /**\n   *  CSI Ps S  Scroll up Ps lines (default = 1) (SU), VT420, ECMA-48.\n   * \\x9b2S\n   *\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static scrollUpLines(count) {\n    return `${CSI}${count}S`;\n  }\n  /**\n       *  CSI ? Pi ; Pa ; Pv S */\n\n  /**\n   *  CSI Ps T  Scroll down Ps lines (default = 1) (SD), VT420.\n   * \\x9b2T\n   *\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static scrollDownLines(count) {\n    return `${CSI}${count}T`;\n  }\n  /**\n       *  CSI Ps ; Ps ; Ps ; Ps ; Ps T */\n\n  /**\n       *  CSI > Ps ; Ps T */\n\n  /**\n   *  CSI Ps X  Erase Ps Character(s) (default = 1) (ECH).\n   * \\x9b2X\n   *\n   * @param {?} count\n   * @return {?}\n   */\n\n\n  static eraseCharacters(count) {\n    return `${CSI}${count}X`;\n  }\n\n}\n/** @enum {number} */\n\n\nconst KindOfEraseInDisplay = {\n  Below: 0,\n  Above: 1,\n  All: 2,\n  SavedLines: 3\n};\nKindOfEraseInDisplay[KindOfEraseInDisplay.Below] = 'Below';\nKindOfEraseInDisplay[KindOfEraseInDisplay.Above] = 'Above';\nKindOfEraseInDisplay[KindOfEraseInDisplay.All] = 'All';\nKindOfEraseInDisplay[KindOfEraseInDisplay.SavedLines] = 'SavedLines';\n/** @enum {number} */\n\nconst KindOfEraseInLine = {\n  Right: 0,\n  Left: 1,\n  All: 2\n};\nKindOfEraseInLine[KindOfEraseInLine.Right] = 'Right';\nKindOfEraseInLine[KindOfEraseInLine.Left] = 'Left';\nKindOfEraseInLine[KindOfEraseInLine.All] = 'All';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/ng-terminal.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\nfunction NgTerminal() {}\n\nif (false) {\n  /**\n   * getter only provided\n   * A observable to emit printable characters when a user typed on the div for the xterm\n   * @deprecated since version 2.1.0\n   * @type {?}\n   */\n  NgTerminal.prototype.keyInput;\n  /**\n   * getter only provided\n   * A observable to emit keys and keyboard event when a user typed on the div for the xterm\n   * @type {?}\n   */\n\n  NgTerminal.prototype.keyEventInput;\n  /**\n   * getter only provided\n   * return the core object of the terminal where you can control everything directly\n   * @type {?}\n   */\n\n  NgTerminal.prototype.underlying;\n  /**\n   * write print charactors or control sequences to the xterm directly\n   * @param {?} chars charactors to write\n   * @return {?}\n   */\n\n  NgTerminal.prototype.write = function (chars) {};\n  /**\n   * change row, col, draggable\n   * @param {?} opt\n   * @return {?}\n   */\n\n\n  NgTerminal.prototype.setDisplayOption = function (opt) {};\n  /**\n   * @param {?} styleObject\n   * @return {?}\n   */\n\n\n  NgTerminal.prototype.setStyle = function (styleObject) {};\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/display-option.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * options for dimensions of terminal.\n * fixedGrid has high priority than activateDraggableOnEdge's\n * @record\n */\n\n\nfunction DisplayOption() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  DisplayOption.prototype.fixedGrid;\n  /** @type {?|undefined} */\n\n  DisplayOption.prototype.activateDraggableOnEdge;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ng-terminal.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { FunctionsUsingCSI, KindOfEraseInDisplay, KindOfEraseInLine, NgTerminalComponent, NgTerminalModule, NgTerminalService, GlobalStyleComponent as ɵa }; //# sourceMappingURL=ng-terminal.js.map","map":null,"metadata":{},"sourceType":"module"}