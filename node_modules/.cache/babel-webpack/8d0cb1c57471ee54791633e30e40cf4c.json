{"ast":null,"code":"/**\r\n * XY series module.\r\n */\nimport { __extends, __values } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Series, SeriesDataItem } from \"./Series\";\nimport { Sprite, visualProperties } from \"../../core/Sprite\";\nimport { ValueAxis } from \"../axes/ValueAxis\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { MutableValueDisposer } from \"../../core/utils/Disposer\";\nimport { XYChart } from \"../types/XYChart\";\nimport { CategoryAxis } from \"../axes/CategoryAxis\";\nimport { DateAxis } from \"../axes/DateAxis\";\nimport { registry } from \"../../core/Registry\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $time from \"../../core/utils/Time\";\nimport * as $array from \"../../core/utils/Array\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $path from \"../../core/rendering/Path\";\nimport { options } from \"../../core/Options\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[XYSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar XYSeriesDataItem = function (_super) {\n  __extends(XYSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function XYSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"XYSeriesDataItem\";\n    _this.values.customValue = {};\n    _this.values.valueX = {\n      stack: 0\n    };\n    _this.values.valueY = {\n      stack: 0\n    };\n    _this.values.openValueX = {};\n    _this.values.openValueY = {};\n    _this.values.dateX = {};\n    _this.values.dateY = {};\n    _this.values.openDateX = {};\n    _this.values.openDateY = {};\n\n    _this.setLocation(\"dateX\", 0.5, 0);\n\n    _this.setLocation(\"dateY\", 0.5, 0);\n\n    _this.setLocation(\"categoryX\", 0.5, 0);\n\n    _this.setLocation(\"categoryY\", 0.5, 0);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(XYSeriesDataItem.prototype, \"valueX\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      return this.values.valueX.value;\n    },\n\n    /**\r\n     * Item's numeric value on X value axis.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function (value) {\n      this.setValue(\"valueX\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"customValue\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      return this.values.customValue.value;\n    },\n\n    /**\r\n     * Item's custom numeric value.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function (value) {\n      this.setValue(\"customValue\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"valueY\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      return this.values.valueY.value;\n    },\n\n    /**\r\n     * Item's numeric value on Y value axis.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function (value) {\n      this.setValue(\"valueY\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"dateX\", {\n    /**\r\n     * @return Date\r\n     */\n    get: function () {\n      return this.getDate(\"dateX\");\n    },\n\n    /**\r\n     * Item's date value on X date-based axis.\r\n     *\r\n     * @param date  Date\r\n     */\n    set: function (date) {\n      this.setDate(\"dateX\", date);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"dateY\", {\n    /**\r\n     * @return Date\r\n     */\n    get: function () {\n      return this.getDate(\"dateY\");\n    },\n\n    /**\r\n     * Item's date value on Y date-based axis.\r\n     *\r\n     * @param date  Date\r\n     */\n    set: function (date) {\n      this.setDate(\"dateY\", date);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"categoryX\", {\n    /**\r\n     * @return Category\r\n     */\n    get: function () {\n      return this.categories.categoryX;\n    },\n\n    /**\r\n     * Item's category on X category axis.\r\n     *\r\n     * @param category  Category\r\n     */\n    set: function (category) {\n      this.setCategory(\"categoryX\", category);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"categoryY\", {\n    /**\r\n     * @return Category\r\n     */\n    get: function () {\n      return this.categories.categoryY;\n    },\n\n    /**\r\n     * Item's category on Y category axis.\r\n     *\r\n     * @param category  Category\r\n     */\n    set: function (category) {\n      this.setCategory(\"categoryY\", category);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openValueX\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      return this.values.openValueX.value;\n    },\n\n    /**\r\n     * Item's open numeric value on X value axis.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function (value) {\n      this.setValue(\"openValueX\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openValueY\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      return this.values.openValueY.value;\n    },\n\n    /**\r\n     * Item's open numeric value on Y value axis.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function (value) {\n      this.setValue(\"openValueY\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openDateX\", {\n    /**\r\n     * @return Date\r\n     */\n    get: function () {\n      return this.getDate(\"openDateX\");\n    },\n\n    /**\r\n     * Item's open date value on X date-based axis.\r\n     *\r\n     * @param date  Date\r\n     */\n    set: function (date) {\n      this.setDate(\"openDateX\", date);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openDateY\", {\n    /**\r\n     * @return Date\r\n     */\n    get: function () {\n      return this.getDate(\"openDateY\");\n    },\n\n    /**\r\n     * Item's open date value on Y date-based axis.\r\n     *\r\n     * @param date  Date\r\n     */\n    set: function (date) {\n      this.setDate(\"openDateY\", date);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openCategoryX\", {\n    /**\r\n     * @return Category\r\n     */\n    get: function () {\n      return this.categories.openCategoryX;\n    },\n\n    /**\r\n     * Item's open category on X category axis.\r\n     *\r\n     * @param category  Category\r\n     */\n    set: function (category) {\n      this.setCategory(\"openCategoryX\", category);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openCategoryY\", {\n    /**\r\n     * @return Category\r\n     */\n    get: function () {\n      return this.categories.openCategoryY;\n    },\n\n    /**\r\n     * Item's open category on Y category axis.\r\n     *\r\n     * @param category  Category\r\n     */\n    set: function (category) {\n      this.setCategory(\"openCategoryY\", category);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Return smallest value out of all item's value fields.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param fields      Fields to check in\r\n   * @param working     Include working (temporary) values\r\n   * @param stackValue  If item is in a stack, the value item starts as\r\n   * @return Value\r\n   */\n\n  XYSeriesDataItem.prototype.getMin = function (fields, working, stackValue) {\n    var _this = this; //if (this.visible) {  // dumped because of non smooth zooming\n\n\n    var min;\n\n    if (!$type.isNumber(stackValue)) {\n      stackValue = 0;\n    }\n\n    $array.each(fields, function (field) {\n      var value;\n\n      if (working) {\n        value = _this.getWorkingValue(field);\n      } else {\n        value = _this.getValue(field);\n      }\n\n      value += stackValue;\n\n      if (value < min || !$type.isNumber(min)) {\n        min = value;\n      }\n    });\n    return min; //}\n  };\n  /**\r\n   * Return biggest value out of all item's value fields.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param fields      Fields to check in\r\n   * @param working     Include working (temporary) values\r\n   * @param stackValue  If item is in a stack, the value item starts as\r\n   * @return Value\r\n   */\n\n\n  XYSeriesDataItem.prototype.getMax = function (fields, working, stackValue) {\n    var _this = this; //if (this.visible) { // dumped because of non smooth zooming\n\n\n    var max;\n\n    if (!$type.isNumber(stackValue)) {\n      stackValue = 0;\n    }\n\n    $array.each(fields, function (field) {\n      var value;\n\n      if (working) {\n        value = _this.getWorkingValue(field);\n      } else {\n        value = _this.getValue(field);\n      }\n\n      value += stackValue;\n\n      if (value > max || !$type.isNumber(max)) {\n        max = value;\n      }\n    });\n    return max; //}\n  };\n\n  return XYSeriesDataItem;\n}(SeriesDataItem);\n\nexport { XYSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines Series for [[XYChart]].\r\n *\r\n * @see {@link IXYSeriesEvents} for a list of available Events\r\n * @see {@link IXYSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar XYSeries = function (_super) {\n  __extends(XYSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function XYSeries() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Indicates which of the series' `dataFields` to calculate aggregate values\r\n     * for.\r\n     *\r\n     * Available data fields for all [[XYSeries]] are:\r\n     * `valueX`, `valueY`, `openValueX`, and `openValueY`.\r\n     *\r\n     * [[CandlestickSeries]] adds:\r\n     * `lowValueX`, `lowValueY`, `highValueX`, and `highValueY`.\r\n     *\r\n     * Available options:\r\n     * `\"open\"`, `\"close\"`, `\"low\"`, `\"high\"`, `\"average\"`, `\"sum\"`.\r\n     *\r\n     * Defaults are as follows:\r\n     * * `valueX`: `\"close\"`\r\n     * * `valueY`: `\"close\"`\r\n     * * `openValueX`: `\"open\"`\r\n     * * `openValueY`: `\"open\"`\r\n     * * `lowValueX`: `\"low\"`\r\n     * * `lowValueY`: `\"low\"`\r\n     * * `highValueX`: `\"high\"`\r\n     * * `highValueY`: `\"high\"`\r\n     *\r\n     * Is required only if data being plotted on a `DateAxis` and\r\n     * its `groupData` is set to `true`.\r\n     *\r\n     * ```TypeScript\r\n     * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * let series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JavaScript\r\n     * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * var series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     \"type\": \"DateAxis\",\r\n     *     \"groupData\": true\r\n     *   }],\r\n     *   \"yAxes\": [{\r\n     *     \"type\": \"ValueAxis\"\r\n     *   }],\r\n     *   \"series\": [{\r\n     *     \"type\": \"LineSeries\",\r\n     *     \"dataFields\": {\r\n     *       \"dateX\": \"date\",\r\n     *       \"valueY\": \"value\"\r\n     *     },\r\n     *     \"groupFields\": {\r\n     *       \"valueY\": \"average\"\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * The above setup will ensure, that if there are many data items within\r\n     * selected range, they will be grouped into aggregated data points, using\r\n     * average value of all the values.\r\n     *\r\n     * For example if we have 2 years worth of daily data (~700 data items), when\r\n     * fully zoomed out, the chart would show ~100 data items instead: one for\r\n     * each week in those two years.\r\n     *\r\n     * Grouping will occur automatically, based on current selection range, and\r\n     * will change dynamically when user zooms in/out the chart.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     * @since 4.7.0\r\n     */\n\n\n    _this.groupFields = {};\n    /**\r\n     * X axis the series is attached to.\r\n     */\n\n    _this._xAxis = new MutableValueDisposer();\n    /**\r\n     * Y axis the series is attached to.\r\n     */\n\n    _this._yAxis = new MutableValueDisposer();\n    /**\r\n     * [_xValueFields description]\r\n     *\r\n     * @todo Description\r\n     */\n\n    _this._xValueFields = [];\n    /**\r\n     * [_yValueFields description]\r\n     *\r\n     * @todo Description\r\n     */\n\n    _this._yValueFields = [];\n    /**\r\n     * @ignore\r\n     */\n\n    _this._baseInterval = {};\n    /**\r\n     * @ignore\r\n     */\n\n    _this.dataGrouped = false;\n    /**\r\n     * @ignore\r\n     */\n\n    _this.usesShowFields = false;\n    /**\r\n     * @ignore\r\n     */\n\n    _this._dataSetChanged = false;\n    _this._maxxX = 100000;\n    _this._maxxY = 100000;\n    _this._propertiesChanged = false;\n    /**\r\n     * @ignore\r\n     */\n\n    _this.outOfRange = false;\n    _this.className = \"XYSeries\";\n    _this.isMeasured = false;\n    _this.groupFields.valueX = \"close\";\n    _this.groupFields.valueY = \"close\";\n    _this.groupFields.customValue = \"close\";\n    _this.groupFields.openValueX = \"open\";\n    _this.groupFields.openValueY = \"open\";\n    _this.cursorTooltipEnabled = true;\n    _this.cursorHoverEnabled = true;\n    _this.excludeFromTotal = false;\n    _this.mainContainer.mask = new Sprite();\n\n    _this.mainContainer.mask.setElement(_this.paper.add(\"path\"));\n\n    _this.stacked = false;\n    _this.snapTooltip = false;\n    _this._showBullets = false;\n    _this.tooltip.pointerOrientation = \"horizontal\";\n    _this.properties.stackToNegative = true;\n    _this.hideTooltipWhileZooming = true;\n\n    _this.setPropertyValue(\"maskBullets\", true);\n\n    _this.tooltip.events.on(\"hidden\", function () {\n      _this.returnBulletDefaultState();\n    }, undefined, false);\n\n    _this._disposers.push(_this._xAxis);\n\n    _this._disposers.push(_this._yAxis);\n\n    _this.observe(visualProperties, function () {\n      if (_this.inited) {\n        _this._propertiesChanged = true;\n\n        if (_this.legendDataItem) {\n          _this.legendDataItem.childrenCreated = false;\n        }\n\n        if (_this.chart && _this.chart.legend) {\n          _this.chart.legend.invalidateDataItems();\n        }\n\n        _this.invalidate();\n      }\n    }, undefined, false);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  XYSeries.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"X/Y Series\");\n    }\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  XYSeries.prototype.createDataItem = function () {\n    return new XYSeriesDataItem();\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  XYSeries.prototype.resetExtremes = function () {\n    this._tmin.clear();\n\n    this._tmax.clear();\n\n    this._smin.clear();\n\n    this._smax.clear();\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  XYSeries.prototype.dataChangeUpdate = function () {\n    this.dataGrouped = false;\n    this._baseInterval = {};\n    this._currentDataSetId = \"\";\n    this.resetExtremes();\n\n    if (this.xAxis) {\n      this.xAxis.seriesDataChangeUpdate(this);\n    }\n\n    if (this.yAxis) {\n      this.yAxis.seriesDataChangeUpdate(this);\n    }\n  };\n  /**\r\n   * (Re)validates the series' data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  XYSeries.prototype.validateData = function () {\n    this._baseInterval = {};\n    var dataFields = this.dataFields;\n\n    if (dataFields.valueYShow || dataFields.openValueXShow || dataFields.openValueXShow || dataFields.openValueYShow) {\n      this.usesShowFields = true;\n    } else {\n      this.usesShowFields = false;\n    }\n\n    this.defineFields();\n\n    if (this.data.length > 0) {\n      this.dataChangeUpdate();\n    }\n\n    _super.prototype.validateData.call(this);\n\n    this.updateItemReaderText();\n\n    if (this.chart) {\n      if (!$type.hasValue(this.dataFields[this._xField]) || !$type.hasValue(this.dataFields[this._yField])) {\n        throw Error(\"Data fields for series \\\"\" + (this.name ? this.name : this.uid) + \"\\\" are not properly defined.\");\n      }\n    } // 4.7.21 solves 51540\n\n\n    if (this.inited && this.isHidden) {\n      this.hide(0);\n    }\n\n    this.dataGrouped = false;\n  };\n  /**\r\n   * Processes data item.\r\n   *\r\n   * @param dataItem     Data item\r\n   * @param dataContext  Raw data\r\n   * @param index        Index of the data item\r\n   */\n\n\n  XYSeries.prototype.processDataItem = function (dataItem, dataContext) {\n    try {\n      _super.prototype.processDataItem.call(this, dataItem, dataContext);\n\n      this.xAxis.processSeriesDataItem(dataItem, \"X\");\n      this.yAxis.processSeriesDataItem(dataItem, \"Y\");\n      this.setInitialWorkingValues(dataItem);\n    } catch (e) {\n      if (this._chart) {\n        this._chart.raiseCriticalError(e);\n      }\n    }\n  };\n  /**\r\n   *\r\n   * When validating raw data, instead of processing data item, we update it\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param item\r\n   */\n\n\n  XYSeries.prototype.updateDataItem = function (dataItem) {\n    _super.prototype.updateDataItem.call(this, dataItem); //dataItem.events.disable();\n\n\n    this.xAxis.processSeriesDataItem(dataItem, \"X\");\n    this.yAxis.processSeriesDataItem(dataItem, \"Y\"); //dataItem.events.enable();\t\t\n  };\n  /**\r\n   * Inits data item's working values.\r\n   *\r\n   * @param dataItem  Data item\r\n   * @param index     Data item's index\r\n   */\n\n\n  XYSeries.prototype.setInitialWorkingValues = function (dataItem) {};\n  /**\r\n   * @ignore\r\n   */\n\n\n  XYSeries.prototype.disposeData = function () {\n    _super.prototype.disposeData.call(this);\n\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n\n    if (xAxis) {\n      var dataItemsX = this.dataItemsByAxis.getKey(xAxis.uid);\n\n      if (dataItemsX) {\n        dataItemsX.clear();\n      }\n\n      if (xAxis instanceof CategoryAxis) {\n        this.clearCatAxis(xAxis);\n      }\n    }\n\n    if (yAxis) {\n      var dataItemsY = this.dataItemsByAxis.getKey(yAxis.uid);\n\n      if (dataItemsY) {\n        dataItemsY.clear();\n      }\n\n      if (yAxis instanceof CategoryAxis) {\n        this.clearCatAxis(yAxis);\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  XYSeries.prototype.clearCatAxis = function (axis) {\n    var uid = this.uid;\n    axis.dataItems.each(function (dataItem) {\n      if (dataItem.seriesDataItems[uid]) {\n        dataItem.seriesDataItems[uid] = [];\n      }\n    });\n  };\n  /**\r\n   * Sets up which data fields to use for data access.\r\n   */\n\n\n  XYSeries.prototype.defineFields = function () {\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n\n    if (xAxis && yAxis) {\n      var xAxisFieldName = xAxis.axisFieldName;\n      var xField = xAxisFieldName + \"X\";\n      var xOpenField = \"open\" + $utils.capitalize(xAxisFieldName) + \"X\";\n      var yAxisFieldName = yAxis.axisFieldName;\n      var yField = yAxisFieldName + \"Y\";\n      var yOpenField = \"open\" + $utils.capitalize(yAxisFieldName) + \"Y\";\n      this._xField = xField;\n      this._yField = yField;\n\n      if (this.dataFields[xOpenField]) {\n        this._xOpenField = xOpenField;\n      }\n\n      if (this.dataFields[yOpenField]) {\n        this._yOpenField = yOpenField;\n      }\n\n      if (!this.dataFields[yOpenField] && this.baseAxis == yAxis) {\n        this._yOpenField = yField;\n      }\n\n      if (!this.dataFields[xOpenField] && this.baseAxis == xAxis) {\n        this._xOpenField = xField;\n      }\n\n      if (this.stacked && this.baseAxis == xAxis) {\n        this._xOpenField = xField;\n      }\n\n      if (this.stacked && this.baseAxis == yAxis) {\n        this._yOpenField = yField;\n      }\n\n      if (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {\n        if (!this._yOpenField) {\n          this._yOpenField = yField;\n        }\n      }\n\n      this._xValueFields = [];\n      this._yValueFields = [];\n      this.addValueField(xAxis, this._xValueFields, this._xField);\n      this.addValueField(xAxis, this._xValueFields, this._xOpenField);\n      this.addValueField(yAxis, this._yValueFields, this._yField);\n      this.addValueField(yAxis, this._yValueFields, this._yOpenField);\n    }\n  };\n  /**\r\n   * [axis description]\r\n   *\r\n   * @todo Description\r\n   * @param axis    Axis\r\n   * @param fields  Fields (?)\r\n   * @param field   Field\r\n   */\n\n\n  XYSeries.prototype.addValueField = function (axis, fields, field) {\n    if (axis instanceof ValueAxis) {\n      if ($type.hasValue(this.dataFields[field]) && fields.indexOf(field) == -1) {\n        fields.push(field);\n      }\n    }\n  };\n  /**\r\n   * Sets category field from the category axis.\r\n   *\r\n   * User might set field for category axis only, but not for series. In such\r\n   * case, we take field value from axis and set it for series.\r\n   *\r\n   * @param field  Field\r\n   * @param axis   Axis\r\n   */\n\n\n  XYSeries.prototype.setCategoryAxisField = function (field, axis) {\n    if (!$type.hasValue(this.dataFields[field])) {\n      this.dataFields[field] = axis.dataFields.category;\n    }\n  };\n  /**\r\n   * Sets date field from the date axis.\r\n   *\r\n   * User might set field for category axis only, but not for series. In such\r\n   * case, we take field value from axis and set it for series.\r\n   *\r\n   * @param field  Field\r\n   * @param axis   Axis\r\n   */\n\n\n  XYSeries.prototype.setDateAxisField = function (field, axis) {\n    if (!$type.hasValue(this.dataFields[field])) {\n      this.dataFields[field] = axis.dataFields.date;\n    }\n  };\n  /**\r\n   * Performs after-draw tasks, e.g. creates masks.\r\n   */\n\n\n  XYSeries.prototype.afterDraw = function () {\n    _super.prototype.afterDraw.call(this);\n\n    this.createMask();\n  };\n  /**\r\n   * Create a mask for the series.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  XYSeries.prototype.createMask = function () {\n    // this mask from which we cut out ranges. does not work well if ranges overlap.\n    if (this.mainContainer.mask) {\n      var path_1 = this.getMaskPath(); // @todo: this approach won't work well on circluar or other non x/y axes\n\n      $iter.each(this.axisRanges.iterator(), function (range) {\n        if (range.axisFill.fillPath) {\n          range.axisFill.validate();\n          path_1 += range.axisFill.fillPath;\n        }\n      });\n      this.mainContainer.mask.path = path_1;\n    }\n  };\n  /**\r\n   * Returns an SVG path to use as series mask.\r\n   *\r\n   * @return SVG path\r\n   */\n\n\n  XYSeries.prototype.getMaskPath = function () {\n    if (this.xAxis && this.yAxis) {\n      return $path.rectToPath({\n        x: 0,\n        y: 0,\n        width: this.xAxis.axisLength,\n        height: this.yAxis.axisLength\n      });\n    }\n\n    return \"\";\n  };\n  /**\r\n   * Returns axis data field to use.\r\n   *\r\n   * @param axis  Axis\r\n   * @return Field name\r\n   */\n\n\n  XYSeries.prototype.getAxisField = function (axis) {\n    if (axis == this.xAxis) {\n      return this.xField;\n    }\n\n    if (axis == this.yAxis) {\n      return this.yField;\n    }\n  };\n  /**\r\n   * Validates data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  XYSeries.prototype.validateDataItems = function () {\n    var chart = this.chart;\n\n    if (chart) {\n      this._maxxX = $math.max(100000, chart.plotContainer.maxWidth * 2);\n      this._maxxY = $math.max(100000, chart.plotContainer.maxHeight * 2);\n    } // this helps date axis to check which baseInterval we should use\n\n\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n\n    if (xAxis && yAxis) {\n      xAxis.updateAxisBySeries();\n      yAxis.updateAxisBySeries();\n    }\n\n    _super.prototype.validateDataItems.call(this);\n\n    if (xAxis && yAxis) {\n      xAxis.postProcessSeriesDataItems(this);\n      yAxis.postProcessSeriesDataItems(this);\n    }\n  };\n  /**\r\n   * Validates data range.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  XYSeries.prototype.validateDataRange = function () {\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n\n    if (xAxis && yAxis) {\n      if (xAxis.dataRangeInvalid) {\n        xAxis.validateDataRange();\n      }\n\n      if (yAxis.dataRangeInvalid) {\n        yAxis.validateDataRange();\n      }\n    }\n\n    _super.prototype.validateDataRange.call(this);\n  };\n  /**\r\n   * (Re)validates the whole series, effectively causing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  XYSeries.prototype.validate = function () {\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n\n    if (xAxis && yAxis) {\n      if (xAxis.invalid) {\n        xAxis.validate();\n      }\n\n      if (yAxis.invalid) {\n        yAxis.validate();\n      }\n\n      this.y = yAxis.pixelY;\n      this.x = xAxis.pixelX;\n      this._showBullets = true;\n      var minBulletDistance = this.minBulletDistance;\n\n      if ($type.isNumber(minBulletDistance)) {\n        if (this.baseAxis.axisLength / (this.endIndex - this.startIndex) < minBulletDistance) {\n          this._showBullets = false;\n        }\n      }\n    }\n\n    this.updateTooltip();\n\n    if (xAxis instanceof DateAxis && xAxis.groupData && !this.dataGrouped || yAxis instanceof DateAxis && yAxis.groupData && !this.dataGrouped) {\n      return;\n    }\n\n    _super.prototype.validate.call(this);\n\n    var chart = this.chart;\n    var maskBullets = this.maskBullets;\n\n    if (chart && maskBullets) {\n      if (chart.className == \"XYChart\") {\n        if (chart.leftAxesContainer.layout == \"vertical\" || chart.rightAxesContainer.layout == \"vertical\") {\n          if (this.yAxis) {\n            this.bulletsContainer.mask = this.yAxis.renderer.gridContainer;\n          } else {\n            this.bulletsContainer.mask = undefined;\n          }\n        }\n\n        if (chart.topAxesContainer.layout == \"horizontal\" || chart.bottomAxesContainer.layout == \"horizontal\") {\n          if (this.xAxis) {\n            this.bulletsContainer.mask = this.xAxis.renderer.gridContainer;\n          } else {\n            this.bulletsContainer.mask = undefined;\n          }\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(XYSeries.prototype, \"xAxis\", {\n    /**\r\n     * @return Axis\r\n     */\n    get: function () {\n      if (this.chart) {\n        if (!this._xAxis.get()) {\n          var axis = this.chart.xAxes.getIndex(0);\n\n          if (!axis) {\n            throw Error(\"There are no X axes on chart.\");\n          }\n\n          this.xAxis = axis;\n        }\n\n        return this._xAxis.get();\n      }\n    },\n\n    /**\r\n     * X axis the series is attached to.\r\n     *\r\n     * @param axis  Axis\r\n     */\n    set: function (axis) {\n      this.setXAxis(axis);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  XYSeries.prototype.setXAxis = function (axis) {\n    var oldAxis = this._xAxis.get();\n\n    if (oldAxis != axis) {\n      if (oldAxis) {\n        this.dataItemsByAxis.removeKey(oldAxis.uid); // TODO why is this here ?\n\n        this._xAxis.dispose(); // temp @todo: why it is not disposed?\n\n\n        oldAxis.series.removeValue(this);\n      }\n\n      this._xAxis.set(axis, axis.registerSeries(this));\n\n      this.dataItemsByAxis.setKey(axis.uid, new Dictionary());\n      this.invalidateData();\n    }\n  };\n\n  Object.defineProperty(XYSeries.prototype, \"yAxis\", {\n    /**\r\n     * @return Axis\r\n     */\n    get: function () {\n      if (this.chart) {\n        if (!this._yAxis.get()) {\n          var axis = this.chart.yAxes.getIndex(0);\n\n          if (!axis) {\n            throw Error(\"There are no Y axes on chart.\");\n          }\n\n          this.yAxis = axis;\n        }\n\n        return this._yAxis.get();\n      }\n    },\n\n    /**\r\n     * Y axis the series is attached to.\r\n     *\r\n     * @param axis  Axis\r\n     */\n    set: function (axis) {\n      this.setYAxis(axis);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  XYSeries.prototype.setYAxis = function (axis) {\n    var oldAxis = this._yAxis.get();\n\n    if (oldAxis != axis) {\n      if (oldAxis) {\n        this.dataItemsByAxis.removeKey(oldAxis.uid); // TODO why is this here ?\n\n        this._yAxis.dispose(); // temp @todo: why it is not disposed?\n\n\n        oldAxis.series.removeValue(this);\n      }\n\n      this._yAxis.set(axis, axis.registerSeries(this));\n\n      if (axis.chart instanceof XYChart) {\n        axis.chart.handleYAxisSet(this);\n      }\n\n      this.dataItemsByAxis.setKey(axis.uid, new Dictionary());\n      this.invalidateData();\n    }\n  };\n\n  Object.defineProperty(XYSeries.prototype, \"baseAxis\", {\n    /**\r\n     * @return Axis\r\n     */\n    get: function () {\n      var xAxis = this.xAxis;\n      var yAxis = this.yAxis;\n\n      if (!this._baseAxis && xAxis && yAxis) {\n        if (yAxis instanceof DateAxis) {\n          this._baseAxis = yAxis;\n        }\n\n        if (xAxis instanceof DateAxis) {\n          this._baseAxis = xAxis;\n        }\n\n        if (yAxis instanceof CategoryAxis) {\n          this._baseAxis = yAxis;\n        }\n\n        if (xAxis instanceof CategoryAxis) {\n          this._baseAxis = xAxis;\n        }\n\n        if (!this._baseAxis) {\n          this._baseAxis = xAxis;\n        }\n      }\n\n      return this._baseAxis;\n    },\n\n    /**\r\n     * The main (base) axis.\r\n     *\r\n     * This is the axis that series fills will go to, or grow animations will\r\n     * happen from.\r\n     *\r\n     * @param value  Axis\r\n     */\n    set: function (value) {\n      if (this._baseAxis != value) {\n        this._baseAxis = value;\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adds one or several (array) of data items to the existing data.\r\n   *\r\n   * @param rawDataItem One or many raw data item objects\r\n   */\n\n  XYSeries.prototype.addData = function (rawDataItem, removeCount, skipRaw) {\n    _super.prototype.addData.call(this, rawDataItem, removeCount, skipRaw);\n\n    var scrollbarSeries = this.scrollbarSeries;\n\n    if (scrollbarSeries) {\n      this.scrollbarSeries.addData(rawDataItem, removeCount, true);\n      this.scrollbarSeries._parseDataFrom = this._parseDataFrom;\n    }\n  };\n\n  XYSeries.prototype.setData = function (value) {\n    _super.prototype.setData.call(this, value);\n\n    if (this.scrollbarSeries) {\n      this.scrollbarSeries.setData(value);\n    }\n  };\n  /**\r\n   * Makes the chart use particular data set.\r\n   *\r\n   * If `id` is not provided or there is no such data set, main data will be\r\n   * used.\r\n   *\r\n   * @ignore\r\n   * @since 4.7.0\r\n   * @param  id  Data set id\r\n   */\n\n\n  XYSeries.prototype.setDataSet = function (id) {\n    var changed = _super.prototype.setDataSet.call(this, id);\n\n    if (changed) {\n      this._dataSetChanged = true;\n      var dataItems = this.dataItems;\n      this.resetExtremes();\n\n      if (dataItems && dataItems.length > 0) {\n        var xAxis = this.xAxis;\n        var yAxis = this.yAxis;\n        this._prevStartIndex = undefined;\n        this._prevEndIndex = undefined;\n        this._startIndex = undefined;\n        this._endIndex = undefined;\n\n        if (!this.appeared) {\n          this.processValues(false); // this will slow down!\n        }\n\n        if (xAxis instanceof DateAxis && xAxis == this.baseAxis) {\n          this._tmin.setKey(xAxis.uid, dataItems.getIndex(0).dateX.getTime());\n\n          this._tmax.setKey(xAxis.uid, dataItems.getIndex(dataItems.length - 1).dateX.getTime());\n\n          this.dispatch(\"extremeschanged\");\n        }\n\n        if (yAxis instanceof DateAxis && yAxis == this.baseAxis) {\n          this._tmin.setKey(yAxis.uid, dataItems.getIndex(0).dateY.getTime());\n\n          this._tmax.setKey(yAxis.uid, dataItems.getIndex(dataItems.length - 1).dateY.getTime());\n\n          this.dispatch(\"extremeschanged\");\n        }\n      }\n    }\n\n    return changed;\n  };\n  /**\r\n   * Processes values after data items' were added.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItems  Data items\r\n   */\n\n\n  XYSeries.prototype.processValues = function (working) {\n    _super.prototype.processValues.call(this, working);\n\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n\n    if (!xAxis || !yAxis) {\n      return;\n    }\n\n    var dataItems = this.dataItems;\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var workingStartIndex = startIndex;\n    var workingEndIndex = endIndex;\n\n    if (!working) {\n      startIndex = 0;\n      endIndex = this.dataItems.length;\n    }\n\n    for (var i = startIndex; i < endIndex; i++) {\n      var dataItem = dataItems.getIndex(i);\n      this.getStackValue(dataItem, working);\n      var stackX = dataItem.getValue(\"valueX\", \"stack\");\n      var stackY = dataItem.getValue(\"valueY\", \"stack\");\n      minX = $math.min(dataItem.getMin(this._xValueFields, working, stackX), minX);\n      minY = $math.min(dataItem.getMin(this._yValueFields, working, stackY), minY);\n      maxX = $math.max(dataItem.getMax(this._xValueFields, working, stackX), maxX);\n      maxY = $math.max(dataItem.getMax(this._yValueFields, working, stackY), maxY); // if it's stacked, pay attention to stack value\n\n      if (this.stacked) {\n        if (this.baseAxis == xAxis) {\n          if (stackY < minY) {\n            minY = stackY;\n          }\n\n          if (stackY > maxY) {\n            maxY = stackY;\n          }\n        }\n\n        if (this.baseAxis == yAxis) {\n          if (stackX < minX) {\n            minX = stackX;\n          }\n\n          if (stackX > maxX) {\n            maxX = stackX;\n          }\n        }\n      }\n    } // this is mainly for value axis to calculate total and perecent.total of each series category\n\n\n    xAxis.processSeriesDataItems();\n    yAxis.processSeriesDataItems();\n    var xAxisId = xAxis.uid;\n    var yAxisId = yAxis.uid;\n\n    if (this.xAxis instanceof ValueAxis && (minX == Infinity || maxX == -Infinity)) {\n      this._smin.setKey(xAxisId, undefined);\n\n      this._smax.setKey(xAxisId, undefined);\n\n      this.dispatchImmediately(\"selectionextremeschanged\");\n      return;\n    }\n\n    if (this.yAxis instanceof ValueAxis && (minY == Infinity || maxY == -Infinity)) {\n      this._smin.setKey(yAxisId, undefined);\n\n      this._smax.setKey(yAxisId, undefined);\n\n      this.dispatchImmediately(\"selectionextremeschanged\");\n      return;\n    }\n\n    if (!working) {\n      if (this._tmin.getKey(xAxisId) != minX || this._tmax.getKey(xAxisId) != maxX || this._tmin.getKey(yAxisId) != minY || this._tmax.getKey(yAxisId) != maxY) {\n        this._tmin.setKey(xAxisId, minX);\n\n        this._tmax.setKey(xAxisId, maxX);\n\n        this._tmin.setKey(yAxisId, minY);\n\n        this._tmax.setKey(yAxisId, maxY);\n\n        var stackedSeries = this.stackedSeries;\n\n        if (stackedSeries) {\n          if (stackedSeries.isDisposed()) {\n            this.stackedSeries = undefined;\n          } else {\n            stackedSeries.processValues(false);\n          }\n        }\n\n        this.dispatchImmediately(\"extremeschanged\");\n      }\n    }\n\n    if (startIndex != workingStartIndex || endIndex != workingEndIndex) {\n      minX = Infinity;\n      maxX = -Infinity;\n      minY = Infinity;\n      maxY = -Infinity;\n\n      for (var i = workingStartIndex; i < workingEndIndex; i++) {\n        var dataItem = dataItems.getIndex(i);\n        this.getStackValue(dataItem, working);\n        var stackX = dataItem.getValue(\"valueX\", \"stack\");\n        var stackY = dataItem.getValue(\"valueY\", \"stack\");\n        minX = $math.min(dataItem.getMin(this._xValueFields, working, stackX), minX);\n        minY = $math.min(dataItem.getMin(this._yValueFields, working, stackY), minY);\n        maxX = $math.max(dataItem.getMax(this._xValueFields, working, stackX), maxX);\n        maxY = $math.max(dataItem.getMax(this._yValueFields, working, stackY), maxY); // if it's stacked, pay attention to stack value\n\n        if (this.stacked) {\n          if (this.baseAxis == xAxis) {\n            if (stackY < minY) {\n              minY = stackY;\n            }\n\n            if (stackY > maxY) {\n              maxY = stackY;\n            }\n          }\n\n          if (this.baseAxis == yAxis) {\n            if (stackX < minX) {\n              minX = stackX;\n            }\n\n            if (stackX > maxX) {\n              maxX = stackX;\n            }\n          }\n        }\n      }\n    }\n\n    if (this.xAxis instanceof ValueAxis && (minX == Infinity || maxX == -Infinity)) {\n      this._smin.setKey(xAxisId, undefined);\n\n      this._smax.setKey(xAxisId, undefined);\n\n      this.dispatchImmediately(\"selectionextremeschanged\");\n      return;\n    }\n\n    if (this.yAxis instanceof ValueAxis && (minY == Infinity || maxY == -Infinity)) {\n      this._smin.setKey(yAxisId, undefined);\n\n      this._smax.setKey(yAxisId, undefined);\n\n      this.dispatchImmediately(\"selectionextremeschanged\");\n      return;\n    }\n\n    if (this._smin.getKey(xAxisId) != minX || this._smax.getKey(xAxisId) != maxX || this._smin.getKey(yAxisId) != minY || this._smax.getKey(yAxisId) != maxY) {\n      this._smin.setKey(xAxisId, minX);\n\n      this._smax.setKey(xAxisId, maxX);\n\n      this._smin.setKey(yAxisId, minY);\n\n      this._smax.setKey(yAxisId, maxY);\n\n      if (this.appeared || this.start != 0 || this.end != 1 || this.dataItems != this.mainDataSet) {\n        /// new, helps to handle issues with change percent\n        var changed = false;\n\n        if (yAxis instanceof ValueAxis && !(yAxis instanceof DateAxis)) {\n          var tmin = this._tmin.getKey(yAxisId);\n\n          if (!$type.isNumber(tmin) || (this.usesShowFields || this._dataSetChanged || xAxis instanceof DateAxis && xAxis.groupData && this.isShowing) && minY < tmin || this.stackedSeries && !this.isHidden) {\n            this._tmin.setKey(yAxisId, minY);\n\n            changed = true;\n          }\n\n          var tmax = this._tmax.getKey(yAxisId);\n\n          if (!$type.isNumber(tmax) || (this.usesShowFields || this._dataSetChanged || xAxis instanceof DateAxis && xAxis.groupData && this.isShowing) && maxY > tmax || this.stackedSeries && !this.isHidden) {\n            this._tmax.setKey(yAxisId, maxY);\n\n            changed = true;\n          }\n        }\n\n        if (xAxis instanceof ValueAxis && !(xAxis instanceof DateAxis)) {\n          var tmin = this._tmin.getKey(xAxisId);\n\n          if (!$type.isNumber(tmin) || (this.usesShowFields || this._dataSetChanged || yAxis instanceof DateAxis && yAxis.groupData && this.isShowing) && minX < tmin || this.stackedSeries && !this.isHidden) {\n            this._tmin.setKey(xAxisId, minX);\n\n            changed = true;\n          }\n\n          var tmax = this._tmax.getKey(xAxisId);\n\n          if (!$type.isNumber(tmax) || (this.usesShowFields || this._dataSetChanged || yAxis instanceof DateAxis && yAxis.groupData && this.isShowing) && maxX > tmax || this.stackedSeries && !this.isHidden) {\n            this._tmax.setKey(xAxisId, maxX);\n\n            changed = true;\n          }\n        }\n\n        if (changed) {\n          this.dispatchImmediately(\"extremeschanged\");\n        }\n\n        if (this.start == 0 && this.end == 1) {\n          // yes, its ok. otherwise min/max won't be updated when zooming out\n          this._dataSetChanged = false;\n        }\n\n        this.dispatchImmediately(\"selectionextremeschanged\");\n      }\n    }\n\n    if (!working && this.stacked) {\n      this.processValues(true);\n    }\n  };\n  /**\r\n   * Hides element's [[Tooltip]].\r\n   *\r\n   * @see {@link Tooltip}\r\n   */\n\n\n  XYSeries.prototype.hideTooltip = function (duration) {\n    _super.prototype.hideTooltip.call(this, duration);\n\n    this.returnBulletDefaultState();\n    this._prevTooltipDataItem = undefined;\n  };\n  /**\r\n   * Shows series tooltip at specific position.\r\n   *\r\n   * @param xPosition  X\r\n   * @param yPosition  Y\r\n   */\n\n\n  XYSeries.prototype.showTooltipAtPosition = function (xPosition, yPosition) {\n    var dataItem;\n\n    if (this.visible && !this.isHiding && !this.isShowing) {\n      var xAxis = this._xAxis.get();\n\n      var yAxis = this._yAxis.get();\n\n      if (xAxis == this.baseAxis) {\n        dataItem = xAxis.getSeriesDataItem(this, xAxis.toAxisPosition(xPosition), this.snapTooltip);\n      }\n\n      if (yAxis == this.baseAxis) {\n        dataItem = yAxis.getSeriesDataItem(this, yAxis.toAxisPosition(yPosition), this.snapTooltip);\n      }\n\n      var point = this.showTooltipAtDataItem(dataItem);\n\n      if (point) {\n        return point;\n      } // so that if tooltip is shown on columns or bullets for it not to be hidden\n\n\n      if (!this.tooltipText && !this.tooltipHTML) {\n        return;\n      }\n    }\n\n    this.hideTooltip();\n  };\n\n  XYSeries.prototype.getAdjustedXLocation = function (dataItem, field, bulletLocationX) {\n    return dataItem.locations[field];\n  };\n\n  XYSeries.prototype.getAdjustedYLocation = function (dataItem, field, bulletLocationY) {\n    return dataItem.locations[field];\n  };\n  /**\r\n   * Shows series tooltip at specific dataItem.\r\n   *\r\n   * @param dataItem\r\n   */\n\n\n  XYSeries.prototype.showTooltipAtDataItem = function (dataItem) {\n    var e_1, _a;\n\n    var cursor = this.chart.cursor;\n\n    if (cursor && cursor.hideSeriesTooltipsOnSelection && cursor.selection.visible && cursor.downPoint) {\n      this.hideTooltip();\n      return;\n    }\n\n    this.returnBulletDefaultState(dataItem);\n\n    if (dataItem && dataItem.visible) {\n      this.updateLegendValue(dataItem);\n\n      if (this.cursorTooltipEnabled) {\n        this.tooltipDataItem = dataItem; // todo: add tooltipXField and tooltipYField.\n\n        var tooltipXField = this.tooltipXField;\n        var tooltipYField = this.tooltipYField;\n\n        if ($type.hasValue(dataItem[tooltipXField]) && $type.hasValue(dataItem[tooltipYField])) {\n          var tooltipPoint = this.getPoint(dataItem, tooltipXField, tooltipYField, this.getAdjustedXLocation(dataItem, tooltipXField), this.getAdjustedYLocation(dataItem, tooltipYField));\n\n          if (tooltipPoint) {\n            if (this.chart.className == \"XYChart\" && (tooltipPoint.y < -1 || tooltipPoint.y > this.yAxis.pixelHeight + 1 || tooltipPoint.x < -1 || tooltipPoint.x > this.xAxis.pixelWidth + 1)) {// void\n            } else {\n              this.tooltipX = tooltipPoint.x;\n              this.tooltipY = tooltipPoint.y;\n\n              if (this._prevTooltipDataItem != dataItem) {\n                this.dispatchImmediately(\"tooltipshownat\", {\n                  type: \"tooltipshownat\",\n                  target: this,\n                  dataItem: dataItem\n                });\n                this._prevTooltipDataItem = dataItem;\n              }\n\n              if (this.cursorHoverEnabled) {\n                try {\n                  for (var _b = __values(dataItem.sprites), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var sprite = _c.value;\n\n                    if (!sprite.parent.visible || sprite.isHidden || sprite.__disabled || sprite.disabled || sprite.isHiding) {} else {\n                      if (!sprite.interactions.isRealHover) {\n                        sprite.dispatchImmediately(\"over\");\n                        sprite.interactions.isRealHover = true;\n                      }\n\n                      sprite.isHover = true;\n                    }\n                  }\n                } catch (e_1_1) {\n                  e_1 = {\n                    error: e_1_1\n                  };\n                } finally {\n                  try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                  } finally {\n                    if (e_1) throw e_1.error;\n                  }\n                }\n              }\n\n              if (this.showTooltip()) {\n                return $utils.spritePointToSvg({\n                  x: tooltipPoint.x,\n                  y: tooltipPoint.y\n                }, this);\n              }\n\n              return;\n            }\n          }\n        }\n      }\n    } else {\n      this.updateLegendValue(dataItem, true);\n    }\n  };\n  /**\r\n   * Returns default state to bullets when tooltip is shown at some other data\r\n   * item or hidden\r\n   */\n\n\n  XYSeries.prototype.returnBulletDefaultState = function (dataItem) {\n    var e_2, _a;\n\n    if (this._prevTooltipDataItem && this._prevTooltipDataItem != dataItem) {\n      try {\n        for (var _b = __values(this._prevTooltipDataItem.sprites), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var sprite = _c.value;\n\n          if (!sprite.isDisposed()) {\n            var fireEvent = sprite.interactions.isRealHover;\n            sprite.isHover = false;\n\n            if (fireEvent) {\n              sprite.dispatchImmediately(\"out\");\n            }\n          } else {\n            this._prevTooltipDataItem = undefined;\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  };\n\n  XYSeries.prototype.shouldCreateBullet = function (dataItem, bulletTemplate) {\n    // use series xField/yField if bullet doesn't have fields set\n    var xField = bulletTemplate.xField;\n\n    if (!$type.hasValue(xField)) {\n      xField = this.xField;\n    }\n\n    var yField = bulletTemplate.yField;\n\n    if (!$type.hasValue(yField)) {\n      yField = this.yField;\n    }\n\n    if (this.xAxis instanceof ValueAxis && !dataItem.hasValue([xField]) || this.yAxis instanceof ValueAxis && !dataItem.hasValue([yField])) {\n      return false;\n    }\n\n    if (bulletTemplate.disabled) {\n      var disabledField = bulletTemplate.propertyFields.disabled;\n      var dataContext = dataItem.dataContext;\n\n      if (dataContext && dataContext[disabledField] === false) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  XYSeries.prototype.updateTooltip = function () {\n    if (!this.hideTooltipWhileZooming && this.tooltip && !this.tooltip.isHidden && !this.isHiding && !this.isHidden && this.tooltipDataItem) {\n      this.showTooltipAtDataItem(this.tooltipDataItem);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  XYSeries.prototype.positionBullet = function (bullet) {\n    _super.prototype.positionBullet.call(this, bullet);\n\n    var dataItem = bullet.dataItem; // use series xField/yField if bullet doesn't have fields set\n\n    var xField = bullet.xField;\n\n    if (!$type.hasValue(xField)) {\n      xField = this.xField;\n    }\n\n    var yField = bullet.yField;\n\n    if (!$type.hasValue(yField)) {\n      yField = this.yField;\n    }\n\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n\n    if (xAxis instanceof ValueAxis && !dataItem.hasValue([xField]) || yAxis instanceof ValueAxis && !dataItem.hasValue([yField])) {\n      bullet.visible = false;\n    } else {\n      var bulletLocationX = this.getBulletLocationX(bullet, xField);\n      var bulletLocationY = this.getBulletLocationY(bullet, yField);\n      var point = this.getPoint(dataItem, xField, yField, bulletLocationX, bulletLocationY);\n\n      if (point) {\n        var xOpenField = this.xOpenField;\n        var yOpenField = this.yOpenField;\n        var positionX = void 0;\n        var positionY = void 0;\n\n        if (xAxis instanceof DateAxis) {\n          if (!$type.isNumber(bulletLocationX)) {\n            bulletLocationX = 0;\n          }\n\n          var openValue = void 0;\n          var closeValue = dataItem.getWorkingValue(xField);\n\n          if (!xOpenField) {\n            if (xAxis == this.baseAxis) {\n              openValue = xAxis.baseValue;\n            }\n          } else {\n            openValue = dataItem.getWorkingValue(xOpenField);\n          }\n\n          if (!$type.isNumber(openValue)) {\n            openValue = closeValue;\n          }\n\n          var stack = dataItem.getValue(\"valueX\", \"stack\");\n          openValue += stack;\n          closeValue += stack;\n\n          if (openValue == closeValue) {\n            var baseInterval = xAxis.baseInterval;\n            var dateFormatter = xAxis.dateFormatter;\n            openValue = $time.round(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.firstDayOfWeek, dateFormatter.utc, undefined, dateFormatter.timezoneMinutes, dateFormatter.timezone).getTime();\n            closeValue = $time.add(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.utc).getTime();\n          }\n\n          var middleValue = void 0;\n\n          if (xAxis == this.baseAxis) {\n            middleValue = openValue + (closeValue - openValue) * bulletLocationX;\n          } else {\n            middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationX);\n          }\n\n          positionX = xAxis.valueToPosition(middleValue);\n        } else if (xAxis instanceof ValueAxis) {\n          if (!$type.isNumber(bulletLocationX)) {\n            bulletLocationX = 0;\n          }\n\n          var openValue = void 0;\n          var closeValue = dataItem.getWorkingValue(xField);\n\n          if (!xOpenField) {\n            openValue = xAxis.baseValue;\n          } else {\n            openValue = dataItem.getWorkingValue(xOpenField);\n          }\n\n          var stack = dataItem.getValue(\"valueX\", \"stack\");\n          openValue += stack;\n          closeValue += stack;\n          var middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationX);\n          positionX = xAxis.valueToPosition(middleValue);\n        } else if (xAxis instanceof CategoryAxis) {\n          var rightLocation = this.getAdjustedXLocation(dataItem, xField, bullet.locationX);\n          var leftLocation = this.getAdjustedXLocation(dataItem, xOpenField, bullet.locationX);\n          positionX = xAxis.categoryToPosition(dataItem[xField], rightLocation);\n          var openPositionX = void 0;\n\n          if (xOpenField) {\n            openPositionX = xAxis.categoryToPosition(dataItem[xOpenField], leftLocation);\n          }\n\n          if (!$type.isNumber(openPositionX)) {\n            openPositionX = 1;\n          }\n\n          positionX = openPositionX + (positionX - openPositionX) * bulletLocationX;\n        }\n\n        if (yAxis instanceof DateAxis) {\n          if (!$type.isNumber(bulletLocationY)) {\n            bulletLocationY = 0;\n          }\n\n          var openValue = void 0;\n          var closeValue = dataItem.getWorkingValue(yField);\n\n          if (!yOpenField) {\n            if (yAxis == this.baseAxis) {\n              openValue = yAxis.baseValue;\n            }\n          } else {\n            openValue = dataItem.getWorkingValue(yOpenField);\n          }\n\n          if (!$type.isNumber(openValue)) {\n            openValue = closeValue;\n          }\n\n          var stack = dataItem.getValue(\"valueY\", \"stack\");\n          openValue += stack;\n          closeValue += stack;\n\n          if (openValue == closeValue) {\n            var baseInterval = yAxis.baseInterval;\n            var dateFormatter = yAxis.dateFormatter;\n            openValue = $time.round(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.firstDayOfWeek, dateFormatter.utc, undefined, dateFormatter.timezoneMinutes, dateFormatter.timezone).getTime();\n            closeValue = $time.add(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.utc).getTime();\n          }\n\n          var middleValue = void 0;\n\n          if (yAxis == this.baseAxis) {\n            middleValue = openValue + (closeValue - openValue) * bulletLocationY;\n          } else {\n            middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationY);\n          }\n\n          positionY = yAxis.valueToPosition(middleValue);\n        } else if (yAxis instanceof ValueAxis) {\n          if (!$type.isNumber(bulletLocationY)) {\n            bulletLocationY = 0;\n          }\n\n          var openValue = void 0;\n          var closeValue = dataItem.getWorkingValue(yField);\n\n          if (!yOpenField) {\n            openValue = yAxis.baseValue;\n          } else {\n            openValue = dataItem.getWorkingValue(yOpenField);\n          }\n\n          var stack = dataItem.getValue(\"valueY\", \"stack\");\n          openValue += stack;\n          closeValue += stack;\n          var middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationY);\n          positionY = yAxis.valueToPosition(middleValue);\n        } else if (yAxis instanceof CategoryAxis) {\n          positionY = yAxis.categoryToPosition(dataItem[yField], bulletLocationY);\n          var topLocation = this.getAdjustedYLocation(dataItem, yField, bullet.locationY);\n          var bottomLocation = this.getAdjustedYLocation(dataItem, yOpenField, bullet.locationY);\n          positionY = yAxis.categoryToPosition(dataItem[yField], topLocation);\n          var openPositionY = void 0;\n\n          if (yOpenField) {\n            openPositionY = yAxis.categoryToPosition(dataItem[yOpenField], bottomLocation);\n          }\n\n          if (!$type.isNumber(openPositionY)) {\n            openPositionY = 1;\n          }\n\n          positionY = openPositionY + (positionY - openPositionY) * bulletLocationY;\n        }\n\n        bullet.visible = true;\n        this.positionBulletReal(bullet, positionX, positionY);\n      } else {\n        bullet.visible = false;\n      }\n    }\n  };\n\n  XYSeries.prototype.positionBulletReal = function (bullet, positionX, positionY) {\n    bullet.x = this.xAxis.renderer.positionToPoint(positionX, positionY).x;\n    bullet.y = this.yAxis.renderer.positionToPoint(positionY, positionX).y;\n  };\n  /**\r\n   * returns bullet x location\r\n   * @ignore\r\n   */\n\n\n  XYSeries.prototype.getBulletLocationX = function (bullet, field) {\n    var bulletLocation = bullet.locationX;\n    var dataItem = bullet.dataItem;\n\n    if (!$type.isNumber(bulletLocation)) {\n      bulletLocation = dataItem.workingLocations[field];\n    }\n\n    return bulletLocation;\n  };\n  /**\r\n   * Returns bullet x location\r\n   * @ignore\r\n   */\n\n\n  XYSeries.prototype.getBulletLocationY = function (bullet, field) {\n    var bulletLocation = bullet.locationY;\n    var dataItem = bullet.dataItem;\n\n    if (!$type.isNumber(bulletLocation)) {\n      bulletLocation = dataItem.workingLocations[field];\n    }\n\n    return bulletLocation;\n  };\n  /**\r\n   * This method must be called if you update Series' data fields that might\r\n   * affect stacking of the series.\r\n   *\r\n   * Since individual `dataField` changes are not being monitored, you need\r\n   * todo it manually for changes to take affect.\r\n   *\r\n   * @since 4.7.21\r\n   */\n\n\n  XYSeries.prototype.updateStacking = function () {\n    var _this = this;\n\n    this.invalidateDataItems();\n\n    if (this.chart) {\n      this.chart.series.each(function (series) {\n        if (series.baseAxis == _this.baseAxis) {\n          series.stackedSeries = undefined;\n          series.invalidateDataItems();\n          series.invalidateProcessedData();\n        }\n      });\n    }\n  };\n\n  Object.defineProperty(XYSeries.prototype, \"stacked\", {\n    /**\r\n     * @return Can be stacked?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"stacked\");\n    },\n\n    /**\r\n     * Can items from this series be included into stacks?\r\n     *\r\n     * Note: proper stacking is only possible if series have the same number\r\n     * of data items. To ensure this, don't set data directly on series\r\n     * but do this on chart instead.\r\n     *\r\n     * @default false\r\n     * @param stacked  Can be stacked?\r\n     */\n    set: function (stacked) {\n      if (this.setPropertyValue(\"stacked\", stacked, true)) {\n        this.updateStacking();\n        var xAxis = this.xAxis;\n        var yAxis = this.yAxis;\n\n        if (!stacked) {\n          var field_1;\n\n          if (xAxis != this.baseAxis && xAxis instanceof ValueAxis) {\n            field_1 = this.xField;\n          }\n\n          if (yAxis != this.baseAxis && yAxis instanceof ValueAxis) {\n            field_1 = this.yField;\n          }\n\n          if (field_1) {\n            this.dataItems.each(function (dataItem) {\n              dataItem.setCalculatedValue(field_1, 0, \"stack\");\n            });\n          }\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"snapTooltip\", {\n    /**\r\n     * @return Should snap?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"snapTooltip\");\n    },\n\n    /**\r\n     * Should the nearest tooltip be shown if no data item is found on the\r\n     * current cursor position? In order this to work, you should set snapTooltip = false on the series baseAxis.\r\n     *\r\n     * @default false\r\n     * @param value  Should snap?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"snapTooltip\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Shows hidden series.\r\n   *\r\n   * @param duration  Duration of reveal animation (ms)\r\n   * @return Animation\r\n   */\n\n  XYSeries.prototype.show = function (duration) {\n    var _this = this;\n\n    if (this.isHidden) {\n      if (this.appeared && this.xAxis instanceof DateAxis && this.xAxis.groupData) {\n        this._tmin.setKey(this.yAxis.uid, undefined);\n\n        this._tmax.setKey(this.yAxis.uid, undefined);\n      }\n\n      if (this.appeared && this.yAxis instanceof DateAxis && this.yAxis.groupData) {\n        this._tmin.setKey(this.xAxis.uid, undefined);\n\n        this._tmax.setKey(this.xAxis.uid, undefined);\n      }\n    }\n\n    var fields;\n\n    if (this.xAxis instanceof ValueAxis && this.xAxis != this.baseAxis) {\n      fields = this._xValueFields;\n    }\n\n    if (this.yAxis instanceof ValueAxis && this.yAxis != this.baseAxis) {\n      fields = this._yValueFields;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var delay = 0;\n    var interpolationDuration = this.defaultState.transitionDuration;\n\n    if ($type.isNumber(duration)) {\n      interpolationDuration = duration;\n    }\n\n    if (!options.animationsEnabled) {\n      interpolationDuration = 0;\n    }\n\n    var anim;\n    $iter.each($iter.indexed(this.dataItems.iterator()), function (a) {\n      var i = a[0];\n      var dataItem = a[1];\n      var realDuration = interpolationDuration;\n\n      if (i < _this.startIndex - 10 || i > _this.endIndex + 10) {\n        realDuration = 0;\n        delay = 0;\n      }\n\n      if (_this.sequencedInterpolation && realDuration > 0) {\n        delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);\n      }\n\n      anim = dataItem.show(realDuration, delay, fields);\n    }); // other data sets\n\n    this.dataSets.each(function (key, dataSet) {\n      if (dataSet != _this.dataItems) {\n        dataSet.each(function (dataItem) {\n          dataItem.events.disable();\n          dataItem.show(0, 0, fields);\n          dataItem.events.enable();\n        });\n      }\n    });\n\n    if (this.mainDataSet != this.dataItems) {\n      this.mainDataSet.each(function (dataItem) {\n        dataItem.events.disable();\n        dataItem.show(0, 0, fields);\n        dataItem.events.enable();\n      });\n    }\n\n    var animation = _super.prototype.show.call(this, duration);\n\n    if (anim && !anim.isFinished()) {\n      animation = anim;\n    }\n\n    if (this.hidden) {\n      this.dispatchImmediately(\"selectionextremeschanged\");\n      this.hidden = false;\n    }\n\n    return animation;\n  };\n  /**\r\n   * Hides series.\r\n   *\r\n   * @param duration  Duration of hiding animation (ms)\r\n   * @return Animation\r\n   */\n\n\n  XYSeries.prototype.hide = function (duration) {\n    var _this = this;\n\n    var fields;\n    var value;\n    var xAxis = this.xAxis;\n\n    if (xAxis instanceof ValueAxis && xAxis != this.baseAxis) {\n      fields = this._xValueFields; // animate to zero if 0 is within zoomMin/zoomMax\n\n      if (this.stacked || xAxis.minZoomed < xAxis.baseValue && xAxis.maxZoomed > xAxis.baseValue || this.stackedSeries) {\n        value = xAxis.baseValue;\n      } else {\n        value = xAxis.min;\n      }\n    }\n\n    var yAxis = this.yAxis;\n\n    if (yAxis instanceof ValueAxis && yAxis != this.baseAxis) {\n      fields = this._yValueFields; // animate to zero if 0 is within zoomMin/zoomMax\n\n      if (this.stacked || yAxis.minZoomed < yAxis.baseValue && yAxis.maxZoomed > yAxis.baseValue || this.stackedSeries) {\n        value = yAxis.baseValue;\n      } else {\n        value = yAxis.min;\n      }\n    } //if ($type.hasValue(fields)) {\n\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var interpolationDuration = this.hiddenState.transitionDuration;\n\n    if ($type.isNumber(duration)) {\n      interpolationDuration = duration;\n    }\n\n    if (!options.animationsEnabled) {\n      interpolationDuration = 0;\n    }\n\n    var delay = 0;\n    var anim;\n    $iter.each($iter.indexed(this.dataItems.iterator()), function (a) {\n      var i = a[0];\n      var dataItem = a[1];\n      var realDuration = interpolationDuration;\n\n      if (i < _this.startIndex - 10 || i > _this.endIndex + 10) {\n        realDuration = 0;\n      }\n\n      if (realDuration == 0) {\n        dataItem.hide(0, 0, value, fields);\n      } else {\n        if (_this.sequencedInterpolation && realDuration > 0) {\n          delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);\n        }\n\n        anim = dataItem.hide(realDuration, delay, value, fields);\n      }\n    }); // other data sets\n\n    this.dataSets.each(function (key, dataSet) {\n      if (dataSet != _this.dataItems) {\n        dataSet.each(function (dataItem) {\n          dataItem.events.disable();\n          dataItem.hide(0, 0, value, fields);\n          dataItem.events.enable();\n        });\n      }\n    });\n\n    if (this.mainDataSet != this.dataItems) {\n      this.mainDataSet.each(function (dataItem) {\n        dataItem.events.disable();\n        dataItem.hide(0, 0, value, fields);\n        dataItem.events.enable();\n      });\n    }\n\n    var animation = _super.prototype.hide.call(this, interpolationDuration);\n\n    if (animation && !animation.isFinished()) {\n      animation.delay(delay);\n    }\n\n    if (anim && !anim.isFinished()) {\n      animation = anim;\n    } // helps to avoid flicker. otherwise columns will show up at full size and only on next frame will animate from 0\n\n\n    this.validateDataElements(); //}\n\n    return animation;\n  };\n  /**\r\n   * [handleDataItemWorkingValueChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  XYSeries.prototype.handleDataItemWorkingValueChange = function (dataItem, name) {\n    _super.prototype.handleDataItemWorkingValueChange.call(this, dataItem, name); // to calculate stack values\n\n\n    var axisSeries = this.baseAxis.series;\n    $iter.each(axisSeries.iterator(), function (series) {\n      if (series.stacked || series.stackedSeries) {\n        series.invalidateProcessedData();\n      }\n    });\n  };\n  /**\r\n   * [getStackValue description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n\n\n  XYSeries.prototype.getStackValue = function (dataItem, working) {\n    // todo: here wer stack x and y values only. question is - what should we do with other values, like openX, openY?\n    // if this series is not stacked or new stack begins, return.\n    var _this = this;\n\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n\n    if (!this.stacked || !xAxis || !yAxis) {\n      return;\n    } else {\n      // it might seem that it's better to go through base axis series, but we do not maintain the same order as in chart.series there.\n      var chart = this.chart;\n      var index = chart.series.indexOf(this);\n      var field_2;\n\n      if (xAxis != this.baseAxis && xAxis instanceof ValueAxis) {\n        field_2 = this.xField;\n      }\n\n      if (yAxis != this.baseAxis && yAxis instanceof ValueAxis) {\n        field_2 = this.yField;\n      }\n\n      if (!field_2) {\n        return;\n      } //this is good for removing series, otherwise stack values will remain the same and chart won't pay atention when adding/removing series\t\t\t\n\n\n      dataItem.setCalculatedValue(field_2, 0, \"stack\");\n      $iter.eachContinue(chart.series.range(0, index).backwards().iterator(), function (prevSeries) {\n        // stacking is only possible if both axes are the same\n        if (prevSeries.xAxis == xAxis && prevSeries.yAxis == yAxis && prevSeries.className == _this.className) {\n          // saving value\n          prevSeries.stackedSeries = _this;\n          var prevDataItem = prevSeries.dataItems.getIndex(dataItem.index); // indexes should match\n\n          if (prevDataItem && prevDataItem.hasValue(_this._xValueFields) && prevDataItem.hasValue(_this._yValueFields)) {\n            var value = dataItem.getValue(field_2);\n            var prevValue = void 0;\n            var prevRealValue = prevDataItem.getValue(field_2) + prevDataItem.getValue(field_2, \"stack\");\n\n            if (working) {\n              prevValue = prevDataItem.getWorkingValue(field_2) + prevDataItem.getValue(field_2, \"stack\");\n            } else {\n              prevValue = prevDataItem.getValue(field_2) + prevDataItem.getValue(field_2, \"stack\");\n            }\n\n            if (_this.stackToNegative) {\n              if (value >= 0 && prevRealValue >= 0 || value < 0 && prevRealValue < 0) {\n                dataItem.setCalculatedValue(field_2, prevValue, \"stack\");\n                return false;\n              } else if (!prevSeries.stacked) {\n                return false;\n              }\n            } else {\n              dataItem.setCalculatedValue(field_2, prevValue, \"stack\");\n              return false;\n            }\n          } else if (!prevSeries.stacked) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n\n  Object.defineProperty(XYSeries.prototype, \"stackToNegative\", {\n    /**\r\n     * @return Stack to base line\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"stackToNegative\");\n    },\n\n    /**\r\n     * This setting indicates how negative values are treated in stacked stacked\r\n     * series.\r\n     *\r\n     * If set to `true` (default), negative values will stack on the base line.\r\n     *\r\n     * If set to `false`, negative value will stack in relation to the previous\r\n     * value in the stack.\r\n     *\r\n     * @since 4.9.34\r\n     * @param  value  Stack to base line\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"stackToNegative\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"xField\", {\n    /**\r\n     * [xField description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._xField;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"yField\", {\n    /**\r\n     * [yField description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._yField;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"xOpenField\", {\n    /**\r\n     * [xOpenField description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._xOpenField;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"yOpenField\", {\n    /**\r\n     * [yOpenField description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._yOpenField;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"tooltipXField\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @return [description]\r\n     */\n    get: function () {\n      if (this._tooltipXField) {\n        return this._tooltipXField;\n      }\n\n      return this._xField;\n    },\n\n    /**\r\n     * [tooltipXField description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param value [description]\r\n     */\n    set: function (value) {\n      this._tooltipXField = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"tooltipYField\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @return [description]\r\n     */\n    get: function () {\n      if (this._tooltipYField) {\n        return this._tooltipYField;\n      }\n\n      return this._yField;\n    },\n\n    /**\r\n     * [tooltipYField description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param value [description]\r\n     */\n    set: function (value) {\n      this._tooltipYField = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns lowest value in the series for the specific axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axis  Axis\r\n   * @return value\r\n   */\n\n  XYSeries.prototype.min = function (axis) {\n    return this._tmin.getKey(axis.uid);\n  };\n  /**\r\n   * Returns highest value in the series for the specific axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axis  Axis\r\n   * @return value\r\n   */\n\n\n  XYSeries.prototype.max = function (axis) {\n    return this._tmax.getKey(axis.uid);\n  };\n  /**\r\n   * Returns lowest value in the series for the specific axis within current\r\n   * selection.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axis  Axis\r\n   * @return value\r\n   */\n\n\n  XYSeries.prototype.selectionMin = function (axis) {\n    var value = this._smin.getKey(axis.uid); // not good, because bad if there are no items with values in selection\n    //if (!$type.isNumber(value)) {\n    //value = this.min(axis);\n    //}\t\t\n\n\n    return value;\n  };\n  /**\r\n   * Returns highest value in the series for the specific axis within current\r\n   * selection.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axis  Axis\r\n   * @return value\r\n   */\n\n\n  XYSeries.prototype.selectionMax = function (axis) {\n    var value = this._smax.getKey(axis.uid); // not good, because bad if there are no items with values in selection\n    //if (!$type.isNumber(value)) {\n    //value = this.max(axis);\n    //}\n\n\n    return value;\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n\n  XYSeries.prototype.processConfig = function (config) {\n    if (config) {\n      // Set up base axes\n      if ($type.hasValue(config.baseAxis) && $type.isString(config.baseAxis)) {\n        if (this.map.hasKey(config.baseAxis)) {\n          config.baseAxis = this.map.getKey(config.baseAxis);\n        } else {\n          this.processingErrors.push(\"[XYSeries (\" + (this.name || \"unnamed\") + \")] No axis with id \\\"\" + config.baseAxis + \"\\\" found for `baseAxis`.\");\n          delete config.baseAxis;\n        }\n      } // Set up axes\n\n\n      if ($type.hasValue(config.xAxis) && $type.isString(config.xAxis)) {\n        if (this.map.hasKey(config.xAxis)) {\n          config.xAxis = this.map.getKey(config.xAxis);\n        } else {\n          this.processingErrors.push(\"[XYSeries (\" + (this.name || \"unnamed\") + \")] No axis with id \\\"\" + config.xAxis + \"\\\" found for `xAxis`.\");\n          delete config.xAxis;\n        }\n      }\n\n      if ($type.hasValue(config.yAxis) && $type.isString(config.yAxis)) {\n        if (this.map.hasKey(config.yAxis)) {\n          config.yAxis = this.map.getKey(config.yAxis);\n        } else {\n          this.processingErrors.push(\"[XYSeries (\" + (this.name || \"unnamed\") + \")] No axis with id \\\"\" + config.yAxis + \"\\\" found for `yAxis`.\");\n          delete config.yAxis;\n        }\n      } // Set up axis ranges\n\n\n      if ($type.hasValue(config.axisRanges) && $type.isArray(config.axisRanges)) {\n        for (var i = 0, len = config.axisRanges.length; i < len; i++) {\n          var range = config.axisRanges[i];\n\n          if (!$type.hasValue(range.type)) {\n            range.type = \"AxisDataItem\";\n          }\n\n          if ($type.hasValue(range.axis) && $type.isString(range.axis) && this.map.hasKey(range.axis)) {\n            range.component = this.map.getKey(range.axis);\n          } else if ($type.hasValue(range.component) && $type.isString(range.component) && this.map.hasKey(range.component)) {\n            range.component = this.map.getKey(range.component);\n          }\n        }\n      } // Parse date fields based on the series fields\n\n\n      if (!$type.hasValue(config.dataFields) || !$type.isObject(config.dataFields)) {\n        this.processingErrors.push(\"`dataFields` is not set for series [\" + (this.name || \"unnamed\") + \"]\");\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n  /**\r\n   * Returns an [[IPoint]] coordinates of the specific Serie's data point.\r\n   *\r\n   * @param    dataItem   Data item\r\n   * @param    xKey       Name of X data field\r\n   * @param    yKey       Name of Y data field\r\n   * @param    locationX  X location\r\n   * @param    locationY  Y location\r\n   * @param    stackKeyX  ?\r\n   * @param    stackKeyY  ?\r\n   * @returns             Coordinates\r\n   */\n\n\n  XYSeries.prototype.getPoint = function (dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {\n    if (this.xAxis && this.yAxis) {\n      var x = this.xAxis.getX(dataItem, xKey, locationX);\n      var y = this.yAxis.getY(dataItem, yKey, locationY);\n      x = $math.fitToRange(x, -this._maxxX, this._maxxX); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.\n\n      y = $math.fitToRange(y, -this._maxxY, this._maxxY); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  };\n  /**\r\n   * Updates item reader text based on the type and set up of axis.\r\n   */\n\n\n  XYSeries.prototype.updateItemReaderText = function () {\n    // We do not want to overwrite this if `itemReaderText` was changed by\n    // user code.\n    if (this._itemReaderTextChanged) {\n      return;\n    }\n\n    var text = \"\";\n    $object.each(this.dataFields, function (key, val) {\n      text += \"{\" + key + \"} \";\n    });\n    this.itemReaderText = text;\n    this._itemReaderTextChanged = false;\n  };\n\n  Object.defineProperty(XYSeries.prototype, \"cursorTooltipEnabled\", {\n    /**\r\n     * @return Display tooltip?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"cursorTooltipEnabled\");\n    },\n\n    /**\r\n     * Indicates if series should display a tooltip for chart's cursor.\r\n     *\r\n     * If set to `true` (default), the tooltips set for all series item's\r\n     * elements like columns and bullets will be automatically shown\r\n     * when [[XYCursor]] passes over category/date, even if its not hovered\r\n     * directly over the item.\r\n     *\r\n     * Set this to `false` to disable such behavior and display item-specific\r\n     * tooltips only when hovered directly over them\r\n     *\r\n     * @default true\r\n     * @param value Display tooltip?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"cursorTooltipEnabled\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"cursorHoverEnabled\", {\n    /**\r\n     * @return Hover enabled?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"cursorHoverEnabled\");\n    },\n\n    /**\r\n     * Indicates if series should apply hover state on bullets/columns/etc when\r\n     * cursor is over the data item.\r\n     *\r\n     * If set to `true` (default) and chart cursor is enabled on th chart,\r\n     * hovering over date/category will trigger hover states on related Series\r\n     * items like bullets and columns.\r\n     *\r\n     * @default true\r\n     * @since 4.2.2\r\n     * @param  value  Hover enabled?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"cursorHoverEnabled\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"excludeFromTotal\", {\n    /**\r\n     * @return Exclude from totals?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"excludeFromTotal\");\n    },\n\n    /**\r\n     * Indicates if series' values should be excluded when calculating totals.\r\n     *\r\n     * @default false\r\n     * @since 4.4.9\r\n     * @param  value  Exclude from totals?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"excludeFromTotal\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"hideTooltipWhileZooming\", {\n    /**\r\n     * @return Hide tooltip while zooming?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"hideTooltipWhileZooming\");\n    },\n\n    /**\r\n     * Indicates if series' tooltip should be hidden while series axis range is\r\n     * animating (zooming).\r\n     *\r\n     * @default true\r\n     * @since 4.7.16\r\n     * @param  value  Hide tooltip while zooming?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"hideTooltipWhileZooming\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"maskBullets\", {\n    /**\r\n     * @return Mask bullets?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maskBullets\");\n    },\n\n    /**\r\n     * Indicates if series' bullets should be masked.\r\n     *\r\n     * @default true\r\n     * @since 4.7.17\r\n     * @param  value  Mask bullets?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"maskBullets\", value);\n      var chart = this.chart;\n\n      if (chart) {\n        if (value) {\n          this.bulletsContainer.parent = chart.bulletsContainer;\n        } else {\n          this.bulletsContainer.parent = chart.axisBulletsContainer;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all properties from another instance of [[Series]].\r\n   *\r\n   * @param source  Source series\r\n   */\n\n  XYSeries.prototype.copyFrom = function (source) {\n    this.groupFields = $utils.copyProperties(source.groupFields, {});\n\n    _super.prototype.copyFrom.call(this, source);\n  };\n  /**\r\n   * Destroys this object and all related data.\r\n   */\n\n\n  XYSeries.prototype.dispose = function () {\n    if (this.scrollbarSeries) {\n      this.scrollbarSeries.dispose();\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n\n  return XYSeries;\n}(Series);\n\nexport { XYSeries };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"XYSeries\"] = XYSeries;\nregistry.registeredClasses[\"XYSeriesDataItem\"] = XYSeriesDataItem; //# sourceMappingURL=XYSeries.js.map","map":null,"metadata":{},"sourceType":"module"}